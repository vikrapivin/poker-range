// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pokerth.proto

#include "pokerth.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr NetGameInfo::NetGameInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : manualblinds_()
  , _manualblinds_cached_byte_size_(0)
  , gamename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , maxnumplayers_(0u)
  , raiseeveryhands_(0u)
  , raiseeveryminutes_(0u)
  , endraisesmallblindvalue_(0u)
  , proposedguispeed_(0u)
  , delaybetweenhands_(0u)
  , playeractiontimeout_(0u)
  , firstsmallblind_(0u)
  , startmoney_(0u)
  , netgametype_(1)

  , raiseintervalmode_(1)

  , endraisemode_(1)

  , allowspectators_(true){}
struct NetGameInfoDefaultTypeInternal {
  constexpr NetGameInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NetGameInfoDefaultTypeInternal() {}
  union {
    NetGameInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NetGameInfoDefaultTypeInternal _NetGameInfo_default_instance_;
constexpr PlayerResult::PlayerResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : besthandposition_()
  , _besthandposition_cached_byte_size_(0)
  , playerid_(0u)
  , resultcard1_(0u)
  , resultcard2_(0u)
  , moneywon_(0u)
  , playermoney_(0u)
  , cardsvalue_(0u){}
struct PlayerResultDefaultTypeInternal {
  constexpr PlayerResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerResultDefaultTypeInternal() {}
  union {
    PlayerResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerResultDefaultTypeInternal _PlayerResult_default_instance_;
constexpr AnnounceMessage_Version::AnnounceMessage_Version(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : majorversion_(0u)
  , minorversion_(0u){}
struct AnnounceMessage_VersionDefaultTypeInternal {
  constexpr AnnounceMessage_VersionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnnounceMessage_VersionDefaultTypeInternal() {}
  union {
    AnnounceMessage_Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnnounceMessage_VersionDefaultTypeInternal _AnnounceMessage_Version_default_instance_;
constexpr AnnounceMessage::AnnounceMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : protocolversion_(nullptr)
  , latestgameversion_(nullptr)
  , latestbetarevision_(0u)
  , servertype_(0)

  , numplayersonserver_(0u){}
struct AnnounceMessageDefaultTypeInternal {
  constexpr AnnounceMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnnounceMessageDefaultTypeInternal() {}
  union {
    AnnounceMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnnounceMessageDefaultTypeInternal _AnnounceMessage_default_instance_;
constexpr InitMessage::InitMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mylastsessionid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , authserverpassword_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nickname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , clientuserdata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , avatarhash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , requestedversion_(nullptr)
  , buildid_(0u)
  , login_(0)
{}
struct InitMessageDefaultTypeInternal {
  constexpr InitMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitMessageDefaultTypeInternal() {}
  union {
    InitMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitMessageDefaultTypeInternal _InitMessage_default_instance_;
constexpr AuthServerChallengeMessage::AuthServerChallengeMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : serverchallenge_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AuthServerChallengeMessageDefaultTypeInternal {
  constexpr AuthServerChallengeMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AuthServerChallengeMessageDefaultTypeInternal() {}
  union {
    AuthServerChallengeMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AuthServerChallengeMessageDefaultTypeInternal _AuthServerChallengeMessage_default_instance_;
constexpr AuthClientResponseMessage::AuthClientResponseMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : clientresponse_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AuthClientResponseMessageDefaultTypeInternal {
  constexpr AuthClientResponseMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AuthClientResponseMessageDefaultTypeInternal() {}
  union {
    AuthClientResponseMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AuthClientResponseMessageDefaultTypeInternal _AuthClientResponseMessage_default_instance_;
constexpr AuthServerVerificationMessage::AuthServerVerificationMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : serververification_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AuthServerVerificationMessageDefaultTypeInternal {
  constexpr AuthServerVerificationMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AuthServerVerificationMessageDefaultTypeInternal() {}
  union {
    AuthServerVerificationMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AuthServerVerificationMessageDefaultTypeInternal _AuthServerVerificationMessage_default_instance_;
constexpr InitAckMessage::InitAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : yoursessionid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , youravatarhash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , yourplayerid_(0u)
  , rejoingameid_(0u){}
struct InitAckMessageDefaultTypeInternal {
  constexpr InitAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitAckMessageDefaultTypeInternal() {}
  union {
    InitAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitAckMessageDefaultTypeInternal _InitAckMessage_default_instance_;
constexpr AvatarRequestMessage::AvatarRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : avatarhash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , requestid_(0u){}
struct AvatarRequestMessageDefaultTypeInternal {
  constexpr AvatarRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvatarRequestMessageDefaultTypeInternal() {}
  union {
    AvatarRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvatarRequestMessageDefaultTypeInternal _AvatarRequestMessage_default_instance_;
constexpr AvatarHeaderMessage::AvatarHeaderMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : requestid_(0u)
  , avatarsize_(0u)
  , avatartype_(1)
{}
struct AvatarHeaderMessageDefaultTypeInternal {
  constexpr AvatarHeaderMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvatarHeaderMessageDefaultTypeInternal() {}
  union {
    AvatarHeaderMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvatarHeaderMessageDefaultTypeInternal _AvatarHeaderMessage_default_instance_;
constexpr AvatarDataMessage::AvatarDataMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : avatarblock_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , requestid_(0u){}
struct AvatarDataMessageDefaultTypeInternal {
  constexpr AvatarDataMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvatarDataMessageDefaultTypeInternal() {}
  union {
    AvatarDataMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvatarDataMessageDefaultTypeInternal _AvatarDataMessage_default_instance_;
constexpr AvatarEndMessage::AvatarEndMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : requestid_(0u){}
struct AvatarEndMessageDefaultTypeInternal {
  constexpr AvatarEndMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvatarEndMessageDefaultTypeInternal() {}
  union {
    AvatarEndMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvatarEndMessageDefaultTypeInternal _AvatarEndMessage_default_instance_;
constexpr UnknownAvatarMessage::UnknownAvatarMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : requestid_(0u){}
struct UnknownAvatarMessageDefaultTypeInternal {
  constexpr UnknownAvatarMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UnknownAvatarMessageDefaultTypeInternal() {}
  union {
    UnknownAvatarMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UnknownAvatarMessageDefaultTypeInternal _UnknownAvatarMessage_default_instance_;
constexpr PlayerListMessage::PlayerListMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerid_(0u)
  , playerlistnotification_(0)
{}
struct PlayerListMessageDefaultTypeInternal {
  constexpr PlayerListMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerListMessageDefaultTypeInternal() {}
  union {
    PlayerListMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerListMessageDefaultTypeInternal _PlayerListMessage_default_instance_;
constexpr GameListNewMessage::GameListNewMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerids_()
  , _playerids_cached_byte_size_(0)
  , spectatorids_()
  , _spectatorids_cached_byte_size_(0)
  , gameinfo_(nullptr)
  , gameid_(0u)
  , isprivate_(false)
  , adminplayerid_(0u)
  , gamemode_(1)
{}
struct GameListNewMessageDefaultTypeInternal {
  constexpr GameListNewMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListNewMessageDefaultTypeInternal() {}
  union {
    GameListNewMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListNewMessageDefaultTypeInternal _GameListNewMessage_default_instance_;
constexpr GameListUpdateMessage::GameListUpdateMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , gamemode_(1)
{}
struct GameListUpdateMessageDefaultTypeInternal {
  constexpr GameListUpdateMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListUpdateMessageDefaultTypeInternal() {}
  union {
    GameListUpdateMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListUpdateMessageDefaultTypeInternal _GameListUpdateMessage_default_instance_;
constexpr GameListPlayerJoinedMessage::GameListPlayerJoinedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct GameListPlayerJoinedMessageDefaultTypeInternal {
  constexpr GameListPlayerJoinedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListPlayerJoinedMessageDefaultTypeInternal() {}
  union {
    GameListPlayerJoinedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListPlayerJoinedMessageDefaultTypeInternal _GameListPlayerJoinedMessage_default_instance_;
constexpr GameListPlayerLeftMessage::GameListPlayerLeftMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct GameListPlayerLeftMessageDefaultTypeInternal {
  constexpr GameListPlayerLeftMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListPlayerLeftMessageDefaultTypeInternal() {}
  union {
    GameListPlayerLeftMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListPlayerLeftMessageDefaultTypeInternal _GameListPlayerLeftMessage_default_instance_;
constexpr GameListSpectatorJoinedMessage::GameListSpectatorJoinedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct GameListSpectatorJoinedMessageDefaultTypeInternal {
  constexpr GameListSpectatorJoinedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListSpectatorJoinedMessageDefaultTypeInternal() {}
  union {
    GameListSpectatorJoinedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListSpectatorJoinedMessageDefaultTypeInternal _GameListSpectatorJoinedMessage_default_instance_;
constexpr GameListSpectatorLeftMessage::GameListSpectatorLeftMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct GameListSpectatorLeftMessageDefaultTypeInternal {
  constexpr GameListSpectatorLeftMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListSpectatorLeftMessageDefaultTypeInternal() {}
  union {
    GameListSpectatorLeftMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListSpectatorLeftMessageDefaultTypeInternal _GameListSpectatorLeftMessage_default_instance_;
constexpr GameListAdminChangedMessage::GameListAdminChangedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , newadminplayerid_(0u){}
struct GameListAdminChangedMessageDefaultTypeInternal {
  constexpr GameListAdminChangedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameListAdminChangedMessageDefaultTypeInternal() {}
  union {
    GameListAdminChangedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameListAdminChangedMessageDefaultTypeInternal _GameListAdminChangedMessage_default_instance_;
constexpr PlayerInfoRequestMessage::PlayerInfoRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerid_()
  , _playerid_cached_byte_size_(0){}
struct PlayerInfoRequestMessageDefaultTypeInternal {
  constexpr PlayerInfoRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerInfoRequestMessageDefaultTypeInternal() {}
  union {
    PlayerInfoRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerInfoRequestMessageDefaultTypeInternal _PlayerInfoRequestMessage_default_instance_;
constexpr PlayerInfoReplyMessage_PlayerInfoData_AvatarData::PlayerInfoReplyMessage_PlayerInfoData_AvatarData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : avatarhash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , avatartype_(1)
{}
struct PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal {
  constexpr PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal() {}
  union {
    PlayerInfoReplyMessage_PlayerInfoData_AvatarData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal _PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_;
constexpr PlayerInfoReplyMessage_PlayerInfoData::PlayerInfoReplyMessage_PlayerInfoData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playername_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , countrycode_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , avatardata_(nullptr)
  , ishuman_(false)
  , playerrights_(1)
{}
struct PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal {
  constexpr PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal() {}
  union {
    PlayerInfoReplyMessage_PlayerInfoData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal _PlayerInfoReplyMessage_PlayerInfoData_default_instance_;
constexpr PlayerInfoReplyMessage::PlayerInfoReplyMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerinfodata_(nullptr)
  , playerid_(0u){}
struct PlayerInfoReplyMessageDefaultTypeInternal {
  constexpr PlayerInfoReplyMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerInfoReplyMessageDefaultTypeInternal() {}
  union {
    PlayerInfoReplyMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerInfoReplyMessageDefaultTypeInternal _PlayerInfoReplyMessage_default_instance_;
constexpr SubscriptionRequestMessage::SubscriptionRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subscriptionaction_(1)
{}
struct SubscriptionRequestMessageDefaultTypeInternal {
  constexpr SubscriptionRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SubscriptionRequestMessageDefaultTypeInternal() {}
  union {
    SubscriptionRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SubscriptionRequestMessageDefaultTypeInternal _SubscriptionRequestMessage_default_instance_;
constexpr JoinExistingGameMessage::JoinExistingGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gameid_(0u)
  , autoleave_(false)
  , spectateonly_(false){}
struct JoinExistingGameMessageDefaultTypeInternal {
  constexpr JoinExistingGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JoinExistingGameMessageDefaultTypeInternal() {}
  union {
    JoinExistingGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JoinExistingGameMessageDefaultTypeInternal _JoinExistingGameMessage_default_instance_;
constexpr JoinNewGameMessage::JoinNewGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gameinfo_(nullptr)
  , autoleave_(false){}
struct JoinNewGameMessageDefaultTypeInternal {
  constexpr JoinNewGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JoinNewGameMessageDefaultTypeInternal() {}
  union {
    JoinNewGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JoinNewGameMessageDefaultTypeInternal _JoinNewGameMessage_default_instance_;
constexpr RejoinExistingGameMessage::RejoinExistingGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , autoleave_(false){}
struct RejoinExistingGameMessageDefaultTypeInternal {
  constexpr RejoinExistingGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RejoinExistingGameMessageDefaultTypeInternal() {}
  union {
    RejoinExistingGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RejoinExistingGameMessageDefaultTypeInternal _RejoinExistingGameMessage_default_instance_;
constexpr JoinGameAckMessage::JoinGameAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameinfo_(nullptr)
  , gameid_(0u)
  , areyougameadmin_(false)
  , spectateonly_(false){}
struct JoinGameAckMessageDefaultTypeInternal {
  constexpr JoinGameAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JoinGameAckMessageDefaultTypeInternal() {}
  union {
    JoinGameAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JoinGameAckMessageDefaultTypeInternal _JoinGameAckMessage_default_instance_;
constexpr JoinGameFailedMessage::JoinGameFailedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , joingamefailurereason_(1)
{}
struct JoinGameFailedMessageDefaultTypeInternal {
  constexpr JoinGameFailedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JoinGameFailedMessageDefaultTypeInternal() {}
  union {
    JoinGameFailedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JoinGameFailedMessageDefaultTypeInternal _JoinGameFailedMessage_default_instance_;
constexpr GamePlayerJoinedMessage::GamePlayerJoinedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , isgameadmin_(false){}
struct GamePlayerJoinedMessageDefaultTypeInternal {
  constexpr GamePlayerJoinedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GamePlayerJoinedMessageDefaultTypeInternal() {}
  union {
    GamePlayerJoinedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GamePlayerJoinedMessageDefaultTypeInternal _GamePlayerJoinedMessage_default_instance_;
constexpr GamePlayerLeftMessage::GamePlayerLeftMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , gameplayerleftreason_(0)
{}
struct GamePlayerLeftMessageDefaultTypeInternal {
  constexpr GamePlayerLeftMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GamePlayerLeftMessageDefaultTypeInternal() {}
  union {
    GamePlayerLeftMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GamePlayerLeftMessageDefaultTypeInternal _GamePlayerLeftMessage_default_instance_;
constexpr GameSpectatorJoinedMessage::GameSpectatorJoinedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct GameSpectatorJoinedMessageDefaultTypeInternal {
  constexpr GameSpectatorJoinedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameSpectatorJoinedMessageDefaultTypeInternal() {}
  union {
    GameSpectatorJoinedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameSpectatorJoinedMessageDefaultTypeInternal _GameSpectatorJoinedMessage_default_instance_;
constexpr GameSpectatorLeftMessage::GameSpectatorLeftMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , gamespectatorleftreason_(0)
{}
struct GameSpectatorLeftMessageDefaultTypeInternal {
  constexpr GameSpectatorLeftMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameSpectatorLeftMessageDefaultTypeInternal() {}
  union {
    GameSpectatorLeftMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameSpectatorLeftMessageDefaultTypeInternal _GameSpectatorLeftMessage_default_instance_;
constexpr GameAdminChangedMessage::GameAdminChangedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , newadminplayerid_(0u){}
struct GameAdminChangedMessageDefaultTypeInternal {
  constexpr GameAdminChangedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameAdminChangedMessageDefaultTypeInternal() {}
  union {
    GameAdminChangedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameAdminChangedMessageDefaultTypeInternal _GameAdminChangedMessage_default_instance_;
constexpr RemovedFromGameMessage::RemovedFromGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , removedfromgamereason_(0)
{}
struct RemovedFromGameMessageDefaultTypeInternal {
  constexpr RemovedFromGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RemovedFromGameMessageDefaultTypeInternal() {}
  union {
    RemovedFromGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RemovedFromGameMessageDefaultTypeInternal _RemovedFromGameMessage_default_instance_;
constexpr KickPlayerRequestMessage::KickPlayerRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct KickPlayerRequestMessageDefaultTypeInternal {
  constexpr KickPlayerRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KickPlayerRequestMessageDefaultTypeInternal() {}
  union {
    KickPlayerRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KickPlayerRequestMessageDefaultTypeInternal _KickPlayerRequestMessage_default_instance_;
constexpr LeaveGameRequestMessage::LeaveGameRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u){}
struct LeaveGameRequestMessageDefaultTypeInternal {
  constexpr LeaveGameRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LeaveGameRequestMessageDefaultTypeInternal() {}
  union {
    LeaveGameRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LeaveGameRequestMessageDefaultTypeInternal _LeaveGameRequestMessage_default_instance_;
constexpr InvitePlayerToGameMessage::InvitePlayerToGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct InvitePlayerToGameMessageDefaultTypeInternal {
  constexpr InvitePlayerToGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InvitePlayerToGameMessageDefaultTypeInternal() {}
  union {
    InvitePlayerToGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InvitePlayerToGameMessageDefaultTypeInternal _InvitePlayerToGameMessage_default_instance_;
constexpr InviteNotifyMessage::InviteNotifyMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playeridwho_(0u)
  , playeridbywhom_(0u){}
struct InviteNotifyMessageDefaultTypeInternal {
  constexpr InviteNotifyMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InviteNotifyMessageDefaultTypeInternal() {}
  union {
    InviteNotifyMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InviteNotifyMessageDefaultTypeInternal _InviteNotifyMessage_default_instance_;
constexpr RejectGameInvitationMessage::RejectGameInvitationMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , myrejectreason_(0)
{}
struct RejectGameInvitationMessageDefaultTypeInternal {
  constexpr RejectGameInvitationMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RejectGameInvitationMessageDefaultTypeInternal() {}
  union {
    RejectGameInvitationMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RejectGameInvitationMessageDefaultTypeInternal _RejectGameInvitationMessage_default_instance_;
constexpr RejectInvNotifyMessage::RejectInvNotifyMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , playerrejectreason_(0)
{}
struct RejectInvNotifyMessageDefaultTypeInternal {
  constexpr RejectInvNotifyMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RejectInvNotifyMessageDefaultTypeInternal() {}
  union {
    RejectInvNotifyMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RejectInvNotifyMessageDefaultTypeInternal _RejectInvNotifyMessage_default_instance_;
constexpr StartEventMessage::StartEventMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , starteventtype_(0)

  , fillwithcomputerplayers_(false){}
struct StartEventMessageDefaultTypeInternal {
  constexpr StartEventMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StartEventMessageDefaultTypeInternal() {}
  union {
    StartEventMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StartEventMessageDefaultTypeInternal _StartEventMessage_default_instance_;
constexpr StartEventAckMessage::StartEventAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u){}
struct StartEventAckMessageDefaultTypeInternal {
  constexpr StartEventAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StartEventAckMessageDefaultTypeInternal() {}
  union {
    StartEventAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StartEventAckMessageDefaultTypeInternal _StartEventAckMessage_default_instance_;
constexpr GameStartInitialMessage::GameStartInitialMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerseats_()
  , _playerseats_cached_byte_size_(0)
  , gameid_(0u)
  , startdealerplayerid_(0u){}
struct GameStartInitialMessageDefaultTypeInternal {
  constexpr GameStartInitialMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameStartInitialMessageDefaultTypeInternal() {}
  union {
    GameStartInitialMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameStartInitialMessageDefaultTypeInternal _GameStartInitialMessage_default_instance_;
constexpr GameStartRejoinMessage_RejoinPlayerData::GameStartRejoinMessage_RejoinPlayerData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerid_(0u)
  , playermoney_(0u){}
struct GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal {
  constexpr GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal() {}
  union {
    GameStartRejoinMessage_RejoinPlayerData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal _GameStartRejoinMessage_RejoinPlayerData_default_instance_;
constexpr GameStartRejoinMessage::GameStartRejoinMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rejoinplayerdata_()
  , gameid_(0u)
  , startdealerplayerid_(0u)
  , handnum_(0u){}
struct GameStartRejoinMessageDefaultTypeInternal {
  constexpr GameStartRejoinMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameStartRejoinMessageDefaultTypeInternal() {}
  union {
    GameStartRejoinMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameStartRejoinMessageDefaultTypeInternal _GameStartRejoinMessage_default_instance_;
constexpr HandStartMessage_PlainCards::HandStartMessage_PlainCards(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : plaincard1_(0u)
  , plaincard2_(0u){}
struct HandStartMessage_PlainCardsDefaultTypeInternal {
  constexpr HandStartMessage_PlainCardsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HandStartMessage_PlainCardsDefaultTypeInternal() {}
  union {
    HandStartMessage_PlainCards _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HandStartMessage_PlainCardsDefaultTypeInternal _HandStartMessage_PlainCards_default_instance_;
constexpr HandStartMessage::HandStartMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seatstates_()
  , encryptedcards_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , plaincards_(nullptr)
  , gameid_(0u)
  , smallblind_(0u)
  , dealerplayerid_(0u){}
struct HandStartMessageDefaultTypeInternal {
  constexpr HandStartMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HandStartMessageDefaultTypeInternal() {}
  union {
    HandStartMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HandStartMessageDefaultTypeInternal _HandStartMessage_default_instance_;
constexpr PlayersTurnMessage::PlayersTurnMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , gamestate_(0)
{}
struct PlayersTurnMessageDefaultTypeInternal {
  constexpr PlayersTurnMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayersTurnMessageDefaultTypeInternal() {}
  union {
    PlayersTurnMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayersTurnMessageDefaultTypeInternal _PlayersTurnMessage_default_instance_;
constexpr MyActionRequestMessage::MyActionRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , handnum_(0u)
  , gamestate_(0)

  , myaction_(0)

  , myrelativebet_(0u){}
struct MyActionRequestMessageDefaultTypeInternal {
  constexpr MyActionRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MyActionRequestMessageDefaultTypeInternal() {}
  union {
    MyActionRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MyActionRequestMessageDefaultTypeInternal _MyActionRequestMessage_default_instance_;
constexpr YourActionRejectedMessage::YourActionRejectedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , gamestate_(0)

  , youraction_(0)

  , yourrelativebet_(0u)
  , rejectionreason_(1)
{}
struct YourActionRejectedMessageDefaultTypeInternal {
  constexpr YourActionRejectedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~YourActionRejectedMessageDefaultTypeInternal() {}
  union {
    YourActionRejectedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT YourActionRejectedMessageDefaultTypeInternal _YourActionRejectedMessage_default_instance_;
constexpr PlayersActionDoneMessage::PlayersActionDoneMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , gamestate_(0)

  , playeraction_(0)

  , totalplayerbet_(0u)
  , playermoney_(0u)
  , highestset_(0u)
  , minimumraise_(0u){}
struct PlayersActionDoneMessageDefaultTypeInternal {
  constexpr PlayersActionDoneMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayersActionDoneMessageDefaultTypeInternal() {}
  union {
    PlayersActionDoneMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayersActionDoneMessageDefaultTypeInternal _PlayersActionDoneMessage_default_instance_;
constexpr DealFlopCardsMessage::DealFlopCardsMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , flopcard1_(0u)
  , flopcard2_(0u)
  , flopcard3_(0u){}
struct DealFlopCardsMessageDefaultTypeInternal {
  constexpr DealFlopCardsMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DealFlopCardsMessageDefaultTypeInternal() {}
  union {
    DealFlopCardsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DealFlopCardsMessageDefaultTypeInternal _DealFlopCardsMessage_default_instance_;
constexpr DealTurnCardMessage::DealTurnCardMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , turncard_(0u){}
struct DealTurnCardMessageDefaultTypeInternal {
  constexpr DealTurnCardMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DealTurnCardMessageDefaultTypeInternal() {}
  union {
    DealTurnCardMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DealTurnCardMessageDefaultTypeInternal _DealTurnCardMessage_default_instance_;
constexpr DealRiverCardMessage::DealRiverCardMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , rivercard_(0u){}
struct DealRiverCardMessageDefaultTypeInternal {
  constexpr DealRiverCardMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DealRiverCardMessageDefaultTypeInternal() {}
  union {
    DealRiverCardMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DealRiverCardMessageDefaultTypeInternal _DealRiverCardMessage_default_instance_;
constexpr AllInShowCardsMessage_PlayerAllIn::AllInShowCardsMessage_PlayerAllIn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerid_(0u)
  , allincard1_(0u)
  , allincard2_(0u){}
struct AllInShowCardsMessage_PlayerAllInDefaultTypeInternal {
  constexpr AllInShowCardsMessage_PlayerAllInDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AllInShowCardsMessage_PlayerAllInDefaultTypeInternal() {}
  union {
    AllInShowCardsMessage_PlayerAllIn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AllInShowCardsMessage_PlayerAllInDefaultTypeInternal _AllInShowCardsMessage_PlayerAllIn_default_instance_;
constexpr AllInShowCardsMessage::AllInShowCardsMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playersallin_()
  , gameid_(0u){}
struct AllInShowCardsMessageDefaultTypeInternal {
  constexpr AllInShowCardsMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AllInShowCardsMessageDefaultTypeInternal() {}
  union {
    AllInShowCardsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AllInShowCardsMessageDefaultTypeInternal _AllInShowCardsMessage_default_instance_;
constexpr EndOfHandShowCardsMessage::EndOfHandShowCardsMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerresults_()
  , gameid_(0u){}
struct EndOfHandShowCardsMessageDefaultTypeInternal {
  constexpr EndOfHandShowCardsMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EndOfHandShowCardsMessageDefaultTypeInternal() {}
  union {
    EndOfHandShowCardsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EndOfHandShowCardsMessageDefaultTypeInternal _EndOfHandShowCardsMessage_default_instance_;
constexpr EndOfHandHideCardsMessage::EndOfHandHideCardsMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , moneywon_(0u)
  , playermoney_(0u){}
struct EndOfHandHideCardsMessageDefaultTypeInternal {
  constexpr EndOfHandHideCardsMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EndOfHandHideCardsMessageDefaultTypeInternal() {}
  union {
    EndOfHandHideCardsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EndOfHandHideCardsMessageDefaultTypeInternal _EndOfHandHideCardsMessage_default_instance_;
constexpr ShowMyCardsRequestMessage::ShowMyCardsRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ShowMyCardsRequestMessageDefaultTypeInternal {
  constexpr ShowMyCardsRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ShowMyCardsRequestMessageDefaultTypeInternal() {}
  union {
    ShowMyCardsRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ShowMyCardsRequestMessageDefaultTypeInternal _ShowMyCardsRequestMessage_default_instance_;
constexpr AfterHandShowCardsMessage::AfterHandShowCardsMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : playerresult_(nullptr){}
struct AfterHandShowCardsMessageDefaultTypeInternal {
  constexpr AfterHandShowCardsMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AfterHandShowCardsMessageDefaultTypeInternal() {}
  union {
    AfterHandShowCardsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AfterHandShowCardsMessageDefaultTypeInternal _AfterHandShowCardsMessage_default_instance_;
constexpr EndOfGameMessage::EndOfGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , winnerplayerid_(0u){}
struct EndOfGameMessageDefaultTypeInternal {
  constexpr EndOfGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EndOfGameMessageDefaultTypeInternal() {}
  union {
    EndOfGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EndOfGameMessageDefaultTypeInternal _EndOfGameMessage_default_instance_;
constexpr PlayerIdChangedMessage::PlayerIdChangedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : oldplayerid_(0u)
  , newplayerid_(0u){}
struct PlayerIdChangedMessageDefaultTypeInternal {
  constexpr PlayerIdChangedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerIdChangedMessageDefaultTypeInternal() {}
  union {
    PlayerIdChangedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerIdChangedMessageDefaultTypeInternal _PlayerIdChangedMessage_default_instance_;
constexpr AskKickPlayerMessage::AskKickPlayerMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u){}
struct AskKickPlayerMessageDefaultTypeInternal {
  constexpr AskKickPlayerMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AskKickPlayerMessageDefaultTypeInternal() {}
  union {
    AskKickPlayerMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AskKickPlayerMessageDefaultTypeInternal _AskKickPlayerMessage_default_instance_;
constexpr AskKickDeniedMessage::AskKickDeniedMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , playerid_(0u)
  , kickdeniedreason_(0)
{}
struct AskKickDeniedMessageDefaultTypeInternal {
  constexpr AskKickDeniedMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AskKickDeniedMessageDefaultTypeInternal() {}
  union {
    AskKickDeniedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AskKickDeniedMessageDefaultTypeInternal _AskKickDeniedMessage_default_instance_;
constexpr StartKickPetitionMessage::StartKickPetitionMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , petitionid_(0u)
  , proposingplayerid_(0u)
  , kickplayerid_(0u)
  , kicktimeoutsec_(0u)
  , numvotesneededtokick_(0u){}
struct StartKickPetitionMessageDefaultTypeInternal {
  constexpr StartKickPetitionMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StartKickPetitionMessageDefaultTypeInternal() {}
  union {
    StartKickPetitionMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StartKickPetitionMessageDefaultTypeInternal _StartKickPetitionMessage_default_instance_;
constexpr VoteKickRequestMessage::VoteKickRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , petitionid_(0u)
  , votekick_(false){}
struct VoteKickRequestMessageDefaultTypeInternal {
  constexpr VoteKickRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VoteKickRequestMessageDefaultTypeInternal() {}
  union {
    VoteKickRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VoteKickRequestMessageDefaultTypeInternal _VoteKickRequestMessage_default_instance_;
constexpr VoteKickReplyMessage::VoteKickReplyMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , petitionid_(0u)
  , votekickreplytype_(0)
{}
struct VoteKickReplyMessageDefaultTypeInternal {
  constexpr VoteKickReplyMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VoteKickReplyMessageDefaultTypeInternal() {}
  union {
    VoteKickReplyMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VoteKickReplyMessageDefaultTypeInternal _VoteKickReplyMessage_default_instance_;
constexpr KickPetitionUpdateMessage::KickPetitionUpdateMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , petitionid_(0u)
  , numvotesagainstkicking_(0u)
  , numvotesinfavourofkicking_(0u)
  , numvotesneededtokick_(0u){}
struct KickPetitionUpdateMessageDefaultTypeInternal {
  constexpr KickPetitionUpdateMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KickPetitionUpdateMessageDefaultTypeInternal() {}
  union {
    KickPetitionUpdateMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KickPetitionUpdateMessageDefaultTypeInternal _KickPetitionUpdateMessage_default_instance_;
constexpr EndKickPetitionMessage::EndKickPetitionMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(0u)
  , petitionid_(0u)
  , numvotesagainstkicking_(0u)
  , numvotesinfavourofkicking_(0u)
  , resultplayerkicked_(0u)
  , petitionendreason_(0)
{}
struct EndKickPetitionMessageDefaultTypeInternal {
  constexpr EndKickPetitionMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EndKickPetitionMessageDefaultTypeInternal() {}
  union {
    EndKickPetitionMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EndKickPetitionMessageDefaultTypeInternal _EndKickPetitionMessage_default_instance_;
constexpr StatisticsMessage_StatisticsData::StatisticsMessage_StatisticsData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : statisticsvalue_(0u)
  , statisticstype_(1)
{}
struct StatisticsMessage_StatisticsDataDefaultTypeInternal {
  constexpr StatisticsMessage_StatisticsDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatisticsMessage_StatisticsDataDefaultTypeInternal() {}
  union {
    StatisticsMessage_StatisticsData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatisticsMessage_StatisticsDataDefaultTypeInternal _StatisticsMessage_StatisticsData_default_instance_;
constexpr StatisticsMessage::StatisticsMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : statisticsdata_(){}
struct StatisticsMessageDefaultTypeInternal {
  constexpr StatisticsMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatisticsMessageDefaultTypeInternal() {}
  union {
    StatisticsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatisticsMessageDefaultTypeInternal _StatisticsMessage_default_instance_;
constexpr ChatRequestMessage::ChatRequestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : chattext_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , targetgameid_(0u)
  , targetplayerid_(0u){}
struct ChatRequestMessageDefaultTypeInternal {
  constexpr ChatRequestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChatRequestMessageDefaultTypeInternal() {}
  union {
    ChatRequestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChatRequestMessageDefaultTypeInternal _ChatRequestMessage_default_instance_;
constexpr ChatMessage::ChatMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : chattext_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gameid_(0u)
  , playerid_(0u)
  , chattype_(0)
{}
struct ChatMessageDefaultTypeInternal {
  constexpr ChatMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChatMessageDefaultTypeInternal() {}
  union {
    ChatMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
constexpr ChatRejectMessage::ChatRejectMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : chattext_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ChatRejectMessageDefaultTypeInternal {
  constexpr ChatRejectMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChatRejectMessageDefaultTypeInternal() {}
  union {
    ChatRejectMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChatRejectMessageDefaultTypeInternal _ChatRejectMessage_default_instance_;
constexpr DialogMessage::DialogMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : notificationtext_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DialogMessageDefaultTypeInternal {
  constexpr DialogMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DialogMessageDefaultTypeInternal() {}
  union {
    DialogMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DialogMessageDefaultTypeInternal _DialogMessage_default_instance_;
constexpr TimeoutWarningMessage::TimeoutWarningMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timeoutreason_(0)

  , remainingseconds_(0u){}
struct TimeoutWarningMessageDefaultTypeInternal {
  constexpr TimeoutWarningMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TimeoutWarningMessageDefaultTypeInternal() {}
  union {
    TimeoutWarningMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TimeoutWarningMessageDefaultTypeInternal _TimeoutWarningMessage_default_instance_;
constexpr ResetTimeoutMessage::ResetTimeoutMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ResetTimeoutMessageDefaultTypeInternal {
  constexpr ResetTimeoutMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ResetTimeoutMessageDefaultTypeInternal() {}
  union {
    ResetTimeoutMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ResetTimeoutMessageDefaultTypeInternal _ResetTimeoutMessage_default_instance_;
constexpr ReportAvatarMessage::ReportAvatarMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reportedavatarhash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , reportedplayerid_(0u){}
struct ReportAvatarMessageDefaultTypeInternal {
  constexpr ReportAvatarMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReportAvatarMessageDefaultTypeInternal() {}
  union {
    ReportAvatarMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReportAvatarMessageDefaultTypeInternal _ReportAvatarMessage_default_instance_;
constexpr ReportAvatarAckMessage::ReportAvatarAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reportedplayerid_(0u)
  , reportavatarresult_(0)
{}
struct ReportAvatarAckMessageDefaultTypeInternal {
  constexpr ReportAvatarAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReportAvatarAckMessageDefaultTypeInternal() {}
  union {
    ReportAvatarAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReportAvatarAckMessageDefaultTypeInternal _ReportAvatarAckMessage_default_instance_;
constexpr ReportGameMessage::ReportGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reportedgameid_(0u){}
struct ReportGameMessageDefaultTypeInternal {
  constexpr ReportGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReportGameMessageDefaultTypeInternal() {}
  union {
    ReportGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReportGameMessageDefaultTypeInternal _ReportGameMessage_default_instance_;
constexpr ReportGameAckMessage::ReportGameAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reportedgameid_(0u)
  , reportgameresult_(0)
{}
struct ReportGameAckMessageDefaultTypeInternal {
  constexpr ReportGameAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReportGameAckMessageDefaultTypeInternal() {}
  union {
    ReportGameAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReportGameAckMessageDefaultTypeInternal _ReportGameAckMessage_default_instance_;
constexpr ErrorMessage::ErrorMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : errorreason_(0)
{}
struct ErrorMessageDefaultTypeInternal {
  constexpr ErrorMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ErrorMessageDefaultTypeInternal() {}
  union {
    ErrorMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
constexpr AdminRemoveGameMessage::AdminRemoveGameMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : removegameid_(0u){}
struct AdminRemoveGameMessageDefaultTypeInternal {
  constexpr AdminRemoveGameMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdminRemoveGameMessageDefaultTypeInternal() {}
  union {
    AdminRemoveGameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdminRemoveGameMessageDefaultTypeInternal _AdminRemoveGameMessage_default_instance_;
constexpr AdminRemoveGameAckMessage::AdminRemoveGameAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : removegameid_(0u)
  , removegameresult_(0)
{}
struct AdminRemoveGameAckMessageDefaultTypeInternal {
  constexpr AdminRemoveGameAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdminRemoveGameAckMessageDefaultTypeInternal() {}
  union {
    AdminRemoveGameAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdminRemoveGameAckMessageDefaultTypeInternal _AdminRemoveGameAckMessage_default_instance_;
constexpr AdminBanPlayerMessage::AdminBanPlayerMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : banplayerid_(0u){}
struct AdminBanPlayerMessageDefaultTypeInternal {
  constexpr AdminBanPlayerMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdminBanPlayerMessageDefaultTypeInternal() {}
  union {
    AdminBanPlayerMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdminBanPlayerMessageDefaultTypeInternal _AdminBanPlayerMessage_default_instance_;
constexpr AdminBanPlayerAckMessage::AdminBanPlayerAckMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : banplayerid_(0u)
  , banplayerresult_(0)
{}
struct AdminBanPlayerAckMessageDefaultTypeInternal {
  constexpr AdminBanPlayerAckMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdminBanPlayerAckMessageDefaultTypeInternal() {}
  union {
    AdminBanPlayerAckMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdminBanPlayerAckMessageDefaultTypeInternal _AdminBanPlayerAckMessage_default_instance_;
constexpr PokerTHMessage::PokerTHMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : announcemessage_(nullptr)
  , initmessage_(nullptr)
  , authserverchallengemessage_(nullptr)
  , authclientresponsemessage_(nullptr)
  , authserververificationmessage_(nullptr)
  , initackmessage_(nullptr)
  , avatarrequestmessage_(nullptr)
  , avatarheadermessage_(nullptr)
  , avatardatamessage_(nullptr)
  , avatarendmessage_(nullptr)
  , unknownavatarmessage_(nullptr)
  , playerlistmessage_(nullptr)
  , gamelistnewmessage_(nullptr)
  , gamelistupdatemessage_(nullptr)
  , gamelistplayerjoinedmessage_(nullptr)
  , gamelistplayerleftmessage_(nullptr)
  , gamelistadminchangedmessage_(nullptr)
  , playerinforequestmessage_(nullptr)
  , playerinforeplymessage_(nullptr)
  , subscriptionrequestmessage_(nullptr)
  , joinexistinggamemessage_(nullptr)
  , joinnewgamemessage_(nullptr)
  , rejoinexistinggamemessage_(nullptr)
  , joingameackmessage_(nullptr)
  , joingamefailedmessage_(nullptr)
  , gameplayerjoinedmessage_(nullptr)
  , gameplayerleftmessage_(nullptr)
  , gameadminchangedmessage_(nullptr)
  , removedfromgamemessage_(nullptr)
  , kickplayerrequestmessage_(nullptr)
  , leavegamerequestmessage_(nullptr)
  , inviteplayertogamemessage_(nullptr)
  , invitenotifymessage_(nullptr)
  , rejectgameinvitationmessage_(nullptr)
  , rejectinvnotifymessage_(nullptr)
  , starteventmessage_(nullptr)
  , starteventackmessage_(nullptr)
  , gamestartinitialmessage_(nullptr)
  , gamestartrejoinmessage_(nullptr)
  , handstartmessage_(nullptr)
  , playersturnmessage_(nullptr)
  , myactionrequestmessage_(nullptr)
  , youractionrejectedmessage_(nullptr)
  , playersactiondonemessage_(nullptr)
  , dealflopcardsmessage_(nullptr)
  , dealturncardmessage_(nullptr)
  , dealrivercardmessage_(nullptr)
  , allinshowcardsmessage_(nullptr)
  , endofhandshowcardsmessage_(nullptr)
  , endofhandhidecardsmessage_(nullptr)
  , showmycardsrequestmessage_(nullptr)
  , afterhandshowcardsmessage_(nullptr)
  , endofgamemessage_(nullptr)
  , playeridchangedmessage_(nullptr)
  , askkickplayermessage_(nullptr)
  , askkickdeniedmessage_(nullptr)
  , startkickpetitionmessage_(nullptr)
  , votekickrequestmessage_(nullptr)
  , votekickreplymessage_(nullptr)
  , kickpetitionupdatemessage_(nullptr)
  , endkickpetitionmessage_(nullptr)
  , statisticsmessage_(nullptr)
  , chatrequestmessage_(nullptr)
  , chatmessage_(nullptr)
  , chatrejectmessage_(nullptr)
  , dialogmessage_(nullptr)
  , timeoutwarningmessage_(nullptr)
  , resettimeoutmessage_(nullptr)
  , reportavatarmessage_(nullptr)
  , reportavatarackmessage_(nullptr)
  , reportgamemessage_(nullptr)
  , reportgameackmessage_(nullptr)
  , errormessage_(nullptr)
  , adminremovegamemessage_(nullptr)
  , adminremovegameackmessage_(nullptr)
  , adminbanplayermessage_(nullptr)
  , adminbanplayerackmessage_(nullptr)
  , gamelistspectatorjoinedmessage_(nullptr)
  , gamelistspectatorleftmessage_(nullptr)
  , gamespectatorjoinedmessage_(nullptr)
  , gamespectatorleftmessage_(nullptr)
  , messagetype_(1)
{}
struct PokerTHMessageDefaultTypeInternal {
  constexpr PokerTHMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PokerTHMessageDefaultTypeInternal() {}
  union {
    PokerTHMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PokerTHMessageDefaultTypeInternal _PokerTHMessage_default_instance_;
bool NetGameInfo_NetGameType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetGameInfo_NetGameType_strings[4] = {};

static const char NetGameInfo_NetGameType_names[] =
  "inviteOnlyGame"
  "normalGame"
  "rankingGame"
  "registeredOnlyGame";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetGameInfo_NetGameType_entries[] = {
  { {NetGameInfo_NetGameType_names + 0, 14}, 3 },
  { {NetGameInfo_NetGameType_names + 14, 10}, 1 },
  { {NetGameInfo_NetGameType_names + 24, 11}, 4 },
  { {NetGameInfo_NetGameType_names + 35, 18}, 2 },
};

static const int NetGameInfo_NetGameType_entries_by_number[] = {
  1, // 1 -> normalGame
  3, // 2 -> registeredOnlyGame
  0, // 3 -> inviteOnlyGame
  2, // 4 -> rankingGame
};

const std::string& NetGameInfo_NetGameType_Name(
    NetGameInfo_NetGameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetGameInfo_NetGameType_entries,
          NetGameInfo_NetGameType_entries_by_number,
          4, NetGameInfo_NetGameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetGameInfo_NetGameType_entries,
      NetGameInfo_NetGameType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetGameInfo_NetGameType_strings[idx].get();
}
bool NetGameInfo_NetGameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameInfo_NetGameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetGameInfo_NetGameType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<NetGameInfo_NetGameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NetGameInfo_NetGameType NetGameInfo::normalGame;
constexpr NetGameInfo_NetGameType NetGameInfo::registeredOnlyGame;
constexpr NetGameInfo_NetGameType NetGameInfo::inviteOnlyGame;
constexpr NetGameInfo_NetGameType NetGameInfo::rankingGame;
constexpr NetGameInfo_NetGameType NetGameInfo::NetGameType_MIN;
constexpr NetGameInfo_NetGameType NetGameInfo::NetGameType_MAX;
constexpr int NetGameInfo::NetGameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NetGameInfo_RaiseIntervalMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetGameInfo_RaiseIntervalMode_strings[2] = {};

static const char NetGameInfo_RaiseIntervalMode_names[] =
  "raiseOnHandNum"
  "raiseOnMinutes";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetGameInfo_RaiseIntervalMode_entries[] = {
  { {NetGameInfo_RaiseIntervalMode_names + 0, 14}, 1 },
  { {NetGameInfo_RaiseIntervalMode_names + 14, 14}, 2 },
};

static const int NetGameInfo_RaiseIntervalMode_entries_by_number[] = {
  0, // 1 -> raiseOnHandNum
  1, // 2 -> raiseOnMinutes
};

const std::string& NetGameInfo_RaiseIntervalMode_Name(
    NetGameInfo_RaiseIntervalMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetGameInfo_RaiseIntervalMode_entries,
          NetGameInfo_RaiseIntervalMode_entries_by_number,
          2, NetGameInfo_RaiseIntervalMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetGameInfo_RaiseIntervalMode_entries,
      NetGameInfo_RaiseIntervalMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetGameInfo_RaiseIntervalMode_strings[idx].get();
}
bool NetGameInfo_RaiseIntervalMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameInfo_RaiseIntervalMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetGameInfo_RaiseIntervalMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<NetGameInfo_RaiseIntervalMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NetGameInfo_RaiseIntervalMode NetGameInfo::raiseOnHandNum;
constexpr NetGameInfo_RaiseIntervalMode NetGameInfo::raiseOnMinutes;
constexpr NetGameInfo_RaiseIntervalMode NetGameInfo::RaiseIntervalMode_MIN;
constexpr NetGameInfo_RaiseIntervalMode NetGameInfo::RaiseIntervalMode_MAX;
constexpr int NetGameInfo::RaiseIntervalMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NetGameInfo_EndRaiseMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetGameInfo_EndRaiseMode_strings[3] = {};

static const char NetGameInfo_EndRaiseMode_names[] =
  "doubleBlinds"
  "keepLastBlind"
  "raiseByEndValue";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetGameInfo_EndRaiseMode_entries[] = {
  { {NetGameInfo_EndRaiseMode_names + 0, 12}, 1 },
  { {NetGameInfo_EndRaiseMode_names + 12, 13}, 3 },
  { {NetGameInfo_EndRaiseMode_names + 25, 15}, 2 },
};

static const int NetGameInfo_EndRaiseMode_entries_by_number[] = {
  0, // 1 -> doubleBlinds
  2, // 2 -> raiseByEndValue
  1, // 3 -> keepLastBlind
};

const std::string& NetGameInfo_EndRaiseMode_Name(
    NetGameInfo_EndRaiseMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetGameInfo_EndRaiseMode_entries,
          NetGameInfo_EndRaiseMode_entries_by_number,
          3, NetGameInfo_EndRaiseMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetGameInfo_EndRaiseMode_entries,
      NetGameInfo_EndRaiseMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetGameInfo_EndRaiseMode_strings[idx].get();
}
bool NetGameInfo_EndRaiseMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameInfo_EndRaiseMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetGameInfo_EndRaiseMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NetGameInfo_EndRaiseMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NetGameInfo_EndRaiseMode NetGameInfo::doubleBlinds;
constexpr NetGameInfo_EndRaiseMode NetGameInfo::raiseByEndValue;
constexpr NetGameInfo_EndRaiseMode NetGameInfo::keepLastBlind;
constexpr NetGameInfo_EndRaiseMode NetGameInfo::EndRaiseMode_MIN;
constexpr NetGameInfo_EndRaiseMode NetGameInfo::EndRaiseMode_MAX;
constexpr int NetGameInfo::EndRaiseMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AnnounceMessage_ServerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AnnounceMessage_ServerType_strings[3] = {};

static const char AnnounceMessage_ServerType_names[] =
  "serverTypeInternetAuth"
  "serverTypeInternetNoAuth"
  "serverTypeLAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AnnounceMessage_ServerType_entries[] = {
  { {AnnounceMessage_ServerType_names + 0, 22}, 2 },
  { {AnnounceMessage_ServerType_names + 22, 24}, 1 },
  { {AnnounceMessage_ServerType_names + 46, 13}, 0 },
};

static const int AnnounceMessage_ServerType_entries_by_number[] = {
  2, // 0 -> serverTypeLAN
  1, // 1 -> serverTypeInternetNoAuth
  0, // 2 -> serverTypeInternetAuth
};

const std::string& AnnounceMessage_ServerType_Name(
    AnnounceMessage_ServerType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AnnounceMessage_ServerType_entries,
          AnnounceMessage_ServerType_entries_by_number,
          3, AnnounceMessage_ServerType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AnnounceMessage_ServerType_entries,
      AnnounceMessage_ServerType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AnnounceMessage_ServerType_strings[idx].get();
}
bool AnnounceMessage_ServerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnnounceMessage_ServerType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AnnounceMessage_ServerType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AnnounceMessage_ServerType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AnnounceMessage_ServerType AnnounceMessage::serverTypeLAN;
constexpr AnnounceMessage_ServerType AnnounceMessage::serverTypeInternetNoAuth;
constexpr AnnounceMessage_ServerType AnnounceMessage::serverTypeInternetAuth;
constexpr AnnounceMessage_ServerType AnnounceMessage::ServerType_MIN;
constexpr AnnounceMessage_ServerType AnnounceMessage::ServerType_MAX;
constexpr int AnnounceMessage::ServerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool InitMessage_LoginType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InitMessage_LoginType_strings[3] = {};

static const char InitMessage_LoginType_names[] =
  "authenticatedLogin"
  "guestLogin"
  "unauthenticatedLogin";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InitMessage_LoginType_entries[] = {
  { {InitMessage_LoginType_names + 0, 18}, 1 },
  { {InitMessage_LoginType_names + 18, 10}, 0 },
  { {InitMessage_LoginType_names + 28, 20}, 2 },
};

static const int InitMessage_LoginType_entries_by_number[] = {
  1, // 0 -> guestLogin
  0, // 1 -> authenticatedLogin
  2, // 2 -> unauthenticatedLogin
};

const std::string& InitMessage_LoginType_Name(
    InitMessage_LoginType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InitMessage_LoginType_entries,
          InitMessage_LoginType_entries_by_number,
          3, InitMessage_LoginType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InitMessage_LoginType_entries,
      InitMessage_LoginType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InitMessage_LoginType_strings[idx].get();
}
bool InitMessage_LoginType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InitMessage_LoginType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InitMessage_LoginType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<InitMessage_LoginType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr InitMessage_LoginType InitMessage::guestLogin;
constexpr InitMessage_LoginType InitMessage::authenticatedLogin;
constexpr InitMessage_LoginType InitMessage::unauthenticatedLogin;
constexpr InitMessage_LoginType InitMessage::LoginType_MIN;
constexpr InitMessage_LoginType InitMessage::LoginType_MAX;
constexpr int InitMessage::LoginType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PlayerListMessage_PlayerListNotification_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlayerListMessage_PlayerListNotification_strings[2] = {};

static const char PlayerListMessage_PlayerListNotification_names[] =
  "playerListLeft"
  "playerListNew";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlayerListMessage_PlayerListNotification_entries[] = {
  { {PlayerListMessage_PlayerListNotification_names + 0, 14}, 1 },
  { {PlayerListMessage_PlayerListNotification_names + 14, 13}, 0 },
};

static const int PlayerListMessage_PlayerListNotification_entries_by_number[] = {
  1, // 0 -> playerListNew
  0, // 1 -> playerListLeft
};

const std::string& PlayerListMessage_PlayerListNotification_Name(
    PlayerListMessage_PlayerListNotification value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlayerListMessage_PlayerListNotification_entries,
          PlayerListMessage_PlayerListNotification_entries_by_number,
          2, PlayerListMessage_PlayerListNotification_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlayerListMessage_PlayerListNotification_entries,
      PlayerListMessage_PlayerListNotification_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlayerListMessage_PlayerListNotification_strings[idx].get();
}
bool PlayerListMessage_PlayerListNotification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerListMessage_PlayerListNotification* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlayerListMessage_PlayerListNotification_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PlayerListMessage_PlayerListNotification>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PlayerListMessage_PlayerListNotification PlayerListMessage::playerListNew;
constexpr PlayerListMessage_PlayerListNotification PlayerListMessage::playerListLeft;
constexpr PlayerListMessage_PlayerListNotification PlayerListMessage::PlayerListNotification_MIN;
constexpr PlayerListMessage_PlayerListNotification PlayerListMessage::PlayerListNotification_MAX;
constexpr int PlayerListMessage::PlayerListNotification_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SubscriptionRequestMessage_SubscriptionAction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SubscriptionRequestMessage_SubscriptionAction_strings[2] = {};

static const char SubscriptionRequestMessage_SubscriptionAction_names[] =
  "resubscribeGameList"
  "unsubscribeGameList";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SubscriptionRequestMessage_SubscriptionAction_entries[] = {
  { {SubscriptionRequestMessage_SubscriptionAction_names + 0, 19}, 2 },
  { {SubscriptionRequestMessage_SubscriptionAction_names + 19, 19}, 1 },
};

static const int SubscriptionRequestMessage_SubscriptionAction_entries_by_number[] = {
  1, // 1 -> unsubscribeGameList
  0, // 2 -> resubscribeGameList
};

const std::string& SubscriptionRequestMessage_SubscriptionAction_Name(
    SubscriptionRequestMessage_SubscriptionAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SubscriptionRequestMessage_SubscriptionAction_entries,
          SubscriptionRequestMessage_SubscriptionAction_entries_by_number,
          2, SubscriptionRequestMessage_SubscriptionAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SubscriptionRequestMessage_SubscriptionAction_entries,
      SubscriptionRequestMessage_SubscriptionAction_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SubscriptionRequestMessage_SubscriptionAction_strings[idx].get();
}
bool SubscriptionRequestMessage_SubscriptionAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionRequestMessage_SubscriptionAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SubscriptionRequestMessage_SubscriptionAction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SubscriptionRequestMessage_SubscriptionAction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::unsubscribeGameList;
constexpr SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::resubscribeGameList;
constexpr SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::SubscriptionAction_MIN;
constexpr SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::SubscriptionAction_MAX;
constexpr int SubscriptionRequestMessage::SubscriptionAction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool JoinGameFailedMessage_JoinGameFailureReason_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> JoinGameFailedMessage_JoinGameFailureReason_strings[12] = {};

static const char JoinGameFailedMessage_JoinGameFailureReason_names[] =
  "badGameName"
  "gameIsFull"
  "gameIsRunning"
  "gameNameInUse"
  "invalidGame"
  "invalidPassword"
  "invalidSettings"
  "ipAddressBlocked"
  "noSpectatorsAllowed"
  "notAllowedAsGuest"
  "notInvited"
  "rejoinFailed";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry JoinGameFailedMessage_JoinGameFailureReason_entries[] = {
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 0, 11}, 8 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 11, 10}, 2 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 21, 13}, 3 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 34, 13}, 7 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 47, 11}, 1 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 58, 15}, 4 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 73, 15}, 9 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 88, 16}, 10 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 104, 19}, 12 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 123, 17}, 5 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 140, 10}, 6 },
  { {JoinGameFailedMessage_JoinGameFailureReason_names + 150, 12}, 11 },
};

static const int JoinGameFailedMessage_JoinGameFailureReason_entries_by_number[] = {
  4, // 1 -> invalidGame
  1, // 2 -> gameIsFull
  2, // 3 -> gameIsRunning
  5, // 4 -> invalidPassword
  9, // 5 -> notAllowedAsGuest
  10, // 6 -> notInvited
  3, // 7 -> gameNameInUse
  0, // 8 -> badGameName
  6, // 9 -> invalidSettings
  7, // 10 -> ipAddressBlocked
  11, // 11 -> rejoinFailed
  8, // 12 -> noSpectatorsAllowed
};

const std::string& JoinGameFailedMessage_JoinGameFailureReason_Name(
    JoinGameFailedMessage_JoinGameFailureReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          JoinGameFailedMessage_JoinGameFailureReason_entries,
          JoinGameFailedMessage_JoinGameFailureReason_entries_by_number,
          12, JoinGameFailedMessage_JoinGameFailureReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      JoinGameFailedMessage_JoinGameFailureReason_entries,
      JoinGameFailedMessage_JoinGameFailureReason_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     JoinGameFailedMessage_JoinGameFailureReason_strings[idx].get();
}
bool JoinGameFailedMessage_JoinGameFailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JoinGameFailedMessage_JoinGameFailureReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      JoinGameFailedMessage_JoinGameFailureReason_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<JoinGameFailedMessage_JoinGameFailureReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::invalidGame;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::gameIsFull;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::gameIsRunning;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::invalidPassword;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::notAllowedAsGuest;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::notInvited;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::gameNameInUse;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::badGameName;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::invalidSettings;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::ipAddressBlocked;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::rejoinFailed;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::noSpectatorsAllowed;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::JoinGameFailureReason_MIN;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::JoinGameFailureReason_MAX;
constexpr int JoinGameFailedMessage::JoinGameFailureReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GamePlayerLeftMessage_GamePlayerLeftReason_strings[3] = {};

static const char GamePlayerLeftMessage_GamePlayerLeftReason_names[] =
  "leftError"
  "leftKicked"
  "leftOnRequest";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GamePlayerLeftMessage_GamePlayerLeftReason_entries[] = {
  { {GamePlayerLeftMessage_GamePlayerLeftReason_names + 0, 9}, 2 },
  { {GamePlayerLeftMessage_GamePlayerLeftReason_names + 9, 10}, 1 },
  { {GamePlayerLeftMessage_GamePlayerLeftReason_names + 19, 13}, 0 },
};

static const int GamePlayerLeftMessage_GamePlayerLeftReason_entries_by_number[] = {
  2, // 0 -> leftOnRequest
  1, // 1 -> leftKicked
  0, // 2 -> leftError
};

const std::string& GamePlayerLeftMessage_GamePlayerLeftReason_Name(
    GamePlayerLeftMessage_GamePlayerLeftReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GamePlayerLeftMessage_GamePlayerLeftReason_entries,
          GamePlayerLeftMessage_GamePlayerLeftReason_entries_by_number,
          3, GamePlayerLeftMessage_GamePlayerLeftReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GamePlayerLeftMessage_GamePlayerLeftReason_entries,
      GamePlayerLeftMessage_GamePlayerLeftReason_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GamePlayerLeftMessage_GamePlayerLeftReason_strings[idx].get();
}
bool GamePlayerLeftMessage_GamePlayerLeftReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GamePlayerLeftMessage_GamePlayerLeftReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GamePlayerLeftMessage_GamePlayerLeftReason_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GamePlayerLeftMessage_GamePlayerLeftReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::leftOnRequest;
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::leftKicked;
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::leftError;
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::GamePlayerLeftReason_MIN;
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::GamePlayerLeftReason_MAX;
constexpr int GamePlayerLeftMessage::GamePlayerLeftReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RemovedFromGameMessage_RemovedFromGameReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RemovedFromGameMessage_RemovedFromGameReason_strings[7] = {};

static const char RemovedFromGameMessage_RemovedFromGameReason_names[] =
  "gameClosed"
  "gameIsFull"
  "gameIsRunning"
  "gameTimeout"
  "kickedFromGame"
  "removedOnRequest"
  "removedStartFailed";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RemovedFromGameMessage_RemovedFromGameReason_entries[] = {
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 0, 10}, 6 },
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 10, 10}, 2 },
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 20, 13}, 3 },
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 33, 11}, 4 },
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 44, 14}, 1 },
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 58, 16}, 0 },
  { {RemovedFromGameMessage_RemovedFromGameReason_names + 74, 18}, 5 },
};

static const int RemovedFromGameMessage_RemovedFromGameReason_entries_by_number[] = {
  5, // 0 -> removedOnRequest
  4, // 1 -> kickedFromGame
  1, // 2 -> gameIsFull
  2, // 3 -> gameIsRunning
  3, // 4 -> gameTimeout
  6, // 5 -> removedStartFailed
  0, // 6 -> gameClosed
};

const std::string& RemovedFromGameMessage_RemovedFromGameReason_Name(
    RemovedFromGameMessage_RemovedFromGameReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RemovedFromGameMessage_RemovedFromGameReason_entries,
          RemovedFromGameMessage_RemovedFromGameReason_entries_by_number,
          7, RemovedFromGameMessage_RemovedFromGameReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RemovedFromGameMessage_RemovedFromGameReason_entries,
      RemovedFromGameMessage_RemovedFromGameReason_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RemovedFromGameMessage_RemovedFromGameReason_strings[idx].get();
}
bool RemovedFromGameMessage_RemovedFromGameReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemovedFromGameMessage_RemovedFromGameReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RemovedFromGameMessage_RemovedFromGameReason_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<RemovedFromGameMessage_RemovedFromGameReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::removedOnRequest;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::kickedFromGame;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::gameIsFull;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::gameIsRunning;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::gameTimeout;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::removedStartFailed;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::gameClosed;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::RemovedFromGameReason_MIN;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::RemovedFromGameReason_MAX;
constexpr int RemovedFromGameMessage::RemovedFromGameReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RejectGameInvitationMessage_RejectGameInvReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RejectGameInvitationMessage_RejectGameInvReason_strings[2] = {};

static const char RejectGameInvitationMessage_RejectGameInvReason_names[] =
  "rejectReasonBusy"
  "rejectReasonNo";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RejectGameInvitationMessage_RejectGameInvReason_entries[] = {
  { {RejectGameInvitationMessage_RejectGameInvReason_names + 0, 16}, 1 },
  { {RejectGameInvitationMessage_RejectGameInvReason_names + 16, 14}, 0 },
};

static const int RejectGameInvitationMessage_RejectGameInvReason_entries_by_number[] = {
  1, // 0 -> rejectReasonNo
  0, // 1 -> rejectReasonBusy
};

const std::string& RejectGameInvitationMessage_RejectGameInvReason_Name(
    RejectGameInvitationMessage_RejectGameInvReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RejectGameInvitationMessage_RejectGameInvReason_entries,
          RejectGameInvitationMessage_RejectGameInvReason_entries_by_number,
          2, RejectGameInvitationMessage_RejectGameInvReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RejectGameInvitationMessage_RejectGameInvReason_entries,
      RejectGameInvitationMessage_RejectGameInvReason_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RejectGameInvitationMessage_RejectGameInvReason_strings[idx].get();
}
bool RejectGameInvitationMessage_RejectGameInvReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RejectGameInvitationMessage_RejectGameInvReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RejectGameInvitationMessage_RejectGameInvReason_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<RejectGameInvitationMessage_RejectGameInvReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::rejectReasonNo;
constexpr RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::rejectReasonBusy;
constexpr RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::RejectGameInvReason_MIN;
constexpr RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::RejectGameInvReason_MAX;
constexpr int RejectGameInvitationMessage::RejectGameInvReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool StartEventMessage_StartEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StartEventMessage_StartEventType_strings[2] = {};

static const char StartEventMessage_StartEventType_names[] =
  "rejoinEvent"
  "startEvent";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StartEventMessage_StartEventType_entries[] = {
  { {StartEventMessage_StartEventType_names + 0, 11}, 1 },
  { {StartEventMessage_StartEventType_names + 11, 10}, 0 },
};

static const int StartEventMessage_StartEventType_entries_by_number[] = {
  1, // 0 -> startEvent
  0, // 1 -> rejoinEvent
};

const std::string& StartEventMessage_StartEventType_Name(
    StartEventMessage_StartEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StartEventMessage_StartEventType_entries,
          StartEventMessage_StartEventType_entries_by_number,
          2, StartEventMessage_StartEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StartEventMessage_StartEventType_entries,
      StartEventMessage_StartEventType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StartEventMessage_StartEventType_strings[idx].get();
}
bool StartEventMessage_StartEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StartEventMessage_StartEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StartEventMessage_StartEventType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<StartEventMessage_StartEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StartEventMessage_StartEventType StartEventMessage::startEvent;
constexpr StartEventMessage_StartEventType StartEventMessage::rejoinEvent;
constexpr StartEventMessage_StartEventType StartEventMessage::StartEventType_MIN;
constexpr StartEventMessage_StartEventType StartEventMessage::StartEventType_MAX;
constexpr int StartEventMessage::StartEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool YourActionRejectedMessage_RejectionReason_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> YourActionRejectedMessage_RejectionReason_strings[3] = {};

static const char YourActionRejectedMessage_RejectionReason_names[] =
  "rejectedActionNotAllowed"
  "rejectedInvalidGameState"
  "rejectedNotYourTurn";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry YourActionRejectedMessage_RejectionReason_entries[] = {
  { {YourActionRejectedMessage_RejectionReason_names + 0, 24}, 3 },
  { {YourActionRejectedMessage_RejectionReason_names + 24, 24}, 1 },
  { {YourActionRejectedMessage_RejectionReason_names + 48, 19}, 2 },
};

static const int YourActionRejectedMessage_RejectionReason_entries_by_number[] = {
  1, // 1 -> rejectedInvalidGameState
  2, // 2 -> rejectedNotYourTurn
  0, // 3 -> rejectedActionNotAllowed
};

const std::string& YourActionRejectedMessage_RejectionReason_Name(
    YourActionRejectedMessage_RejectionReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          YourActionRejectedMessage_RejectionReason_entries,
          YourActionRejectedMessage_RejectionReason_entries_by_number,
          3, YourActionRejectedMessage_RejectionReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      YourActionRejectedMessage_RejectionReason_entries,
      YourActionRejectedMessage_RejectionReason_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     YourActionRejectedMessage_RejectionReason_strings[idx].get();
}
bool YourActionRejectedMessage_RejectionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, YourActionRejectedMessage_RejectionReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      YourActionRejectedMessage_RejectionReason_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<YourActionRejectedMessage_RejectionReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectedInvalidGameState;
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectedNotYourTurn;
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectedActionNotAllowed;
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::RejectionReason_MIN;
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::RejectionReason_MAX;
constexpr int YourActionRejectedMessage::RejectionReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AskKickDeniedMessage_KickDeniedReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AskKickDeniedMessage_KickDeniedReason_strings[5] = {};

static const char AskKickDeniedMessage_KickDeniedReason_names[] =
  "kickDeniedAlreadyInProgress"
  "kickDeniedInvalidGameState"
  "kickDeniedInvalidPlayerId"
  "kickDeniedNotPossible"
  "kickDeniedTryAgainLater";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AskKickDeniedMessage_KickDeniedReason_entries[] = {
  { {AskKickDeniedMessage_KickDeniedReason_names + 0, 27}, 3 },
  { {AskKickDeniedMessage_KickDeniedReason_names + 27, 26}, 0 },
  { {AskKickDeniedMessage_KickDeniedReason_names + 53, 25}, 4 },
  { {AskKickDeniedMessage_KickDeniedReason_names + 78, 21}, 1 },
  { {AskKickDeniedMessage_KickDeniedReason_names + 99, 23}, 2 },
};

static const int AskKickDeniedMessage_KickDeniedReason_entries_by_number[] = {
  1, // 0 -> kickDeniedInvalidGameState
  3, // 1 -> kickDeniedNotPossible
  4, // 2 -> kickDeniedTryAgainLater
  0, // 3 -> kickDeniedAlreadyInProgress
  2, // 4 -> kickDeniedInvalidPlayerId
};

const std::string& AskKickDeniedMessage_KickDeniedReason_Name(
    AskKickDeniedMessage_KickDeniedReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AskKickDeniedMessage_KickDeniedReason_entries,
          AskKickDeniedMessage_KickDeniedReason_entries_by_number,
          5, AskKickDeniedMessage_KickDeniedReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AskKickDeniedMessage_KickDeniedReason_entries,
      AskKickDeniedMessage_KickDeniedReason_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AskKickDeniedMessage_KickDeniedReason_strings[idx].get();
}
bool AskKickDeniedMessage_KickDeniedReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AskKickDeniedMessage_KickDeniedReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AskKickDeniedMessage_KickDeniedReason_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AskKickDeniedMessage_KickDeniedReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickDeniedInvalidGameState;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickDeniedNotPossible;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickDeniedTryAgainLater;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickDeniedAlreadyInProgress;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickDeniedInvalidPlayerId;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::KickDeniedReason_MIN;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::KickDeniedReason_MAX;
constexpr int AskKickDeniedMessage::KickDeniedReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VoteKickReplyMessage_VoteKickReplyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VoteKickReplyMessage_VoteKickReplyType_strings[3] = {};

static const char VoteKickReplyMessage_VoteKickReplyType_names[] =
  "voteKickAck"
  "voteKickDeniedAlreadyVoted"
  "voteKickDeniedInvalid";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VoteKickReplyMessage_VoteKickReplyType_entries[] = {
  { {VoteKickReplyMessage_VoteKickReplyType_names + 0, 11}, 0 },
  { {VoteKickReplyMessage_VoteKickReplyType_names + 11, 26}, 2 },
  { {VoteKickReplyMessage_VoteKickReplyType_names + 37, 21}, 1 },
};

static const int VoteKickReplyMessage_VoteKickReplyType_entries_by_number[] = {
  0, // 0 -> voteKickAck
  2, // 1 -> voteKickDeniedInvalid
  1, // 2 -> voteKickDeniedAlreadyVoted
};

const std::string& VoteKickReplyMessage_VoteKickReplyType_Name(
    VoteKickReplyMessage_VoteKickReplyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VoteKickReplyMessage_VoteKickReplyType_entries,
          VoteKickReplyMessage_VoteKickReplyType_entries_by_number,
          3, VoteKickReplyMessage_VoteKickReplyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VoteKickReplyMessage_VoteKickReplyType_entries,
      VoteKickReplyMessage_VoteKickReplyType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VoteKickReplyMessage_VoteKickReplyType_strings[idx].get();
}
bool VoteKickReplyMessage_VoteKickReplyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VoteKickReplyMessage_VoteKickReplyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VoteKickReplyMessage_VoteKickReplyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<VoteKickReplyMessage_VoteKickReplyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::voteKickAck;
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::voteKickDeniedInvalid;
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::voteKickDeniedAlreadyVoted;
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::VoteKickReplyType_MIN;
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::VoteKickReplyType_MAX;
constexpr int VoteKickReplyMessage::VoteKickReplyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EndKickPetitionMessage_PetitionEndReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EndKickPetitionMessage_PetitionEndReason_strings[4] = {};

static const char EndKickPetitionMessage_PetitionEndReason_names[] =
  "petitionEndEnoughVotes"
  "petitionEndPlayerLeft"
  "petitionEndTimeout"
  "petitionEndTooFewPlayers";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EndKickPetitionMessage_PetitionEndReason_entries[] = {
  { {EndKickPetitionMessage_PetitionEndReason_names + 0, 22}, 0 },
  { {EndKickPetitionMessage_PetitionEndReason_names + 22, 21}, 2 },
  { {EndKickPetitionMessage_PetitionEndReason_names + 43, 18}, 3 },
  { {EndKickPetitionMessage_PetitionEndReason_names + 61, 24}, 1 },
};

static const int EndKickPetitionMessage_PetitionEndReason_entries_by_number[] = {
  0, // 0 -> petitionEndEnoughVotes
  3, // 1 -> petitionEndTooFewPlayers
  1, // 2 -> petitionEndPlayerLeft
  2, // 3 -> petitionEndTimeout
};

const std::string& EndKickPetitionMessage_PetitionEndReason_Name(
    EndKickPetitionMessage_PetitionEndReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EndKickPetitionMessage_PetitionEndReason_entries,
          EndKickPetitionMessage_PetitionEndReason_entries_by_number,
          4, EndKickPetitionMessage_PetitionEndReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EndKickPetitionMessage_PetitionEndReason_entries,
      EndKickPetitionMessage_PetitionEndReason_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EndKickPetitionMessage_PetitionEndReason_strings[idx].get();
}
bool EndKickPetitionMessage_PetitionEndReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EndKickPetitionMessage_PetitionEndReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EndKickPetitionMessage_PetitionEndReason_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EndKickPetitionMessage_PetitionEndReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionEndEnoughVotes;
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionEndTooFewPlayers;
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionEndPlayerLeft;
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionEndTimeout;
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::PetitionEndReason_MIN;
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::PetitionEndReason_MAX;
constexpr int EndKickPetitionMessage::PetitionEndReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool StatisticsMessage_StatisticsData_StatisticsType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StatisticsMessage_StatisticsData_StatisticsType_strings[1] = {};

static const char StatisticsMessage_StatisticsData_StatisticsType_names[] =
  "statNumberOfPlayers";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StatisticsMessage_StatisticsData_StatisticsType_entries[] = {
  { {StatisticsMessage_StatisticsData_StatisticsType_names + 0, 19}, 1 },
};

static const int StatisticsMessage_StatisticsData_StatisticsType_entries_by_number[] = {
  0, // 1 -> statNumberOfPlayers
};

const std::string& StatisticsMessage_StatisticsData_StatisticsType_Name(
    StatisticsMessage_StatisticsData_StatisticsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StatisticsMessage_StatisticsData_StatisticsType_entries,
          StatisticsMessage_StatisticsData_StatisticsType_entries_by_number,
          1, StatisticsMessage_StatisticsData_StatisticsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StatisticsMessage_StatisticsData_StatisticsType_entries,
      StatisticsMessage_StatisticsData_StatisticsType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StatisticsMessage_StatisticsData_StatisticsType_strings[idx].get();
}
bool StatisticsMessage_StatisticsData_StatisticsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatisticsMessage_StatisticsData_StatisticsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StatisticsMessage_StatisticsData_StatisticsType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<StatisticsMessage_StatisticsData_StatisticsType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::statNumberOfPlayers;
constexpr StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::StatisticsType_MIN;
constexpr StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::StatisticsType_MAX;
constexpr int StatisticsMessage_StatisticsData::StatisticsType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ChatMessage_ChatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChatMessage_ChatType_strings[5] = {};

static const char ChatMessage_ChatType_names[] =
  "chatTypeBot"
  "chatTypeBroadcast"
  "chatTypeGame"
  "chatTypeLobby"
  "chatTypePrivate";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChatMessage_ChatType_entries[] = {
  { {ChatMessage_ChatType_names + 0, 11}, 2 },
  { {ChatMessage_ChatType_names + 11, 17}, 3 },
  { {ChatMessage_ChatType_names + 28, 12}, 1 },
  { {ChatMessage_ChatType_names + 40, 13}, 0 },
  { {ChatMessage_ChatType_names + 53, 15}, 4 },
};

static const int ChatMessage_ChatType_entries_by_number[] = {
  3, // 0 -> chatTypeLobby
  2, // 1 -> chatTypeGame
  0, // 2 -> chatTypeBot
  1, // 3 -> chatTypeBroadcast
  4, // 4 -> chatTypePrivate
};

const std::string& ChatMessage_ChatType_Name(
    ChatMessage_ChatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChatMessage_ChatType_entries,
          ChatMessage_ChatType_entries_by_number,
          5, ChatMessage_ChatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChatMessage_ChatType_entries,
      ChatMessage_ChatType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChatMessage_ChatType_strings[idx].get();
}
bool ChatMessage_ChatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessage_ChatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChatMessage_ChatType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ChatMessage_ChatType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChatMessage_ChatType ChatMessage::chatTypeLobby;
constexpr ChatMessage_ChatType ChatMessage::chatTypeGame;
constexpr ChatMessage_ChatType ChatMessage::chatTypeBot;
constexpr ChatMessage_ChatType ChatMessage::chatTypeBroadcast;
constexpr ChatMessage_ChatType ChatMessage::chatTypePrivate;
constexpr ChatMessage_ChatType ChatMessage::ChatType_MIN;
constexpr ChatMessage_ChatType ChatMessage::ChatType_MAX;
constexpr int ChatMessage::ChatType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TimeoutWarningMessage_TimeoutReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TimeoutWarningMessage_TimeoutReason_strings[3] = {};

static const char TimeoutWarningMessage_TimeoutReason_names[] =
  "timeoutInactiveGame"
  "timeoutKickAfterAutofold"
  "timeoutNoDataReceived";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TimeoutWarningMessage_TimeoutReason_entries[] = {
  { {TimeoutWarningMessage_TimeoutReason_names + 0, 19}, 1 },
  { {TimeoutWarningMessage_TimeoutReason_names + 19, 24}, 2 },
  { {TimeoutWarningMessage_TimeoutReason_names + 43, 21}, 0 },
};

static const int TimeoutWarningMessage_TimeoutReason_entries_by_number[] = {
  2, // 0 -> timeoutNoDataReceived
  0, // 1 -> timeoutInactiveGame
  1, // 2 -> timeoutKickAfterAutofold
};

const std::string& TimeoutWarningMessage_TimeoutReason_Name(
    TimeoutWarningMessage_TimeoutReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TimeoutWarningMessage_TimeoutReason_entries,
          TimeoutWarningMessage_TimeoutReason_entries_by_number,
          3, TimeoutWarningMessage_TimeoutReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TimeoutWarningMessage_TimeoutReason_entries,
      TimeoutWarningMessage_TimeoutReason_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TimeoutWarningMessage_TimeoutReason_strings[idx].get();
}
bool TimeoutWarningMessage_TimeoutReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeoutWarningMessage_TimeoutReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TimeoutWarningMessage_TimeoutReason_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TimeoutWarningMessage_TimeoutReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutNoDataReceived;
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutInactiveGame;
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutKickAfterAutofold;
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::TimeoutReason_MIN;
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::TimeoutReason_MAX;
constexpr int TimeoutWarningMessage::TimeoutReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReportAvatarAckMessage_ReportAvatarResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReportAvatarAckMessage_ReportAvatarResult_strings[3] = {};

static const char ReportAvatarAckMessage_ReportAvatarResult_names[] =
  "avatarReportAccepted"
  "avatarReportDuplicate"
  "avatarReportInvalid";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReportAvatarAckMessage_ReportAvatarResult_entries[] = {
  { {ReportAvatarAckMessage_ReportAvatarResult_names + 0, 20}, 0 },
  { {ReportAvatarAckMessage_ReportAvatarResult_names + 20, 21}, 1 },
  { {ReportAvatarAckMessage_ReportAvatarResult_names + 41, 19}, 2 },
};

static const int ReportAvatarAckMessage_ReportAvatarResult_entries_by_number[] = {
  0, // 0 -> avatarReportAccepted
  1, // 1 -> avatarReportDuplicate
  2, // 2 -> avatarReportInvalid
};

const std::string& ReportAvatarAckMessage_ReportAvatarResult_Name(
    ReportAvatarAckMessage_ReportAvatarResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReportAvatarAckMessage_ReportAvatarResult_entries,
          ReportAvatarAckMessage_ReportAvatarResult_entries_by_number,
          3, ReportAvatarAckMessage_ReportAvatarResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReportAvatarAckMessage_ReportAvatarResult_entries,
      ReportAvatarAckMessage_ReportAvatarResult_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReportAvatarAckMessage_ReportAvatarResult_strings[idx].get();
}
bool ReportAvatarAckMessage_ReportAvatarResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReportAvatarAckMessage_ReportAvatarResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReportAvatarAckMessage_ReportAvatarResult_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ReportAvatarAckMessage_ReportAvatarResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::avatarReportAccepted;
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::avatarReportDuplicate;
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::avatarReportInvalid;
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::ReportAvatarResult_MIN;
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::ReportAvatarResult_MAX;
constexpr int ReportAvatarAckMessage::ReportAvatarResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReportGameAckMessage_ReportGameResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReportGameAckMessage_ReportGameResult_strings[3] = {};

static const char ReportGameAckMessage_ReportGameResult_names[] =
  "gameReportAccepted"
  "gameReportDuplicate"
  "gameReportInvalid";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReportGameAckMessage_ReportGameResult_entries[] = {
  { {ReportGameAckMessage_ReportGameResult_names + 0, 18}, 0 },
  { {ReportGameAckMessage_ReportGameResult_names + 18, 19}, 1 },
  { {ReportGameAckMessage_ReportGameResult_names + 37, 17}, 2 },
};

static const int ReportGameAckMessage_ReportGameResult_entries_by_number[] = {
  0, // 0 -> gameReportAccepted
  1, // 1 -> gameReportDuplicate
  2, // 2 -> gameReportInvalid
};

const std::string& ReportGameAckMessage_ReportGameResult_Name(
    ReportGameAckMessage_ReportGameResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReportGameAckMessage_ReportGameResult_entries,
          ReportGameAckMessage_ReportGameResult_entries_by_number,
          3, ReportGameAckMessage_ReportGameResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReportGameAckMessage_ReportGameResult_entries,
      ReportGameAckMessage_ReportGameResult_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReportGameAckMessage_ReportGameResult_strings[idx].get();
}
bool ReportGameAckMessage_ReportGameResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReportGameAckMessage_ReportGameResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReportGameAckMessage_ReportGameResult_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ReportGameAckMessage_ReportGameResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage::gameReportAccepted;
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage::gameReportDuplicate;
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage::gameReportInvalid;
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage::ReportGameResult_MIN;
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage::ReportGameResult_MAX;
constexpr int ReportGameAckMessage::ReportGameResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ErrorMessage_ErrorReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ErrorMessage_ErrorReason_strings[15] = {};

static const char ErrorMessage_ErrorReason_names[] =
  "avatarTooLarge"
  "bannedFromServer"
  "blockedByServer"
  "custReserved"
  "initAuthFailure"
  "initBlocked"
  "initInvalidPlayerName"
  "initPlayerNameInUse"
  "initServerFull"
  "initServerMaintenance"
  "initVersionNotSupported"
  "invalidPacket"
  "invalidState"
  "kickedFromServer"
  "sessionTimeout";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ErrorMessage_ErrorReason_entries[] = {
  { {ErrorMessage_ErrorReason_names + 0, 14}, 8 },
  { {ErrorMessage_ErrorReason_names + 14, 16}, 12 },
  { {ErrorMessage_ErrorReason_names + 30, 15}, 13 },
  { {ErrorMessage_ErrorReason_names + 45, 12}, 0 },
  { {ErrorMessage_ErrorReason_names + 57, 15}, 3 },
  { {ErrorMessage_ErrorReason_names + 72, 11}, 7 },
  { {ErrorMessage_ErrorReason_names + 83, 21}, 5 },
  { {ErrorMessage_ErrorReason_names + 104, 19}, 4 },
  { {ErrorMessage_ErrorReason_names + 123, 14}, 2 },
  { {ErrorMessage_ErrorReason_names + 137, 21}, 6 },
  { {ErrorMessage_ErrorReason_names + 158, 23}, 1 },
  { {ErrorMessage_ErrorReason_names + 181, 13}, 9 },
  { {ErrorMessage_ErrorReason_names + 194, 12}, 10 },
  { {ErrorMessage_ErrorReason_names + 206, 16}, 11 },
  { {ErrorMessage_ErrorReason_names + 222, 14}, 14 },
};

static const int ErrorMessage_ErrorReason_entries_by_number[] = {
  3, // 0 -> custReserved
  10, // 1 -> initVersionNotSupported
  8, // 2 -> initServerFull
  4, // 3 -> initAuthFailure
  7, // 4 -> initPlayerNameInUse
  6, // 5 -> initInvalidPlayerName
  9, // 6 -> initServerMaintenance
  5, // 7 -> initBlocked
  0, // 8 -> avatarTooLarge
  11, // 9 -> invalidPacket
  12, // 10 -> invalidState
  13, // 11 -> kickedFromServer
  1, // 12 -> bannedFromServer
  2, // 13 -> blockedByServer
  14, // 14 -> sessionTimeout
};

const std::string& ErrorMessage_ErrorReason_Name(
    ErrorMessage_ErrorReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ErrorMessage_ErrorReason_entries,
          ErrorMessage_ErrorReason_entries_by_number,
          15, ErrorMessage_ErrorReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ErrorMessage_ErrorReason_entries,
      ErrorMessage_ErrorReason_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ErrorMessage_ErrorReason_strings[idx].get();
}
bool ErrorMessage_ErrorReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorMessage_ErrorReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ErrorMessage_ErrorReason_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<ErrorMessage_ErrorReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ErrorMessage_ErrorReason ErrorMessage::custReserved;
constexpr ErrorMessage_ErrorReason ErrorMessage::initVersionNotSupported;
constexpr ErrorMessage_ErrorReason ErrorMessage::initServerFull;
constexpr ErrorMessage_ErrorReason ErrorMessage::initAuthFailure;
constexpr ErrorMessage_ErrorReason ErrorMessage::initPlayerNameInUse;
constexpr ErrorMessage_ErrorReason ErrorMessage::initInvalidPlayerName;
constexpr ErrorMessage_ErrorReason ErrorMessage::initServerMaintenance;
constexpr ErrorMessage_ErrorReason ErrorMessage::initBlocked;
constexpr ErrorMessage_ErrorReason ErrorMessage::avatarTooLarge;
constexpr ErrorMessage_ErrorReason ErrorMessage::invalidPacket;
constexpr ErrorMessage_ErrorReason ErrorMessage::invalidState;
constexpr ErrorMessage_ErrorReason ErrorMessage::kickedFromServer;
constexpr ErrorMessage_ErrorReason ErrorMessage::bannedFromServer;
constexpr ErrorMessage_ErrorReason ErrorMessage::blockedByServer;
constexpr ErrorMessage_ErrorReason ErrorMessage::sessionTimeout;
constexpr ErrorMessage_ErrorReason ErrorMessage::ErrorReason_MIN;
constexpr ErrorMessage_ErrorReason ErrorMessage::ErrorReason_MAX;
constexpr int ErrorMessage::ErrorReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AdminRemoveGameAckMessage_AdminRemoveGameResult_strings[2] = {};

static const char AdminRemoveGameAckMessage_AdminRemoveGameResult_names[] =
  "gameRemoveAccepted"
  "gameRemoveInvalid";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AdminRemoveGameAckMessage_AdminRemoveGameResult_entries[] = {
  { {AdminRemoveGameAckMessage_AdminRemoveGameResult_names + 0, 18}, 0 },
  { {AdminRemoveGameAckMessage_AdminRemoveGameResult_names + 18, 17}, 1 },
};

static const int AdminRemoveGameAckMessage_AdminRemoveGameResult_entries_by_number[] = {
  0, // 0 -> gameRemoveAccepted
  1, // 1 -> gameRemoveInvalid
};

const std::string& AdminRemoveGameAckMessage_AdminRemoveGameResult_Name(
    AdminRemoveGameAckMessage_AdminRemoveGameResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AdminRemoveGameAckMessage_AdminRemoveGameResult_entries,
          AdminRemoveGameAckMessage_AdminRemoveGameResult_entries_by_number,
          2, AdminRemoveGameAckMessage_AdminRemoveGameResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AdminRemoveGameAckMessage_AdminRemoveGameResult_entries,
      AdminRemoveGameAckMessage_AdminRemoveGameResult_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AdminRemoveGameAckMessage_AdminRemoveGameResult_strings[idx].get();
}
bool AdminRemoveGameAckMessage_AdminRemoveGameResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminRemoveGameAckMessage_AdminRemoveGameResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AdminRemoveGameAckMessage_AdminRemoveGameResult_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<AdminRemoveGameAckMessage_AdminRemoveGameResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::gameRemoveAccepted;
constexpr AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::gameRemoveInvalid;
constexpr AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::AdminRemoveGameResult_MIN;
constexpr AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::AdminRemoveGameResult_MAX;
constexpr int AdminRemoveGameAckMessage::AdminRemoveGameResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AdminBanPlayerAckMessage_AdminBanPlayerResult_strings[5] = {};

static const char AdminBanPlayerAckMessage_AdminBanPlayerResult_names[] =
  "banPlayerAccepted"
  "banPlayerDBError"
  "banPlayerInvalid"
  "banPlayerNoDB"
  "banPlayerPending";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AdminBanPlayerAckMessage_AdminBanPlayerResult_entries[] = {
  { {AdminBanPlayerAckMessage_AdminBanPlayerResult_names + 0, 17}, 0 },
  { {AdminBanPlayerAckMessage_AdminBanPlayerResult_names + 17, 16}, 3 },
  { {AdminBanPlayerAckMessage_AdminBanPlayerResult_names + 33, 16}, 4 },
  { {AdminBanPlayerAckMessage_AdminBanPlayerResult_names + 49, 13}, 2 },
  { {AdminBanPlayerAckMessage_AdminBanPlayerResult_names + 62, 16}, 1 },
};

static const int AdminBanPlayerAckMessage_AdminBanPlayerResult_entries_by_number[] = {
  0, // 0 -> banPlayerAccepted
  4, // 1 -> banPlayerPending
  3, // 2 -> banPlayerNoDB
  1, // 3 -> banPlayerDBError
  2, // 4 -> banPlayerInvalid
};

const std::string& AdminBanPlayerAckMessage_AdminBanPlayerResult_Name(
    AdminBanPlayerAckMessage_AdminBanPlayerResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AdminBanPlayerAckMessage_AdminBanPlayerResult_entries,
          AdminBanPlayerAckMessage_AdminBanPlayerResult_entries_by_number,
          5, AdminBanPlayerAckMessage_AdminBanPlayerResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AdminBanPlayerAckMessage_AdminBanPlayerResult_entries,
      AdminBanPlayerAckMessage_AdminBanPlayerResult_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AdminBanPlayerAckMessage_AdminBanPlayerResult_strings[idx].get();
}
bool AdminBanPlayerAckMessage_AdminBanPlayerResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminBanPlayerAckMessage_AdminBanPlayerResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AdminBanPlayerAckMessage_AdminBanPlayerResult_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AdminBanPlayerAckMessage_AdminBanPlayerResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banPlayerAccepted;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banPlayerPending;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banPlayerNoDB;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banPlayerDBError;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banPlayerInvalid;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::AdminBanPlayerResult_MIN;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::AdminBanPlayerResult_MAX;
constexpr int AdminBanPlayerAckMessage::AdminBanPlayerResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PokerTHMessage_PokerTHMessageType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PokerTHMessage_PokerTHMessageType_strings[81] = {};

static const char PokerTHMessage_PokerTHMessageType_names[] =
  "Type_AdminBanPlayerAckMessage"
  "Type_AdminBanPlayerMessage"
  "Type_AdminRemoveGameAckMessage"
  "Type_AdminRemoveGameMessage"
  "Type_AfterHandShowCardsMessage"
  "Type_AllInShowCardsMessage"
  "Type_AnnounceMessage"
  "Type_AskKickDeniedMessage"
  "Type_AskKickPlayerMessage"
  "Type_AuthClientResponseMessage"
  "Type_AuthServerChallengeMessage"
  "Type_AuthServerVerificationMessage"
  "Type_AvatarDataMessage"
  "Type_AvatarEndMessage"
  "Type_AvatarHeaderMessage"
  "Type_AvatarRequestMessage"
  "Type_ChatMessage"
  "Type_ChatRejectMessage"
  "Type_ChatRequestMessage"
  "Type_DealFlopCardsMessage"
  "Type_DealRiverCardMessage"
  "Type_DealTurnCardMessage"
  "Type_DialogMessage"
  "Type_EndKickPetitionMessage"
  "Type_EndOfGameMessage"
  "Type_EndOfHandHideCardsMessage"
  "Type_EndOfHandShowCardsMessage"
  "Type_ErrorMessage"
  "Type_GameAdminChangedMessage"
  "Type_GameListAdminChangedMessage"
  "Type_GameListNewMessage"
  "Type_GameListPlayerJoinedMessage"
  "Type_GameListPlayerLeftMessage"
  "Type_GameListSpectatorJoinedMessage"
  "Type_GameListSpectatorLeftMessage"
  "Type_GameListUpdateMessage"
  "Type_GamePlayerJoinedMessage"
  "Type_GamePlayerLeftMessage"
  "Type_GameSpectatorJoinedMessage"
  "Type_GameSpectatorLeftMessage"
  "Type_GameStartInitialMessage"
  "Type_GameStartRejoinMessage"
  "Type_HandStartMessage"
  "Type_InitAckMessage"
  "Type_InitMessage"
  "Type_InviteNotifyMessage"
  "Type_InvitePlayerToGameMessage"
  "Type_JoinExistingGameMessage"
  "Type_JoinGameAckMessage"
  "Type_JoinGameFailedMessage"
  "Type_JoinNewGameMessage"
  "Type_KickPetitionUpdateMessage"
  "Type_KickPlayerRequestMessage"
  "Type_LeaveGameRequestMessage"
  "Type_MyActionRequestMessage"
  "Type_PlayerIdChangedMessage"
  "Type_PlayerInfoReplyMessage"
  "Type_PlayerInfoRequestMessage"
  "Type_PlayerListMessage"
  "Type_PlayersActionDoneMessage"
  "Type_PlayersTurnMessage"
  "Type_RejectGameInvitationMessage"
  "Type_RejectInvNotifyMessage"
  "Type_RejoinExistingGameMessage"
  "Type_RemovedFromGameMessage"
  "Type_ReportAvatarAckMessage"
  "Type_ReportAvatarMessage"
  "Type_ReportGameAckMessage"
  "Type_ReportGameMessage"
  "Type_ResetTimeoutMessage"
  "Type_ShowMyCardsRequestMessage"
  "Type_StartEventAckMessage"
  "Type_StartEventMessage"
  "Type_StartKickPetitionMessage"
  "Type_StatisticsMessage"
  "Type_SubscriptionRequestMessage"
  "Type_TimeoutWarningMessage"
  "Type_UnknownAvatarMessage"
  "Type_VoteKickReplyMessage"
  "Type_VoteKickRequestMessage"
  "Type_YourActionRejectedMessage";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PokerTHMessage_PokerTHMessageType_entries[] = {
  { {PokerTHMessage_PokerTHMessageType_names + 0, 29}, 77 },
  { {PokerTHMessage_PokerTHMessageType_names + 29, 26}, 76 },
  { {PokerTHMessage_PokerTHMessageType_names + 55, 30}, 75 },
  { {PokerTHMessage_PokerTHMessageType_names + 85, 27}, 74 },
  { {PokerTHMessage_PokerTHMessageType_names + 112, 30}, 52 },
  { {PokerTHMessage_PokerTHMessageType_names + 142, 26}, 48 },
  { {PokerTHMessage_PokerTHMessageType_names + 168, 20}, 1 },
  { {PokerTHMessage_PokerTHMessageType_names + 188, 25}, 56 },
  { {PokerTHMessage_PokerTHMessageType_names + 213, 25}, 55 },
  { {PokerTHMessage_PokerTHMessageType_names + 238, 30}, 4 },
  { {PokerTHMessage_PokerTHMessageType_names + 268, 31}, 3 },
  { {PokerTHMessage_PokerTHMessageType_names + 299, 34}, 5 },
  { {PokerTHMessage_PokerTHMessageType_names + 333, 22}, 9 },
  { {PokerTHMessage_PokerTHMessageType_names + 355, 21}, 10 },
  { {PokerTHMessage_PokerTHMessageType_names + 376, 24}, 8 },
  { {PokerTHMessage_PokerTHMessageType_names + 400, 25}, 7 },
  { {PokerTHMessage_PokerTHMessageType_names + 425, 16}, 64 },
  { {PokerTHMessage_PokerTHMessageType_names + 441, 22}, 65 },
  { {PokerTHMessage_PokerTHMessageType_names + 463, 23}, 63 },
  { {PokerTHMessage_PokerTHMessageType_names + 486, 25}, 45 },
  { {PokerTHMessage_PokerTHMessageType_names + 511, 25}, 47 },
  { {PokerTHMessage_PokerTHMessageType_names + 536, 24}, 46 },
  { {PokerTHMessage_PokerTHMessageType_names + 560, 18}, 66 },
  { {PokerTHMessage_PokerTHMessageType_names + 578, 27}, 61 },
  { {PokerTHMessage_PokerTHMessageType_names + 605, 21}, 53 },
  { {PokerTHMessage_PokerTHMessageType_names + 626, 30}, 50 },
  { {PokerTHMessage_PokerTHMessageType_names + 656, 30}, 49 },
  { {PokerTHMessage_PokerTHMessageType_names + 686, 17}, 73 },
  { {PokerTHMessage_PokerTHMessageType_names + 703, 28}, 28 },
  { {PokerTHMessage_PokerTHMessageType_names + 731, 32}, 17 },
  { {PokerTHMessage_PokerTHMessageType_names + 763, 23}, 13 },
  { {PokerTHMessage_PokerTHMessageType_names + 786, 32}, 15 },
  { {PokerTHMessage_PokerTHMessageType_names + 818, 30}, 16 },
  { {PokerTHMessage_PokerTHMessageType_names + 848, 35}, 78 },
  { {PokerTHMessage_PokerTHMessageType_names + 883, 33}, 79 },
  { {PokerTHMessage_PokerTHMessageType_names + 916, 26}, 14 },
  { {PokerTHMessage_PokerTHMessageType_names + 942, 28}, 26 },
  { {PokerTHMessage_PokerTHMessageType_names + 970, 26}, 27 },
  { {PokerTHMessage_PokerTHMessageType_names + 996, 31}, 80 },
  { {PokerTHMessage_PokerTHMessageType_names + 1027, 29}, 81 },
  { {PokerTHMessage_PokerTHMessageType_names + 1056, 28}, 38 },
  { {PokerTHMessage_PokerTHMessageType_names + 1084, 27}, 39 },
  { {PokerTHMessage_PokerTHMessageType_names + 1111, 21}, 40 },
  { {PokerTHMessage_PokerTHMessageType_names + 1132, 19}, 6 },
  { {PokerTHMessage_PokerTHMessageType_names + 1151, 16}, 2 },
  { {PokerTHMessage_PokerTHMessageType_names + 1167, 24}, 33 },
  { {PokerTHMessage_PokerTHMessageType_names + 1191, 30}, 32 },
  { {PokerTHMessage_PokerTHMessageType_names + 1221, 28}, 21 },
  { {PokerTHMessage_PokerTHMessageType_names + 1249, 23}, 24 },
  { {PokerTHMessage_PokerTHMessageType_names + 1272, 26}, 25 },
  { {PokerTHMessage_PokerTHMessageType_names + 1298, 23}, 22 },
  { {PokerTHMessage_PokerTHMessageType_names + 1321, 30}, 60 },
  { {PokerTHMessage_PokerTHMessageType_names + 1351, 29}, 30 },
  { {PokerTHMessage_PokerTHMessageType_names + 1380, 28}, 31 },
  { {PokerTHMessage_PokerTHMessageType_names + 1408, 27}, 42 },
  { {PokerTHMessage_PokerTHMessageType_names + 1435, 27}, 54 },
  { {PokerTHMessage_PokerTHMessageType_names + 1462, 27}, 19 },
  { {PokerTHMessage_PokerTHMessageType_names + 1489, 29}, 18 },
  { {PokerTHMessage_PokerTHMessageType_names + 1518, 22}, 12 },
  { {PokerTHMessage_PokerTHMessageType_names + 1540, 29}, 44 },
  { {PokerTHMessage_PokerTHMessageType_names + 1569, 23}, 41 },
  { {PokerTHMessage_PokerTHMessageType_names + 1592, 32}, 34 },
  { {PokerTHMessage_PokerTHMessageType_names + 1624, 27}, 35 },
  { {PokerTHMessage_PokerTHMessageType_names + 1651, 30}, 23 },
  { {PokerTHMessage_PokerTHMessageType_names + 1681, 27}, 29 },
  { {PokerTHMessage_PokerTHMessageType_names + 1708, 27}, 70 },
  { {PokerTHMessage_PokerTHMessageType_names + 1735, 24}, 69 },
  { {PokerTHMessage_PokerTHMessageType_names + 1759, 25}, 72 },
  { {PokerTHMessage_PokerTHMessageType_names + 1784, 22}, 71 },
  { {PokerTHMessage_PokerTHMessageType_names + 1806, 24}, 68 },
  { {PokerTHMessage_PokerTHMessageType_names + 1830, 30}, 51 },
  { {PokerTHMessage_PokerTHMessageType_names + 1860, 25}, 37 },
  { {PokerTHMessage_PokerTHMessageType_names + 1885, 22}, 36 },
  { {PokerTHMessage_PokerTHMessageType_names + 1907, 29}, 57 },
  { {PokerTHMessage_PokerTHMessageType_names + 1936, 22}, 62 },
  { {PokerTHMessage_PokerTHMessageType_names + 1958, 31}, 20 },
  { {PokerTHMessage_PokerTHMessageType_names + 1989, 26}, 67 },
  { {PokerTHMessage_PokerTHMessageType_names + 2015, 25}, 11 },
  { {PokerTHMessage_PokerTHMessageType_names + 2040, 25}, 59 },
  { {PokerTHMessage_PokerTHMessageType_names + 2065, 27}, 58 },
  { {PokerTHMessage_PokerTHMessageType_names + 2092, 30}, 43 },
};

static const int PokerTHMessage_PokerTHMessageType_entries_by_number[] = {
  6, // 1 -> Type_AnnounceMessage
  44, // 2 -> Type_InitMessage
  10, // 3 -> Type_AuthServerChallengeMessage
  9, // 4 -> Type_AuthClientResponseMessage
  11, // 5 -> Type_AuthServerVerificationMessage
  43, // 6 -> Type_InitAckMessage
  15, // 7 -> Type_AvatarRequestMessage
  14, // 8 -> Type_AvatarHeaderMessage
  12, // 9 -> Type_AvatarDataMessage
  13, // 10 -> Type_AvatarEndMessage
  77, // 11 -> Type_UnknownAvatarMessage
  58, // 12 -> Type_PlayerListMessage
  30, // 13 -> Type_GameListNewMessage
  35, // 14 -> Type_GameListUpdateMessage
  31, // 15 -> Type_GameListPlayerJoinedMessage
  32, // 16 -> Type_GameListPlayerLeftMessage
  29, // 17 -> Type_GameListAdminChangedMessage
  57, // 18 -> Type_PlayerInfoRequestMessage
  56, // 19 -> Type_PlayerInfoReplyMessage
  75, // 20 -> Type_SubscriptionRequestMessage
  47, // 21 -> Type_JoinExistingGameMessage
  50, // 22 -> Type_JoinNewGameMessage
  63, // 23 -> Type_RejoinExistingGameMessage
  48, // 24 -> Type_JoinGameAckMessage
  49, // 25 -> Type_JoinGameFailedMessage
  36, // 26 -> Type_GamePlayerJoinedMessage
  37, // 27 -> Type_GamePlayerLeftMessage
  28, // 28 -> Type_GameAdminChangedMessage
  64, // 29 -> Type_RemovedFromGameMessage
  52, // 30 -> Type_KickPlayerRequestMessage
  53, // 31 -> Type_LeaveGameRequestMessage
  46, // 32 -> Type_InvitePlayerToGameMessage
  45, // 33 -> Type_InviteNotifyMessage
  61, // 34 -> Type_RejectGameInvitationMessage
  62, // 35 -> Type_RejectInvNotifyMessage
  72, // 36 -> Type_StartEventMessage
  71, // 37 -> Type_StartEventAckMessage
  40, // 38 -> Type_GameStartInitialMessage
  41, // 39 -> Type_GameStartRejoinMessage
  42, // 40 -> Type_HandStartMessage
  60, // 41 -> Type_PlayersTurnMessage
  54, // 42 -> Type_MyActionRequestMessage
  80, // 43 -> Type_YourActionRejectedMessage
  59, // 44 -> Type_PlayersActionDoneMessage
  19, // 45 -> Type_DealFlopCardsMessage
  21, // 46 -> Type_DealTurnCardMessage
  20, // 47 -> Type_DealRiverCardMessage
  5, // 48 -> Type_AllInShowCardsMessage
  26, // 49 -> Type_EndOfHandShowCardsMessage
  25, // 50 -> Type_EndOfHandHideCardsMessage
  70, // 51 -> Type_ShowMyCardsRequestMessage
  4, // 52 -> Type_AfterHandShowCardsMessage
  24, // 53 -> Type_EndOfGameMessage
  55, // 54 -> Type_PlayerIdChangedMessage
  8, // 55 -> Type_AskKickPlayerMessage
  7, // 56 -> Type_AskKickDeniedMessage
  73, // 57 -> Type_StartKickPetitionMessage
  79, // 58 -> Type_VoteKickRequestMessage
  78, // 59 -> Type_VoteKickReplyMessage
  51, // 60 -> Type_KickPetitionUpdateMessage
  23, // 61 -> Type_EndKickPetitionMessage
  74, // 62 -> Type_StatisticsMessage
  18, // 63 -> Type_ChatRequestMessage
  16, // 64 -> Type_ChatMessage
  17, // 65 -> Type_ChatRejectMessage
  22, // 66 -> Type_DialogMessage
  76, // 67 -> Type_TimeoutWarningMessage
  69, // 68 -> Type_ResetTimeoutMessage
  66, // 69 -> Type_ReportAvatarMessage
  65, // 70 -> Type_ReportAvatarAckMessage
  68, // 71 -> Type_ReportGameMessage
  67, // 72 -> Type_ReportGameAckMessage
  27, // 73 -> Type_ErrorMessage
  3, // 74 -> Type_AdminRemoveGameMessage
  2, // 75 -> Type_AdminRemoveGameAckMessage
  1, // 76 -> Type_AdminBanPlayerMessage
  0, // 77 -> Type_AdminBanPlayerAckMessage
  33, // 78 -> Type_GameListSpectatorJoinedMessage
  34, // 79 -> Type_GameListSpectatorLeftMessage
  38, // 80 -> Type_GameSpectatorJoinedMessage
  39, // 81 -> Type_GameSpectatorLeftMessage
};

const std::string& PokerTHMessage_PokerTHMessageType_Name(
    PokerTHMessage_PokerTHMessageType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PokerTHMessage_PokerTHMessageType_entries,
          PokerTHMessage_PokerTHMessageType_entries_by_number,
          81, PokerTHMessage_PokerTHMessageType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PokerTHMessage_PokerTHMessageType_entries,
      PokerTHMessage_PokerTHMessageType_entries_by_number,
      81, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PokerTHMessage_PokerTHMessageType_strings[idx].get();
}
bool PokerTHMessage_PokerTHMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PokerTHMessage_PokerTHMessageType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PokerTHMessage_PokerTHMessageType_entries, 81, name, &int_value);
  if (success) {
    *value = static_cast<PokerTHMessage_PokerTHMessageType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AnnounceMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_InitMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AuthServerChallengeMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AuthClientResponseMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AuthServerVerificationMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_InitAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AvatarRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AvatarHeaderMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AvatarDataMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AvatarEndMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_UnknownAvatarMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_PlayerListMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListNewMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListUpdateMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListPlayerJoinedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListPlayerLeftMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListAdminChangedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_PlayerInfoRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_PlayerInfoReplyMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_SubscriptionRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_JoinExistingGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_JoinNewGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_RejoinExistingGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_JoinGameAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_JoinGameFailedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GamePlayerJoinedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GamePlayerLeftMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameAdminChangedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_RemovedFromGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_KickPlayerRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_LeaveGameRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_InvitePlayerToGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_InviteNotifyMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_RejectGameInvitationMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_RejectInvNotifyMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_StartEventMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_StartEventAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameStartInitialMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameStartRejoinMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_HandStartMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_PlayersTurnMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_MyActionRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_YourActionRejectedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_PlayersActionDoneMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_DealFlopCardsMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_DealTurnCardMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_DealRiverCardMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AllInShowCardsMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_EndOfHandShowCardsMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_EndOfHandHideCardsMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ShowMyCardsRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AfterHandShowCardsMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_EndOfGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_PlayerIdChangedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AskKickPlayerMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AskKickDeniedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_StartKickPetitionMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_VoteKickRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_VoteKickReplyMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_KickPetitionUpdateMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_EndKickPetitionMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_StatisticsMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ChatRequestMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ChatMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ChatRejectMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_DialogMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_TimeoutWarningMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ResetTimeoutMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ReportAvatarMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ReportAvatarAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ReportGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ReportGameAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_ErrorMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AdminRemoveGameMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AdminRemoveGameAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AdminBanPlayerMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_AdminBanPlayerAckMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListSpectatorJoinedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameListSpectatorLeftMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameSpectatorJoinedMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::Type_GameSpectatorLeftMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::PokerTHMessageType_MIN;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage::PokerTHMessageType_MAX;
constexpr int PokerTHMessage::PokerTHMessageType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NetGameMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetGameMode_strings[3] = {};

static const char NetGameMode_names[] =
  "netGameClosed"
  "netGameCreated"
  "netGameStarted";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetGameMode_entries[] = {
  { {NetGameMode_names + 0, 13}, 3 },
  { {NetGameMode_names + 13, 14}, 1 },
  { {NetGameMode_names + 27, 14}, 2 },
};

static const int NetGameMode_entries_by_number[] = {
  1, // 1 -> netGameCreated
  2, // 2 -> netGameStarted
  0, // 3 -> netGameClosed
};

const std::string& NetGameMode_Name(
    NetGameMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetGameMode_entries,
          NetGameMode_entries_by_number,
          3, NetGameMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetGameMode_entries,
      NetGameMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetGameMode_strings[idx].get();
}
bool NetGameMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetGameMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NetGameMode>(int_value);
  }
  return success;
}
bool NetGameState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetGameState_strings[6] = {};

static const char NetGameState_names[] =
  "netStateFlop"
  "netStatePreflop"
  "netStatePreflopBigBlind"
  "netStatePreflopSmallBlind"
  "netStateRiver"
  "netStateTurn";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetGameState_entries[] = {
  { {NetGameState_names + 0, 12}, 1 },
  { {NetGameState_names + 12, 15}, 0 },
  { {NetGameState_names + 27, 23}, 5 },
  { {NetGameState_names + 50, 25}, 4 },
  { {NetGameState_names + 75, 13}, 3 },
  { {NetGameState_names + 88, 12}, 2 },
};

static const int NetGameState_entries_by_number[] = {
  1, // 0 -> netStatePreflop
  0, // 1 -> netStateFlop
  5, // 2 -> netStateTurn
  4, // 3 -> netStateRiver
  3, // 4 -> netStatePreflopSmallBlind
  2, // 5 -> netStatePreflopBigBlind
};

const std::string& NetGameState_Name(
    NetGameState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetGameState_entries,
          NetGameState_entries_by_number,
          6, NetGameState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetGameState_entries,
      NetGameState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetGameState_strings[idx].get();
}
bool NetGameState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetGameState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<NetGameState>(int_value);
  }
  return success;
}
bool NetPlayerAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetPlayerAction_strings[7] = {};

static const char NetPlayerAction_names[] =
  "netActionAllIn"
  "netActionBet"
  "netActionCall"
  "netActionCheck"
  "netActionFold"
  "netActionNone"
  "netActionRaise";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetPlayerAction_entries[] = {
  { {NetPlayerAction_names + 0, 14}, 6 },
  { {NetPlayerAction_names + 14, 12}, 4 },
  { {NetPlayerAction_names + 26, 13}, 3 },
  { {NetPlayerAction_names + 39, 14}, 2 },
  { {NetPlayerAction_names + 53, 13}, 1 },
  { {NetPlayerAction_names + 66, 13}, 0 },
  { {NetPlayerAction_names + 79, 14}, 5 },
};

static const int NetPlayerAction_entries_by_number[] = {
  5, // 0 -> netActionNone
  4, // 1 -> netActionFold
  3, // 2 -> netActionCheck
  2, // 3 -> netActionCall
  1, // 4 -> netActionBet
  6, // 5 -> netActionRaise
  0, // 6 -> netActionAllIn
};

const std::string& NetPlayerAction_Name(
    NetPlayerAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetPlayerAction_entries,
          NetPlayerAction_entries_by_number,
          7, NetPlayerAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetPlayerAction_entries,
      NetPlayerAction_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetPlayerAction_strings[idx].get();
}
bool NetPlayerAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetPlayerAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetPlayerAction_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<NetPlayerAction>(int_value);
  }
  return success;
}
bool NetPlayerState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetPlayerState_strings[3] = {};

static const char NetPlayerState_names[] =
  "netPlayerStateNoMoney"
  "netPlayerStateNormal"
  "netPlayerStateSessionInactive";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetPlayerState_entries[] = {
  { {NetPlayerState_names + 0, 21}, 2 },
  { {NetPlayerState_names + 21, 20}, 0 },
  { {NetPlayerState_names + 41, 29}, 1 },
};

static const int NetPlayerState_entries_by_number[] = {
  1, // 0 -> netPlayerStateNormal
  2, // 1 -> netPlayerStateSessionInactive
  0, // 2 -> netPlayerStateNoMoney
};

const std::string& NetPlayerState_Name(
    NetPlayerState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetPlayerState_entries,
          NetPlayerState_entries_by_number,
          3, NetPlayerState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetPlayerState_entries,
      NetPlayerState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetPlayerState_strings[idx].get();
}
bool NetPlayerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetPlayerState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetPlayerState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NetPlayerState>(int_value);
  }
  return success;
}
bool NetPlayerInfoRights_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetPlayerInfoRights_strings[3] = {};

static const char NetPlayerInfoRights_names[] =
  "netPlayerRightsAdmin"
  "netPlayerRightsGuest"
  "netPlayerRightsNormal";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetPlayerInfoRights_entries[] = {
  { {NetPlayerInfoRights_names + 0, 20}, 3 },
  { {NetPlayerInfoRights_names + 20, 20}, 1 },
  { {NetPlayerInfoRights_names + 40, 21}, 2 },
};

static const int NetPlayerInfoRights_entries_by_number[] = {
  1, // 1 -> netPlayerRightsGuest
  2, // 2 -> netPlayerRightsNormal
  0, // 3 -> netPlayerRightsAdmin
};

const std::string& NetPlayerInfoRights_Name(
    NetPlayerInfoRights value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetPlayerInfoRights_entries,
          NetPlayerInfoRights_entries_by_number,
          3, NetPlayerInfoRights_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetPlayerInfoRights_entries,
      NetPlayerInfoRights_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetPlayerInfoRights_strings[idx].get();
}
bool NetPlayerInfoRights_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetPlayerInfoRights* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetPlayerInfoRights_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NetPlayerInfoRights>(int_value);
  }
  return success;
}
bool NetAvatarType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetAvatarType_strings[3] = {};

static const char NetAvatarType_names[] =
  "netAvatarImageGif"
  "netAvatarImageJpg"
  "netAvatarImagePng";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetAvatarType_entries[] = {
  { {NetAvatarType_names + 0, 17}, 3 },
  { {NetAvatarType_names + 17, 17}, 2 },
  { {NetAvatarType_names + 34, 17}, 1 },
};

static const int NetAvatarType_entries_by_number[] = {
  2, // 1 -> netAvatarImagePng
  1, // 2 -> netAvatarImageJpg
  0, // 3 -> netAvatarImageGif
};

const std::string& NetAvatarType_Name(
    NetAvatarType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetAvatarType_entries,
          NetAvatarType_entries_by_number,
          3, NetAvatarType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetAvatarType_entries,
      NetAvatarType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetAvatarType_strings[idx].get();
}
bool NetAvatarType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetAvatarType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetAvatarType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NetAvatarType>(int_value);
  }
  return success;
}

// ===================================================================

class NetGameInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<NetGameInfo>()._has_bits_);
  static void set_has_gamename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_netgametype(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_maxnumplayers(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raiseintervalmode(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_raiseeveryhands(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_raiseeveryminutes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_endraisemode(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_endraisesmallblindvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_proposedguispeed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_delaybetweenhands(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_playeractiontimeout(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_firstsmallblind(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_startmoney(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_allowspectators(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00001fe3) ^ 0x00001fe3) != 0;
  }
};

NetGameInfo::NetGameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  manualblinds_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:NetGameInfo)
}
NetGameInfo::NetGameInfo(const NetGameInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      manualblinds_(from.manualblinds_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  gamename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gamename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gamename()) {
    gamename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_gamename(), 
      GetArenaForAllocation());
  }
  ::memcpy(&maxnumplayers_, &from.maxnumplayers_,
    static_cast<size_t>(reinterpret_cast<char*>(&allowspectators_) -
    reinterpret_cast<char*>(&maxnumplayers_)) + sizeof(allowspectators_));
  // @@protoc_insertion_point(copy_constructor:NetGameInfo)
}

inline void NetGameInfo::SharedCtor() {
gamename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gamename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&maxnumplayers_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&startmoney_) -
    reinterpret_cast<char*>(&maxnumplayers_)) + sizeof(startmoney_));
netgametype_ = 1;
raiseintervalmode_ = 1;
endraisemode_ = 1;
allowspectators_ = true;
}

NetGameInfo::~NetGameInfo() {
  // @@protoc_insertion_point(destructor:NetGameInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NetGameInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  gamename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NetGameInfo::ArenaDtor(void* object) {
  NetGameInfo* _this = reinterpret_cast< NetGameInfo* >(object);
  (void)_this;
}
void NetGameInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NetGameInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NetGameInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetGameInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  manualblinds_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    gamename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&maxnumplayers_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playeractiontimeout_) -
        reinterpret_cast<char*>(&maxnumplayers_)) + sizeof(playeractiontimeout_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&firstsmallblind_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&startmoney_) -
        reinterpret_cast<char*>(&firstsmallblind_)) + sizeof(startmoney_));
    netgametype_ = 1;
    raiseintervalmode_ = 1;
    endraisemode_ = 1;
    allowspectators_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetGameInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string gameName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gamename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameInfo.NetGameType netGameType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameInfo_NetGameType_IsValid(val))) {
            _internal_set_netgametype(static_cast<::NetGameInfo_NetGameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 maxNumPlayers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_maxnumplayers(&has_bits);
          maxnumplayers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameInfo_RaiseIntervalMode_IsValid(val))) {
            _internal_set_raiseintervalmode(static_cast<::NetGameInfo_RaiseIntervalMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 raiseEveryHands = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_raiseeveryhands(&has_bits);
          raiseeveryhands_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 raiseEveryMinutes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_raiseeveryminutes(&has_bits);
          raiseeveryminutes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameInfo_EndRaiseMode_IsValid(val))) {
            _internal_set_endraisemode(static_cast<::NetGameInfo_EndRaiseMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 endRaiseSmallBlindValue = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_endraisesmallblindvalue(&has_bits);
          endraisesmallblindvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 proposedGuiSpeed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_proposedguispeed(&has_bits);
          proposedguispeed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 delayBetweenHands = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_delaybetweenhands(&has_bits);
          delaybetweenhands_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerActionTimeout = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_playeractiontimeout(&has_bits);
          playeractiontimeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 firstSmallBlind = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_firstsmallblind(&has_bits);
          firstsmallblind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 startMoney = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_startmoney(&has_bits);
          startmoney_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 manualBlinds = 14 [packed = true];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_manualblinds(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 112) {
          _internal_add_manualblinds(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allowSpectators = 15 [default = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_allowspectators(&has_bits);
          allowspectators_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetGameInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NetGameInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string gameName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_gamename(), target);
  }

  // required .NetGameInfo.NetGameType netGameType = 2;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_netgametype(), target);
  }

  // required uint32 maxNumPlayers = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_maxnumplayers(), target);
  }

  // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_raiseintervalmode(), target);
  }

  // optional uint32 raiseEveryHands = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_raiseeveryhands(), target);
  }

  // optional uint32 raiseEveryMinutes = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_raiseeveryminutes(), target);
  }

  // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_endraisemode(), target);
  }

  // optional uint32 endRaiseSmallBlindValue = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_endraisesmallblindvalue(), target);
  }

  // required uint32 proposedGuiSpeed = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_proposedguispeed(), target);
  }

  // required uint32 delayBetweenHands = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_delaybetweenhands(), target);
  }

  // required uint32 playerActionTimeout = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_playeractiontimeout(), target);
  }

  // required uint32 firstSmallBlind = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_firstsmallblind(), target);
  }

  // required uint32 startMoney = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_startmoney(), target);
  }

  // repeated uint32 manualBlinds = 14 [packed = true];
  {
    int byte_size = _manualblinds_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          14, _internal_manualblinds(), byte_size, target);
    }
  }

  // optional bool allowSpectators = 15 [default = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_allowspectators(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NetGameInfo)
  return target;
}

size_t NetGameInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetGameInfo)
  size_t total_size = 0;

  if (_internal_has_gamename()) {
    // required string gameName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gamename());
  }

  if (_internal_has_maxnumplayers()) {
    // required uint32 maxNumPlayers = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_maxnumplayers());
  }

  if (_internal_has_proposedguispeed()) {
    // required uint32 proposedGuiSpeed = 9;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_proposedguispeed());
  }

  if (_internal_has_delaybetweenhands()) {
    // required uint32 delayBetweenHands = 10;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_delaybetweenhands());
  }

  if (_internal_has_playeractiontimeout()) {
    // required uint32 playerActionTimeout = 11;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playeractiontimeout());
  }

  if (_internal_has_firstsmallblind()) {
    // required uint32 firstSmallBlind = 12;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_firstsmallblind());
  }

  if (_internal_has_startmoney()) {
    // required uint32 startMoney = 13;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_startmoney());
  }

  if (_internal_has_netgametype()) {
    // required .NetGameInfo.NetGameType netGameType = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_netgametype());
  }

  if (_internal_has_raiseintervalmode()) {
    // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_raiseintervalmode());
  }

  if (_internal_has_endraisemode()) {
    // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_endraisemode());
  }

  return total_size;
}
size_t NetGameInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NetGameInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00001fe3) ^ 0x00001fe3) == 0) {  // All required fields are present.
    // required string gameName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gamename());

    // required uint32 maxNumPlayers = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_maxnumplayers());

    // required uint32 proposedGuiSpeed = 9;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_proposedguispeed());

    // required uint32 delayBetweenHands = 10;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_delaybetweenhands());

    // required uint32 playerActionTimeout = 11;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playeractiontimeout());

    // required uint32 firstSmallBlind = 12;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_firstsmallblind());

    // required uint32 startMoney = 13;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_startmoney());

    // required .NetGameInfo.NetGameType netGameType = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_netgametype());

    // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_raiseintervalmode());

    // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_endraisemode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 manualBlinds = 14 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->manualblinds_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _manualblinds_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional uint32 raiseEveryHands = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_raiseeveryhands());
    }

    // optional uint32 raiseEveryMinutes = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_raiseeveryminutes());
    }

    // optional uint32 endRaiseSmallBlindValue = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_endraisesmallblindvalue());
    }

  }
  // optional bool allowSpectators = 15 [default = true];
  if (cached_has_bits & 0x00002000u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetGameInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NetGameInfo*>(
      &from));
}

void NetGameInfo::MergeFrom(const NetGameInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetGameInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  manualblinds_.MergeFrom(from.manualblinds_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_gamename(from._internal_gamename());
    }
    if (cached_has_bits & 0x00000002u) {
      maxnumplayers_ = from.maxnumplayers_;
    }
    if (cached_has_bits & 0x00000004u) {
      raiseeveryhands_ = from.raiseeveryhands_;
    }
    if (cached_has_bits & 0x00000008u) {
      raiseeveryminutes_ = from.raiseeveryminutes_;
    }
    if (cached_has_bits & 0x00000010u) {
      endraisesmallblindvalue_ = from.endraisesmallblindvalue_;
    }
    if (cached_has_bits & 0x00000020u) {
      proposedguispeed_ = from.proposedguispeed_;
    }
    if (cached_has_bits & 0x00000040u) {
      delaybetweenhands_ = from.delaybetweenhands_;
    }
    if (cached_has_bits & 0x00000080u) {
      playeractiontimeout_ = from.playeractiontimeout_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      firstsmallblind_ = from.firstsmallblind_;
    }
    if (cached_has_bits & 0x00000200u) {
      startmoney_ = from.startmoney_;
    }
    if (cached_has_bits & 0x00000400u) {
      netgametype_ = from.netgametype_;
    }
    if (cached_has_bits & 0x00000800u) {
      raiseintervalmode_ = from.raiseintervalmode_;
    }
    if (cached_has_bits & 0x00001000u) {
      endraisemode_ = from.endraisemode_;
    }
    if (cached_has_bits & 0x00002000u) {
      allowspectators_ = from.allowspectators_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetGameInfo::CopyFrom(const NetGameInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetGameInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetGameInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void NetGameInfo::InternalSwap(NetGameInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manualblinds_.InternalSwap(&other->manualblinds_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &gamename_, lhs_arena,
      &other->gamename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetGameInfo, startmoney_)
      + sizeof(NetGameInfo::startmoney_)
      - PROTOBUF_FIELD_OFFSET(NetGameInfo, maxnumplayers_)>(
          reinterpret_cast<char*>(&maxnumplayers_),
          reinterpret_cast<char*>(&other->maxnumplayers_));
  swap(netgametype_, other->netgametype_);
  swap(raiseintervalmode_, other->raiseintervalmode_);
  swap(endraisemode_, other->endraisemode_);
  swap(allowspectators_, other->allowspectators_);
}

std::string NetGameInfo::GetTypeName() const {
  return "NetGameInfo";
}


// ===================================================================

class PlayerResult::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerResult>()._has_bits_);
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resultcard1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_resultcard2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_moneywon(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_playermoney(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cardsvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

PlayerResult::PlayerResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  besthandposition_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerResult)
}
PlayerResult::PlayerResult(const PlayerResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      besthandposition_(from.besthandposition_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&playerid_, &from.playerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&cardsvalue_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(cardsvalue_));
  // @@protoc_insertion_point(copy_constructor:PlayerResult)
}

inline void PlayerResult::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&playerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cardsvalue_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(cardsvalue_));
}

PlayerResult::~PlayerResult() {
  // @@protoc_insertion_point(destructor:PlayerResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerResult::ArenaDtor(void* object) {
  PlayerResult* _this = reinterpret_cast< PlayerResult* >(object);
  (void)_this;
}
void PlayerResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerResult::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  besthandposition_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&playerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cardsvalue_) -
        reinterpret_cast<char*>(&playerid_)) + sizeof(cardsvalue_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 resultCard1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_resultcard1(&has_bits);
          resultcard1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 resultCard2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_resultcard2(&has_bits);
          resultcard2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 bestHandPosition = 4 [packed = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_besthandposition(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_besthandposition(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 moneyWon = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_moneywon(&has_bits);
          moneywon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerMoney = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_playermoney(&has_bits);
          playermoney_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cardsValue = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_cardsvalue(&has_bits);
          cardsvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 playerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_playerid(), target);
  }

  // required uint32 resultCard1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_resultcard1(), target);
  }

  // required uint32 resultCard2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_resultcard2(), target);
  }

  // repeated uint32 bestHandPosition = 4 [packed = true];
  {
    int byte_size = _besthandposition_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          4, _internal_besthandposition(), byte_size, target);
    }
  }

  // required uint32 moneyWon = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_moneywon(), target);
  }

  // required uint32 playerMoney = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_playermoney(), target);
  }

  // optional uint32 cardsValue = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_cardsvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerResult)
  return target;
}

size_t PlayerResult::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayerResult)
  size_t total_size = 0;

  if (_internal_has_playerid()) {
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_resultcard1()) {
    // required uint32 resultCard1 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_resultcard1());
  }

  if (_internal_has_resultcard2()) {
    // required uint32 resultCard2 = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_resultcard2());
  }

  if (_internal_has_moneywon()) {
    // required uint32 moneyWon = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_moneywon());
  }

  if (_internal_has_playermoney()) {
    // required uint32 playerMoney = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());
  }

  return total_size;
}
size_t PlayerResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerResult)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required uint32 resultCard1 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_resultcard1());

    // required uint32 resultCard2 = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_resultcard2());

    // required uint32 moneyWon = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_moneywon());

    // required uint32 playerMoney = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 bestHandPosition = 4 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->besthandposition_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _besthandposition_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional uint32 cardsValue = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000020u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_cardsvalue());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerResult*>(
      &from));
}

void PlayerResult::MergeFrom(const PlayerResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  besthandposition_.MergeFrom(from.besthandposition_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      resultcard1_ = from.resultcard1_;
    }
    if (cached_has_bits & 0x00000004u) {
      resultcard2_ = from.resultcard2_;
    }
    if (cached_has_bits & 0x00000008u) {
      moneywon_ = from.moneywon_;
    }
    if (cached_has_bits & 0x00000010u) {
      playermoney_ = from.playermoney_;
    }
    if (cached_has_bits & 0x00000020u) {
      cardsvalue_ = from.cardsvalue_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerResult::CopyFrom(const PlayerResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerResult::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PlayerResult::InternalSwap(PlayerResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  besthandposition_.InternalSwap(&other->besthandposition_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerResult, cardsvalue_)
      + sizeof(PlayerResult::cardsvalue_)
      - PROTOBUF_FIELD_OFFSET(PlayerResult, playerid_)>(
          reinterpret_cast<char*>(&playerid_),
          reinterpret_cast<char*>(&other->playerid_));
}

std::string PlayerResult::GetTypeName() const {
  return "PlayerResult";
}


// ===================================================================

class AnnounceMessage_Version::_Internal {
 public:
  using HasBits = decltype(std::declval<AnnounceMessage_Version>()._has_bits_);
  static void set_has_majorversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minorversion(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AnnounceMessage_Version::AnnounceMessage_Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AnnounceMessage.Version)
}
AnnounceMessage_Version::AnnounceMessage_Version(const AnnounceMessage_Version& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&majorversion_, &from.majorversion_,
    static_cast<size_t>(reinterpret_cast<char*>(&minorversion_) -
    reinterpret_cast<char*>(&majorversion_)) + sizeof(minorversion_));
  // @@protoc_insertion_point(copy_constructor:AnnounceMessage.Version)
}

inline void AnnounceMessage_Version::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&majorversion_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minorversion_) -
    reinterpret_cast<char*>(&majorversion_)) + sizeof(minorversion_));
}

AnnounceMessage_Version::~AnnounceMessage_Version() {
  // @@protoc_insertion_point(destructor:AnnounceMessage.Version)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AnnounceMessage_Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AnnounceMessage_Version::ArenaDtor(void* object) {
  AnnounceMessage_Version* _this = reinterpret_cast< AnnounceMessage_Version* >(object);
  (void)_this;
}
void AnnounceMessage_Version::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnnounceMessage_Version::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnnounceMessage_Version::Clear() {
// @@protoc_insertion_point(message_clear_start:AnnounceMessage.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&majorversion_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minorversion_) -
        reinterpret_cast<char*>(&majorversion_)) + sizeof(minorversion_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AnnounceMessage_Version::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 majorVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_majorversion(&has_bits);
          majorversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 minorVersion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_minorversion(&has_bits);
          minorversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnnounceMessage_Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AnnounceMessage.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 majorVersion = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_majorversion(), target);
  }

  // required uint32 minorVersion = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_minorversion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AnnounceMessage.Version)
  return target;
}

size_t AnnounceMessage_Version::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AnnounceMessage.Version)
  size_t total_size = 0;

  if (_internal_has_majorversion()) {
    // required uint32 majorVersion = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_majorversion());
  }

  if (_internal_has_minorversion()) {
    // required uint32 minorVersion = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minorversion());
  }

  return total_size;
}
size_t AnnounceMessage_Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AnnounceMessage.Version)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 majorVersion = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_majorversion());

    // required uint32 minorVersion = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minorversion());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AnnounceMessage_Version::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AnnounceMessage_Version*>(
      &from));
}

void AnnounceMessage_Version::MergeFrom(const AnnounceMessage_Version& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AnnounceMessage.Version)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      majorversion_ = from.majorversion_;
    }
    if (cached_has_bits & 0x00000002u) {
      minorversion_ = from.minorversion_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AnnounceMessage_Version::CopyFrom(const AnnounceMessage_Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AnnounceMessage.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnnounceMessage_Version::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AnnounceMessage_Version::InternalSwap(AnnounceMessage_Version* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnnounceMessage_Version, minorversion_)
      + sizeof(AnnounceMessage_Version::minorversion_)
      - PROTOBUF_FIELD_OFFSET(AnnounceMessage_Version, majorversion_)>(
          reinterpret_cast<char*>(&majorversion_),
          reinterpret_cast<char*>(&other->majorversion_));
}

std::string AnnounceMessage_Version::GetTypeName() const {
  return "AnnounceMessage.Version";
}


// ===================================================================

class AnnounceMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AnnounceMessage>()._has_bits_);
  static const ::AnnounceMessage_Version& protocolversion(const AnnounceMessage* msg);
  static void set_has_protocolversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::AnnounceMessage_Version& latestgameversion(const AnnounceMessage* msg);
  static void set_has_latestgameversion(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latestbetarevision(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_servertype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_numplayersonserver(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::AnnounceMessage_Version&
AnnounceMessage::_Internal::protocolversion(const AnnounceMessage* msg) {
  return *msg->protocolversion_;
}
const ::AnnounceMessage_Version&
AnnounceMessage::_Internal::latestgameversion(const AnnounceMessage* msg) {
  return *msg->latestgameversion_;
}
AnnounceMessage::AnnounceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AnnounceMessage)
}
AnnounceMessage::AnnounceMessage(const AnnounceMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_protocolversion()) {
    protocolversion_ = new ::AnnounceMessage_Version(*from.protocolversion_);
  } else {
    protocolversion_ = nullptr;
  }
  if (from._internal_has_latestgameversion()) {
    latestgameversion_ = new ::AnnounceMessage_Version(*from.latestgameversion_);
  } else {
    latestgameversion_ = nullptr;
  }
  ::memcpy(&latestbetarevision_, &from.latestbetarevision_,
    static_cast<size_t>(reinterpret_cast<char*>(&numplayersonserver_) -
    reinterpret_cast<char*>(&latestbetarevision_)) + sizeof(numplayersonserver_));
  // @@protoc_insertion_point(copy_constructor:AnnounceMessage)
}

inline void AnnounceMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&protocolversion_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&numplayersonserver_) -
    reinterpret_cast<char*>(&protocolversion_)) + sizeof(numplayersonserver_));
}

AnnounceMessage::~AnnounceMessage() {
  // @@protoc_insertion_point(destructor:AnnounceMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AnnounceMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete protocolversion_;
  if (this != internal_default_instance()) delete latestgameversion_;
}

void AnnounceMessage::ArenaDtor(void* object) {
  AnnounceMessage* _this = reinterpret_cast< AnnounceMessage* >(object);
  (void)_this;
}
void AnnounceMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnnounceMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnnounceMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AnnounceMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(protocolversion_ != nullptr);
      protocolversion_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(latestgameversion_ != nullptr);
      latestgameversion_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&latestbetarevision_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&numplayersonserver_) -
        reinterpret_cast<char*>(&latestbetarevision_)) + sizeof(numplayersonserver_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AnnounceMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .AnnounceMessage.Version protocolVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_protocolversion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .AnnounceMessage.Version latestGameVersion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_latestgameversion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latestBetaRevision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_latestbetarevision(&has_bits);
          latestbetarevision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .AnnounceMessage.ServerType serverType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::AnnounceMessage_ServerType_IsValid(val))) {
            _internal_set_servertype(static_cast<::AnnounceMessage_ServerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 numPlayersOnServer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_numplayersonserver(&has_bits);
          numplayersonserver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnnounceMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AnnounceMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .AnnounceMessage.Version protocolVersion = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::protocolversion(this), target, stream);
  }

  // required .AnnounceMessage.Version latestGameVersion = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::latestgameversion(this), target, stream);
  }

  // required uint32 latestBetaRevision = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_latestbetarevision(), target);
  }

  // required .AnnounceMessage.ServerType serverType = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_servertype(), target);
  }

  // required uint32 numPlayersOnServer = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_numplayersonserver(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AnnounceMessage)
  return target;
}

size_t AnnounceMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AnnounceMessage)
  size_t total_size = 0;

  if (_internal_has_protocolversion()) {
    // required .AnnounceMessage.Version protocolVersion = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *protocolversion_);
  }

  if (_internal_has_latestgameversion()) {
    // required .AnnounceMessage.Version latestGameVersion = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *latestgameversion_);
  }

  if (_internal_has_latestbetarevision()) {
    // required uint32 latestBetaRevision = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latestbetarevision());
  }

  if (_internal_has_servertype()) {
    // required .AnnounceMessage.ServerType serverType = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_servertype());
  }

  if (_internal_has_numplayersonserver()) {
    // required uint32 numPlayersOnServer = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numplayersonserver());
  }

  return total_size;
}
size_t AnnounceMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AnnounceMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .AnnounceMessage.Version protocolVersion = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *protocolversion_);

    // required .AnnounceMessage.Version latestGameVersion = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *latestgameversion_);

    // required uint32 latestBetaRevision = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latestbetarevision());

    // required .AnnounceMessage.ServerType serverType = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_servertype());

    // required uint32 numPlayersOnServer = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numplayersonserver());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AnnounceMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AnnounceMessage*>(
      &from));
}

void AnnounceMessage::MergeFrom(const AnnounceMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AnnounceMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_protocolversion()->::AnnounceMessage_Version::MergeFrom(from._internal_protocolversion());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_latestgameversion()->::AnnounceMessage_Version::MergeFrom(from._internal_latestgameversion());
    }
    if (cached_has_bits & 0x00000004u) {
      latestbetarevision_ = from.latestbetarevision_;
    }
    if (cached_has_bits & 0x00000008u) {
      servertype_ = from.servertype_;
    }
    if (cached_has_bits & 0x00000010u) {
      numplayersonserver_ = from.numplayersonserver_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AnnounceMessage::CopyFrom(const AnnounceMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AnnounceMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnnounceMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_protocolversion()) {
    if (!protocolversion_->IsInitialized()) return false;
  }
  if (_internal_has_latestgameversion()) {
    if (!latestgameversion_->IsInitialized()) return false;
  }
  return true;
}

void AnnounceMessage::InternalSwap(AnnounceMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnnounceMessage, numplayersonserver_)
      + sizeof(AnnounceMessage::numplayersonserver_)
      - PROTOBUF_FIELD_OFFSET(AnnounceMessage, protocolversion_)>(
          reinterpret_cast<char*>(&protocolversion_),
          reinterpret_cast<char*>(&other->protocolversion_));
}

std::string AnnounceMessage::GetTypeName() const {
  return "AnnounceMessage";
}


// ===================================================================

class InitMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InitMessage>()._has_bits_);
  static const ::AnnounceMessage_Version& requestedversion(const InitMessage* msg);
  static void set_has_requestedversion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_buildid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mylastsessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_authserverpassword(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_login(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_nickname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_clientuserdata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_avatarhash(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000e0) ^ 0x000000e0) != 0;
  }
};

const ::AnnounceMessage_Version&
InitMessage::_Internal::requestedversion(const InitMessage* msg) {
  return *msg->requestedversion_;
}
InitMessage::InitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitMessage)
}
InitMessage::InitMessage(const InitMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  mylastsessionid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mylastsessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mylastsessionid()) {
    mylastsessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mylastsessionid(), 
      GetArenaForAllocation());
  }
  authserverpassword_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    authserverpassword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_authserverpassword()) {
    authserverpassword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_authserverpassword(), 
      GetArenaForAllocation());
  }
  nickname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nickname()) {
    nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nickname(), 
      GetArenaForAllocation());
  }
  clientuserdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clientuserdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_clientuserdata()) {
    clientuserdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_clientuserdata(), 
      GetArenaForAllocation());
  }
  avatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatarhash()) {
    avatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatarhash(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_requestedversion()) {
    requestedversion_ = new ::AnnounceMessage_Version(*from.requestedversion_);
  } else {
    requestedversion_ = nullptr;
  }
  ::memcpy(&buildid_, &from.buildid_,
    static_cast<size_t>(reinterpret_cast<char*>(&login_) -
    reinterpret_cast<char*>(&buildid_)) + sizeof(login_));
  // @@protoc_insertion_point(copy_constructor:InitMessage)
}

inline void InitMessage::SharedCtor() {
mylastsessionid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mylastsessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
authserverpassword_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  authserverpassword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nickname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clientuserdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clientuserdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
avatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&requestedversion_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&login_) -
    reinterpret_cast<char*>(&requestedversion_)) + sizeof(login_));
}

InitMessage::~InitMessage() {
  // @@protoc_insertion_point(destructor:InitMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  mylastsessionid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  authserverpassword_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nickname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  clientuserdata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  avatarhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete requestedversion_;
}

void InitMessage::ArenaDtor(void* object) {
  InitMessage* _this = reinterpret_cast< InitMessage* >(object);
  (void)_this;
}
void InitMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:InitMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mylastsessionid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      authserverpassword_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      nickname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      clientuserdata_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      avatarhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(requestedversion_ != nullptr);
      requestedversion_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&buildid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&login_) -
        reinterpret_cast<char*>(&buildid_)) + sizeof(login_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InitMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .AnnounceMessage.Version requestedVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_requestedversion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 buildId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_buildid(&has_bits);
          buildid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes myLastSessionId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mylastsessionid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string authServerPassword = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_authserverpassword();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .InitMessage.LoginType login = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::InitMessage_LoginType_IsValid(val))) {
            _internal_set_login(static_cast<::InitMessage_LoginType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string nickName = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_nickname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes clientUserData = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_clientuserdata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes avatarHash = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_avatarhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .AnnounceMessage.Version requestedVersion = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::requestedversion(this), target, stream);
  }

  // required uint32 buildId = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_buildid(), target);
  }

  // optional bytes myLastSessionId = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_mylastsessionid(), target);
  }

  // optional string authServerPassword = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_authserverpassword(), target);
  }

  // required .InitMessage.LoginType login = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_login(), target);
  }

  // optional string nickName = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_nickname(), target);
  }

  // optional bytes clientUserData = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_clientuserdata(), target);
  }

  // optional bytes avatarHash = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_avatarhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitMessage)
  return target;
}

size_t InitMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:InitMessage)
  size_t total_size = 0;

  if (_internal_has_requestedversion()) {
    // required .AnnounceMessage.Version requestedVersion = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *requestedversion_);
  }

  if (_internal_has_buildid()) {
    // required uint32 buildId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_buildid());
  }

  if (_internal_has_login()) {
    // required .InitMessage.LoginType login = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_login());
  }

  return total_size;
}
size_t InitMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000e0) ^ 0x000000e0) == 0) {  // All required fields are present.
    // required .AnnounceMessage.Version requestedVersion = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *requestedversion_);

    // required uint32 buildId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_buildid());

    // required .InitMessage.LoginType login = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_login());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes myLastSessionId = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_mylastsessionid());
    }

    // optional string authServerPassword = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_authserverpassword());
    }

    // optional string nickName = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nickname());
    }

    // optional bytes clientUserData = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_clientuserdata());
    }

    // optional bytes avatarHash = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_avatarhash());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitMessage*>(
      &from));
}

void InitMessage::MergeFrom(const InitMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_mylastsessionid(from._internal_mylastsessionid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_authserverpassword(from._internal_authserverpassword());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_nickname(from._internal_nickname());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_clientuserdata(from._internal_clientuserdata());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_avatarhash(from._internal_avatarhash());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_requestedversion()->::AnnounceMessage_Version::MergeFrom(from._internal_requestedversion());
    }
    if (cached_has_bits & 0x00000040u) {
      buildid_ = from.buildid_;
    }
    if (cached_has_bits & 0x00000080u) {
      login_ = from.login_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitMessage::CopyFrom(const InitMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_requestedversion()) {
    if (!requestedversion_->IsInitialized()) return false;
  }
  return true;
}

void InitMessage::InternalSwap(InitMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mylastsessionid_, lhs_arena,
      &other->mylastsessionid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &authserverpassword_, lhs_arena,
      &other->authserverpassword_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nickname_, lhs_arena,
      &other->nickname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &clientuserdata_, lhs_arena,
      &other->clientuserdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatarhash_, lhs_arena,
      &other->avatarhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitMessage, login_)
      + sizeof(InitMessage::login_)
      - PROTOBUF_FIELD_OFFSET(InitMessage, requestedversion_)>(
          reinterpret_cast<char*>(&requestedversion_),
          reinterpret_cast<char*>(&other->requestedversion_));
}

std::string InitMessage::GetTypeName() const {
  return "InitMessage";
}


// ===================================================================

class AuthServerChallengeMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthServerChallengeMessage>()._has_bits_);
  static void set_has_serverchallenge(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AuthServerChallengeMessage::AuthServerChallengeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AuthServerChallengeMessage)
}
AuthServerChallengeMessage::AuthServerChallengeMessage(const AuthServerChallengeMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  serverchallenge_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serverchallenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serverchallenge()) {
    serverchallenge_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serverchallenge(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:AuthServerChallengeMessage)
}

inline void AuthServerChallengeMessage::SharedCtor() {
serverchallenge_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serverchallenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthServerChallengeMessage::~AuthServerChallengeMessage() {
  // @@protoc_insertion_point(destructor:AuthServerChallengeMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AuthServerChallengeMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  serverchallenge_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AuthServerChallengeMessage::ArenaDtor(void* object) {
  AuthServerChallengeMessage* _this = reinterpret_cast< AuthServerChallengeMessage* >(object);
  (void)_this;
}
void AuthServerChallengeMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AuthServerChallengeMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthServerChallengeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AuthServerChallengeMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    serverchallenge_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthServerChallengeMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes serverChallenge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serverchallenge();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthServerChallengeMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AuthServerChallengeMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes serverChallenge = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_serverchallenge(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AuthServerChallengeMessage)
  return target;
}

size_t AuthServerChallengeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AuthServerChallengeMessage)
  size_t total_size = 0;

  // required bytes serverChallenge = 1;
  if (_internal_has_serverchallenge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_serverchallenge());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthServerChallengeMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthServerChallengeMessage*>(
      &from));
}

void AuthServerChallengeMessage::MergeFrom(const AuthServerChallengeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AuthServerChallengeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_serverchallenge()) {
    _internal_set_serverchallenge(from._internal_serverchallenge());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthServerChallengeMessage::CopyFrom(const AuthServerChallengeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AuthServerChallengeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthServerChallengeMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AuthServerChallengeMessage::InternalSwap(AuthServerChallengeMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serverchallenge_, lhs_arena,
      &other->serverchallenge_, rhs_arena
  );
}

std::string AuthServerChallengeMessage::GetTypeName() const {
  return "AuthServerChallengeMessage";
}


// ===================================================================

class AuthClientResponseMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthClientResponseMessage>()._has_bits_);
  static void set_has_clientresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AuthClientResponseMessage::AuthClientResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AuthClientResponseMessage)
}
AuthClientResponseMessage::AuthClientResponseMessage(const AuthClientResponseMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clientresponse_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clientresponse_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_clientresponse()) {
    clientresponse_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_clientresponse(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:AuthClientResponseMessage)
}

inline void AuthClientResponseMessage::SharedCtor() {
clientresponse_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clientresponse_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthClientResponseMessage::~AuthClientResponseMessage() {
  // @@protoc_insertion_point(destructor:AuthClientResponseMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AuthClientResponseMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  clientresponse_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AuthClientResponseMessage::ArenaDtor(void* object) {
  AuthClientResponseMessage* _this = reinterpret_cast< AuthClientResponseMessage* >(object);
  (void)_this;
}
void AuthClientResponseMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AuthClientResponseMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthClientResponseMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AuthClientResponseMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    clientresponse_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthClientResponseMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes clientResponse = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_clientresponse();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthClientResponseMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AuthClientResponseMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes clientResponse = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_clientresponse(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AuthClientResponseMessage)
  return target;
}

size_t AuthClientResponseMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AuthClientResponseMessage)
  size_t total_size = 0;

  // required bytes clientResponse = 1;
  if (_internal_has_clientresponse()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_clientresponse());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthClientResponseMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthClientResponseMessage*>(
      &from));
}

void AuthClientResponseMessage::MergeFrom(const AuthClientResponseMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AuthClientResponseMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_clientresponse()) {
    _internal_set_clientresponse(from._internal_clientresponse());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthClientResponseMessage::CopyFrom(const AuthClientResponseMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AuthClientResponseMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthClientResponseMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AuthClientResponseMessage::InternalSwap(AuthClientResponseMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &clientresponse_, lhs_arena,
      &other->clientresponse_, rhs_arena
  );
}

std::string AuthClientResponseMessage::GetTypeName() const {
  return "AuthClientResponseMessage";
}


// ===================================================================

class AuthServerVerificationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthServerVerificationMessage>()._has_bits_);
  static void set_has_serververification(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AuthServerVerificationMessage::AuthServerVerificationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AuthServerVerificationMessage)
}
AuthServerVerificationMessage::AuthServerVerificationMessage(const AuthServerVerificationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  serververification_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serververification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serververification()) {
    serververification_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serververification(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:AuthServerVerificationMessage)
}

inline void AuthServerVerificationMessage::SharedCtor() {
serververification_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serververification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthServerVerificationMessage::~AuthServerVerificationMessage() {
  // @@protoc_insertion_point(destructor:AuthServerVerificationMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AuthServerVerificationMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  serververification_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AuthServerVerificationMessage::ArenaDtor(void* object) {
  AuthServerVerificationMessage* _this = reinterpret_cast< AuthServerVerificationMessage* >(object);
  (void)_this;
}
void AuthServerVerificationMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AuthServerVerificationMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthServerVerificationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AuthServerVerificationMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    serververification_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthServerVerificationMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes serverVerification = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serververification();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthServerVerificationMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AuthServerVerificationMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes serverVerification = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_serververification(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AuthServerVerificationMessage)
  return target;
}

size_t AuthServerVerificationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AuthServerVerificationMessage)
  size_t total_size = 0;

  // required bytes serverVerification = 1;
  if (_internal_has_serververification()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_serververification());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthServerVerificationMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthServerVerificationMessage*>(
      &from));
}

void AuthServerVerificationMessage::MergeFrom(const AuthServerVerificationMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AuthServerVerificationMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_serververification()) {
    _internal_set_serververification(from._internal_serververification());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthServerVerificationMessage::CopyFrom(const AuthServerVerificationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AuthServerVerificationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthServerVerificationMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AuthServerVerificationMessage::InternalSwap(AuthServerVerificationMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serververification_, lhs_arena,
      &other->serververification_, rhs_arena
  );
}

std::string AuthServerVerificationMessage::GetTypeName() const {
  return "AuthServerVerificationMessage";
}


// ===================================================================

class InitAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InitAckMessage>()._has_bits_);
  static void set_has_yoursessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_yourplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_youravatarhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rejoingameid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

InitAckMessage::InitAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitAckMessage)
}
InitAckMessage::InitAckMessage(const InitAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  yoursessionid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    yoursessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_yoursessionid()) {
    yoursessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_yoursessionid(), 
      GetArenaForAllocation());
  }
  youravatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    youravatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_youravatarhash()) {
    youravatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_youravatarhash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&yourplayerid_, &from.yourplayerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&rejoingameid_) -
    reinterpret_cast<char*>(&yourplayerid_)) + sizeof(rejoingameid_));
  // @@protoc_insertion_point(copy_constructor:InitAckMessage)
}

inline void InitAckMessage::SharedCtor() {
yoursessionid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  yoursessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
youravatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  youravatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&yourplayerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rejoingameid_) -
    reinterpret_cast<char*>(&yourplayerid_)) + sizeof(rejoingameid_));
}

InitAckMessage::~InitAckMessage() {
  // @@protoc_insertion_point(destructor:InitAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  yoursessionid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  youravatarhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void InitAckMessage::ArenaDtor(void* object) {
  InitAckMessage* _this = reinterpret_cast< InitAckMessage* >(object);
  (void)_this;
}
void InitAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:InitAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      yoursessionid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      youravatarhash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&yourplayerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rejoingameid_) -
        reinterpret_cast<char*>(&yourplayerid_)) + sizeof(rejoingameid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InitAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes yourSessionId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_yoursessionid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 yourPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_yourplayerid(&has_bits);
          yourplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes yourAvatarHash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_youravatarhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rejoinGameId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rejoingameid(&has_bits);
          rejoingameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes yourSessionId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_yoursessionid(), target);
  }

  // required uint32 yourPlayerId = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_yourplayerid(), target);
  }

  // optional bytes yourAvatarHash = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_youravatarhash(), target);
  }

  // optional uint32 rejoinGameId = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rejoingameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitAckMessage)
  return target;
}

size_t InitAckMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:InitAckMessage)
  size_t total_size = 0;

  if (_internal_has_yoursessionid()) {
    // required bytes yourSessionId = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_yoursessionid());
  }

  if (_internal_has_yourplayerid()) {
    // required uint32 yourPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_yourplayerid());
  }

  return total_size;
}
size_t InitAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitAckMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required bytes yourSessionId = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_yoursessionid());

    // required uint32 yourPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_yourplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes yourAvatarHash = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_youravatarhash());
  }

  // optional uint32 rejoinGameId = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rejoingameid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitAckMessage*>(
      &from));
}

void InitAckMessage::MergeFrom(const InitAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_yoursessionid(from._internal_yoursessionid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_youravatarhash(from._internal_youravatarhash());
    }
    if (cached_has_bits & 0x00000004u) {
      yourplayerid_ = from.yourplayerid_;
    }
    if (cached_has_bits & 0x00000008u) {
      rejoingameid_ = from.rejoingameid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitAckMessage::CopyFrom(const InitAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void InitAckMessage::InternalSwap(InitAckMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &yoursessionid_, lhs_arena,
      &other->yoursessionid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &youravatarhash_, lhs_arena,
      &other->youravatarhash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitAckMessage, rejoingameid_)
      + sizeof(InitAckMessage::rejoingameid_)
      - PROTOBUF_FIELD_OFFSET(InitAckMessage, yourplayerid_)>(
          reinterpret_cast<char*>(&yourplayerid_),
          reinterpret_cast<char*>(&other->yourplayerid_));
}

std::string InitAckMessage::GetTypeName() const {
  return "InitAckMessage";
}


// ===================================================================

class AvatarRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AvatarRequestMessage>()._has_bits_);
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatarhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AvatarRequestMessage::AvatarRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AvatarRequestMessage)
}
AvatarRequestMessage::AvatarRequestMessage(const AvatarRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  avatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatarhash()) {
    avatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatarhash(), 
      GetArenaForAllocation());
  }
  requestid_ = from.requestid_;
  // @@protoc_insertion_point(copy_constructor:AvatarRequestMessage)
}

inline void AvatarRequestMessage::SharedCtor() {
avatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requestid_ = 0u;
}

AvatarRequestMessage::~AvatarRequestMessage() {
  // @@protoc_insertion_point(destructor:AvatarRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvatarRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  avatarhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AvatarRequestMessage::ArenaDtor(void* object) {
  AvatarRequestMessage* _this = reinterpret_cast< AvatarRequestMessage* >(object);
  (void)_this;
}
void AvatarRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvatarRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvatarRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AvatarRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    avatarhash_.ClearNonDefaultToEmpty();
  }
  requestid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvatarRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 requestId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_requestid(&has_bits);
          requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes avatarHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatarhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvatarRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvatarRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 requestId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_requestid(), target);
  }

  // required bytes avatarHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_avatarhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvatarRequestMessage)
  return target;
}

size_t AvatarRequestMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AvatarRequestMessage)
  size_t total_size = 0;

  if (_internal_has_avatarhash()) {
    // required bytes avatarHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_avatarhash());
  }

  if (_internal_has_requestid()) {
    // required uint32 requestId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());
  }

  return total_size;
}
size_t AvatarRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvatarRequestMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes avatarHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_avatarhash());

    // required uint32 requestId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvatarRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvatarRequestMessage*>(
      &from));
}

void AvatarRequestMessage::MergeFrom(const AvatarRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvatarRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_avatarhash(from._internal_avatarhash());
    }
    if (cached_has_bits & 0x00000002u) {
      requestid_ = from.requestid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvatarRequestMessage::CopyFrom(const AvatarRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvatarRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvatarRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AvatarRequestMessage::InternalSwap(AvatarRequestMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatarhash_, lhs_arena,
      &other->avatarhash_, rhs_arena
  );
  swap(requestid_, other->requestid_);
}

std::string AvatarRequestMessage::GetTypeName() const {
  return "AvatarRequestMessage";
}


// ===================================================================

class AvatarHeaderMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AvatarHeaderMessage>()._has_bits_);
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avatartype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_avatarsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AvatarHeaderMessage::AvatarHeaderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AvatarHeaderMessage)
}
AvatarHeaderMessage::AvatarHeaderMessage(const AvatarHeaderMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&requestid_, &from.requestid_,
    static_cast<size_t>(reinterpret_cast<char*>(&avatartype_) -
    reinterpret_cast<char*>(&requestid_)) + sizeof(avatartype_));
  // @@protoc_insertion_point(copy_constructor:AvatarHeaderMessage)
}

inline void AvatarHeaderMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&requestid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&avatarsize_) -
    reinterpret_cast<char*>(&requestid_)) + sizeof(avatarsize_));
avatartype_ = 1;
}

AvatarHeaderMessage::~AvatarHeaderMessage() {
  // @@protoc_insertion_point(destructor:AvatarHeaderMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvatarHeaderMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AvatarHeaderMessage::ArenaDtor(void* object) {
  AvatarHeaderMessage* _this = reinterpret_cast< AvatarHeaderMessage* >(object);
  (void)_this;
}
void AvatarHeaderMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvatarHeaderMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvatarHeaderMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AvatarHeaderMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&requestid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&avatarsize_) -
        reinterpret_cast<char*>(&requestid_)) + sizeof(avatarsize_));
    avatartype_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvatarHeaderMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 requestId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_requestid(&has_bits);
          requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetAvatarType avatarType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetAvatarType_IsValid(val))) {
            _internal_set_avatartype(static_cast<::NetAvatarType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 avatarSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_avatarsize(&has_bits);
          avatarsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvatarHeaderMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvatarHeaderMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 requestId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_requestid(), target);
  }

  // required .NetAvatarType avatarType = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_avatartype(), target);
  }

  // required uint32 avatarSize = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_avatarsize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvatarHeaderMessage)
  return target;
}

size_t AvatarHeaderMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AvatarHeaderMessage)
  size_t total_size = 0;

  if (_internal_has_requestid()) {
    // required uint32 requestId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());
  }

  if (_internal_has_avatarsize()) {
    // required uint32 avatarSize = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_avatarsize());
  }

  if (_internal_has_avatartype()) {
    // required .NetAvatarType avatarType = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_avatartype());
  }

  return total_size;
}
size_t AvatarHeaderMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvatarHeaderMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 requestId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());

    // required uint32 avatarSize = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_avatarsize());

    // required .NetAvatarType avatarType = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_avatartype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvatarHeaderMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvatarHeaderMessage*>(
      &from));
}

void AvatarHeaderMessage::MergeFrom(const AvatarHeaderMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvatarHeaderMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      requestid_ = from.requestid_;
    }
    if (cached_has_bits & 0x00000002u) {
      avatarsize_ = from.avatarsize_;
    }
    if (cached_has_bits & 0x00000004u) {
      avatartype_ = from.avatartype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvatarHeaderMessage::CopyFrom(const AvatarHeaderMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvatarHeaderMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvatarHeaderMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AvatarHeaderMessage::InternalSwap(AvatarHeaderMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvatarHeaderMessage, avatarsize_)
      + sizeof(AvatarHeaderMessage::avatarsize_)
      - PROTOBUF_FIELD_OFFSET(AvatarHeaderMessage, requestid_)>(
          reinterpret_cast<char*>(&requestid_),
          reinterpret_cast<char*>(&other->requestid_));
  swap(avatartype_, other->avatartype_);
}

std::string AvatarHeaderMessage::GetTypeName() const {
  return "AvatarHeaderMessage";
}


// ===================================================================

class AvatarDataMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AvatarDataMessage>()._has_bits_);
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatarblock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AvatarDataMessage::AvatarDataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AvatarDataMessage)
}
AvatarDataMessage::AvatarDataMessage(const AvatarDataMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  avatarblock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatarblock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatarblock()) {
    avatarblock_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatarblock(), 
      GetArenaForAllocation());
  }
  requestid_ = from.requestid_;
  // @@protoc_insertion_point(copy_constructor:AvatarDataMessage)
}

inline void AvatarDataMessage::SharedCtor() {
avatarblock_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatarblock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requestid_ = 0u;
}

AvatarDataMessage::~AvatarDataMessage() {
  // @@protoc_insertion_point(destructor:AvatarDataMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvatarDataMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  avatarblock_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AvatarDataMessage::ArenaDtor(void* object) {
  AvatarDataMessage* _this = reinterpret_cast< AvatarDataMessage* >(object);
  (void)_this;
}
void AvatarDataMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvatarDataMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvatarDataMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AvatarDataMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    avatarblock_.ClearNonDefaultToEmpty();
  }
  requestid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvatarDataMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 requestId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_requestid(&has_bits);
          requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes avatarBlock = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatarblock();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvatarDataMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvatarDataMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 requestId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_requestid(), target);
  }

  // required bytes avatarBlock = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_avatarblock(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvatarDataMessage)
  return target;
}

size_t AvatarDataMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AvatarDataMessage)
  size_t total_size = 0;

  if (_internal_has_avatarblock()) {
    // required bytes avatarBlock = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_avatarblock());
  }

  if (_internal_has_requestid()) {
    // required uint32 requestId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());
  }

  return total_size;
}
size_t AvatarDataMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvatarDataMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes avatarBlock = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_avatarblock());

    // required uint32 requestId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvatarDataMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvatarDataMessage*>(
      &from));
}

void AvatarDataMessage::MergeFrom(const AvatarDataMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvatarDataMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_avatarblock(from._internal_avatarblock());
    }
    if (cached_has_bits & 0x00000002u) {
      requestid_ = from.requestid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvatarDataMessage::CopyFrom(const AvatarDataMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvatarDataMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvatarDataMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AvatarDataMessage::InternalSwap(AvatarDataMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatarblock_, lhs_arena,
      &other->avatarblock_, rhs_arena
  );
  swap(requestid_, other->requestid_);
}

std::string AvatarDataMessage::GetTypeName() const {
  return "AvatarDataMessage";
}


// ===================================================================

class AvatarEndMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AvatarEndMessage>()._has_bits_);
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AvatarEndMessage::AvatarEndMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AvatarEndMessage)
}
AvatarEndMessage::AvatarEndMessage(const AvatarEndMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  requestid_ = from.requestid_;
  // @@protoc_insertion_point(copy_constructor:AvatarEndMessage)
}

inline void AvatarEndMessage::SharedCtor() {
requestid_ = 0u;
}

AvatarEndMessage::~AvatarEndMessage() {
  // @@protoc_insertion_point(destructor:AvatarEndMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvatarEndMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AvatarEndMessage::ArenaDtor(void* object) {
  AvatarEndMessage* _this = reinterpret_cast< AvatarEndMessage* >(object);
  (void)_this;
}
void AvatarEndMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvatarEndMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvatarEndMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AvatarEndMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  requestid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvatarEndMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 requestId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_requestid(&has_bits);
          requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvatarEndMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvatarEndMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 requestId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_requestid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvatarEndMessage)
  return target;
}

size_t AvatarEndMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvatarEndMessage)
  size_t total_size = 0;

  // required uint32 requestId = 1;
  if (_internal_has_requestid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvatarEndMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvatarEndMessage*>(
      &from));
}

void AvatarEndMessage::MergeFrom(const AvatarEndMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvatarEndMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_requestid()) {
    _internal_set_requestid(from._internal_requestid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvatarEndMessage::CopyFrom(const AvatarEndMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvatarEndMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvatarEndMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AvatarEndMessage::InternalSwap(AvatarEndMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(requestid_, other->requestid_);
}

std::string AvatarEndMessage::GetTypeName() const {
  return "AvatarEndMessage";
}


// ===================================================================

class UnknownAvatarMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<UnknownAvatarMessage>()._has_bits_);
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

UnknownAvatarMessage::UnknownAvatarMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:UnknownAvatarMessage)
}
UnknownAvatarMessage::UnknownAvatarMessage(const UnknownAvatarMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  requestid_ = from.requestid_;
  // @@protoc_insertion_point(copy_constructor:UnknownAvatarMessage)
}

inline void UnknownAvatarMessage::SharedCtor() {
requestid_ = 0u;
}

UnknownAvatarMessage::~UnknownAvatarMessage() {
  // @@protoc_insertion_point(destructor:UnknownAvatarMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UnknownAvatarMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UnknownAvatarMessage::ArenaDtor(void* object) {
  UnknownAvatarMessage* _this = reinterpret_cast< UnknownAvatarMessage* >(object);
  (void)_this;
}
void UnknownAvatarMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UnknownAvatarMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UnknownAvatarMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:UnknownAvatarMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  requestid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UnknownAvatarMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 requestId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_requestid(&has_bits);
          requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnknownAvatarMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UnknownAvatarMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 requestId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_requestid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UnknownAvatarMessage)
  return target;
}

size_t UnknownAvatarMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UnknownAvatarMessage)
  size_t total_size = 0;

  // required uint32 requestId = 1;
  if (_internal_has_requestid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_requestid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnknownAvatarMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UnknownAvatarMessage*>(
      &from));
}

void UnknownAvatarMessage::MergeFrom(const UnknownAvatarMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UnknownAvatarMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_requestid()) {
    _internal_set_requestid(from._internal_requestid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnknownAvatarMessage::CopyFrom(const UnknownAvatarMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UnknownAvatarMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnknownAvatarMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UnknownAvatarMessage::InternalSwap(UnknownAvatarMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(requestid_, other->requestid_);
}

std::string UnknownAvatarMessage::GetTypeName() const {
  return "UnknownAvatarMessage";
}


// ===================================================================

class PlayerListMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerListMessage>()._has_bits_);
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerlistnotification(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PlayerListMessage::PlayerListMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerListMessage)
}
PlayerListMessage::PlayerListMessage(const PlayerListMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&playerid_, &from.playerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerlistnotification_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(playerlistnotification_));
  // @@protoc_insertion_point(copy_constructor:PlayerListMessage)
}

inline void PlayerListMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&playerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerlistnotification_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(playerlistnotification_));
}

PlayerListMessage::~PlayerListMessage() {
  // @@protoc_insertion_point(destructor:PlayerListMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerListMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerListMessage::ArenaDtor(void* object) {
  PlayerListMessage* _this = reinterpret_cast< PlayerListMessage* >(object);
  (void)_this;
}
void PlayerListMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerListMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerListMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerListMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&playerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerlistnotification_) -
        reinterpret_cast<char*>(&playerid_)) + sizeof(playerlistnotification_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerListMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PlayerListMessage_PlayerListNotification_IsValid(val))) {
            _internal_set_playerlistnotification(static_cast<::PlayerListMessage_PlayerListNotification>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerListMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerListMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 playerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_playerid(), target);
  }

  // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_playerlistnotification(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerListMessage)
  return target;
}

size_t PlayerListMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayerListMessage)
  size_t total_size = 0;

  if (_internal_has_playerid()) {
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_playerlistnotification()) {
    // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playerlistnotification());
  }

  return total_size;
}
size_t PlayerListMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerListMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playerlistnotification());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerListMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerListMessage*>(
      &from));
}

void PlayerListMessage::MergeFrom(const PlayerListMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerListMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerlistnotification_ = from.playerlistnotification_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerListMessage::CopyFrom(const PlayerListMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerListMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerListMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PlayerListMessage::InternalSwap(PlayerListMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerListMessage, playerlistnotification_)
      + sizeof(PlayerListMessage::playerlistnotification_)
      - PROTOBUF_FIELD_OFFSET(PlayerListMessage, playerid_)>(
          reinterpret_cast<char*>(&playerid_),
          reinterpret_cast<char*>(&other->playerid_));
}

std::string PlayerListMessage::GetTypeName() const {
  return "PlayerListMessage";
}


// ===================================================================

class GameListNewMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListNewMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gamemode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_isprivate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_adminplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::NetGameInfo& gameinfo(const GameListNewMessage* msg);
  static void set_has_gameinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::NetGameInfo&
GameListNewMessage::_Internal::gameinfo(const GameListNewMessage* msg) {
  return *msg->gameinfo_;
}
GameListNewMessage::GameListNewMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  playerids_(arena),
  spectatorids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListNewMessage)
}
GameListNewMessage::GameListNewMessage(const GameListNewMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      playerids_(from.playerids_),
      spectatorids_(from.spectatorids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gameinfo()) {
    gameinfo_ = new ::NetGameInfo(*from.gameinfo_);
  } else {
    gameinfo_ = nullptr;
  }
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&gamemode_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gamemode_));
  // @@protoc_insertion_point(copy_constructor:GameListNewMessage)
}

inline void GameListNewMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&adminplayerid_) -
    reinterpret_cast<char*>(&gameinfo_)) + sizeof(adminplayerid_));
gamemode_ = 1;
}

GameListNewMessage::~GameListNewMessage() {
  // @@protoc_insertion_point(destructor:GameListNewMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListNewMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete gameinfo_;
}

void GameListNewMessage::ArenaDtor(void* object) {
  GameListNewMessage* _this = reinterpret_cast< GameListNewMessage* >(object);
  (void)_this;
}
void GameListNewMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListNewMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListNewMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListNewMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  playerids_.Clear();
  spectatorids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(gameinfo_ != nullptr);
    gameinfo_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&adminplayerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(adminplayerid_));
    gamemode_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListNewMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameMode gameMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameMode_IsValid(val))) {
            _internal_set_gamemode(static_cast<::NetGameMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bool isPrivate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_isprivate(&has_bits);
          isprivate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 playerIds = 4 [packed = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_playerids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_playerids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 adminPlayerId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_adminplayerid(&has_bits);
          adminplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameInfo gameInfo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 spectatorIds = 7 [packed = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_spectatorids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_spectatorids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListNewMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListNewMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .NetGameMode gameMode = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_gamemode(), target);
  }

  // required bool isPrivate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isprivate(), target);
  }

  // repeated uint32 playerIds = 4 [packed = true];
  {
    int byte_size = _playerids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          4, _internal_playerids(), byte_size, target);
    }
  }

  // required uint32 adminPlayerId = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_adminplayerid(), target);
  }

  // required .NetGameInfo gameInfo = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::gameinfo(this), target, stream);
  }

  // repeated uint32 spectatorIds = 7 [packed = true];
  {
    int byte_size = _spectatorids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          7, _internal_spectatorids(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListNewMessage)
  return target;
}

size_t GameListNewMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListNewMessage)
  size_t total_size = 0;

  if (_internal_has_gameinfo()) {
    // required .NetGameInfo gameInfo = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gameinfo_);
  }

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_isprivate()) {
    // required bool isPrivate = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_adminplayerid()) {
    // required uint32 adminPlayerId = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_adminplayerid());
  }

  if (_internal_has_gamemode()) {
    // required .NetGameMode gameMode = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamemode());
  }

  return total_size;
}
size_t GameListNewMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListNewMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .NetGameInfo gameInfo = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gameinfo_);

    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required bool isPrivate = 3;
    total_size += 1 + 1;

    // required uint32 adminPlayerId = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_adminplayerid());

    // required .NetGameMode gameMode = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamemode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 playerIds = 4 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->playerids_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _playerids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 spectatorIds = 7 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->spectatorids_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _spectatorids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListNewMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListNewMessage*>(
      &from));
}

void GameListNewMessage::MergeFrom(const GameListNewMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListNewMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  playerids_.MergeFrom(from.playerids_);
  spectatorids_.MergeFrom(from.spectatorids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_gameinfo()->::NetGameInfo::MergeFrom(from._internal_gameinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000004u) {
      isprivate_ = from.isprivate_;
    }
    if (cached_has_bits & 0x00000008u) {
      adminplayerid_ = from.adminplayerid_;
    }
    if (cached_has_bits & 0x00000010u) {
      gamemode_ = from.gamemode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListNewMessage::CopyFrom(const GameListNewMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListNewMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListNewMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_gameinfo()) {
    if (!gameinfo_->IsInitialized()) return false;
  }
  return true;
}

void GameListNewMessage::InternalSwap(GameListNewMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  playerids_.InternalSwap(&other->playerids_);
  spectatorids_.InternalSwap(&other->spectatorids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameListNewMessage, adminplayerid_)
      + sizeof(GameListNewMessage::adminplayerid_)
      - PROTOBUF_FIELD_OFFSET(GameListNewMessage, gameinfo_)>(
          reinterpret_cast<char*>(&gameinfo_),
          reinterpret_cast<char*>(&other->gameinfo_));
  swap(gamemode_, other->gamemode_);
}

std::string GameListNewMessage::GetTypeName() const {
  return "GameListNewMessage";
}


// ===================================================================

class GameListUpdateMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListUpdateMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gamemode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameListUpdateMessage::GameListUpdateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListUpdateMessage)
}
GameListUpdateMessage::GameListUpdateMessage(const GameListUpdateMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&gamemode_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gamemode_));
  // @@protoc_insertion_point(copy_constructor:GameListUpdateMessage)
}

inline void GameListUpdateMessage::SharedCtor() {
gameid_ = 0u;
gamemode_ = 1;
}

GameListUpdateMessage::~GameListUpdateMessage() {
  // @@protoc_insertion_point(destructor:GameListUpdateMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListUpdateMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameListUpdateMessage::ArenaDtor(void* object) {
  GameListUpdateMessage* _this = reinterpret_cast< GameListUpdateMessage* >(object);
  (void)_this;
}
void GameListUpdateMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListUpdateMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListUpdateMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListUpdateMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    gameid_ = 0u;
    gamemode_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListUpdateMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameMode gameMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameMode_IsValid(val))) {
            _internal_set_gamemode(static_cast<::NetGameMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListUpdateMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListUpdateMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .NetGameMode gameMode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_gamemode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListUpdateMessage)
  return target;
}

size_t GameListUpdateMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListUpdateMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_gamemode()) {
    // required .NetGameMode gameMode = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamemode());
  }

  return total_size;
}
size_t GameListUpdateMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListUpdateMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required .NetGameMode gameMode = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamemode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListUpdateMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListUpdateMessage*>(
      &from));
}

void GameListUpdateMessage::MergeFrom(const GameListUpdateMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListUpdateMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      gamemode_ = from.gamemode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListUpdateMessage::CopyFrom(const GameListUpdateMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListUpdateMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListUpdateMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameListUpdateMessage::InternalSwap(GameListUpdateMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gameid_, other->gameid_);
  swap(gamemode_, other->gamemode_);
}

std::string GameListUpdateMessage::GetTypeName() const {
  return "GameListUpdateMessage";
}


// ===================================================================

class GameListPlayerJoinedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListPlayerJoinedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameListPlayerJoinedMessage::GameListPlayerJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListPlayerJoinedMessage)
}
GameListPlayerJoinedMessage::GameListPlayerJoinedMessage(const GameListPlayerJoinedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:GameListPlayerJoinedMessage)
}

inline void GameListPlayerJoinedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

GameListPlayerJoinedMessage::~GameListPlayerJoinedMessage() {
  // @@protoc_insertion_point(destructor:GameListPlayerJoinedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListPlayerJoinedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameListPlayerJoinedMessage::ArenaDtor(void* object) {
  GameListPlayerJoinedMessage* _this = reinterpret_cast< GameListPlayerJoinedMessage* >(object);
  (void)_this;
}
void GameListPlayerJoinedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListPlayerJoinedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListPlayerJoinedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListPlayerJoinedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListPlayerJoinedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListPlayerJoinedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListPlayerJoinedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListPlayerJoinedMessage)
  return target;
}

size_t GameListPlayerJoinedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListPlayerJoinedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t GameListPlayerJoinedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListPlayerJoinedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListPlayerJoinedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListPlayerJoinedMessage*>(
      &from));
}

void GameListPlayerJoinedMessage::MergeFrom(const GameListPlayerJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListPlayerJoinedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListPlayerJoinedMessage::CopyFrom(const GameListPlayerJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListPlayerJoinedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListPlayerJoinedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameListPlayerJoinedMessage::InternalSwap(GameListPlayerJoinedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameListPlayerJoinedMessage, playerid_)
      + sizeof(GameListPlayerJoinedMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(GameListPlayerJoinedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameListPlayerJoinedMessage::GetTypeName() const {
  return "GameListPlayerJoinedMessage";
}


// ===================================================================

class GameListPlayerLeftMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListPlayerLeftMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameListPlayerLeftMessage::GameListPlayerLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListPlayerLeftMessage)
}
GameListPlayerLeftMessage::GameListPlayerLeftMessage(const GameListPlayerLeftMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:GameListPlayerLeftMessage)
}

inline void GameListPlayerLeftMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

GameListPlayerLeftMessage::~GameListPlayerLeftMessage() {
  // @@protoc_insertion_point(destructor:GameListPlayerLeftMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListPlayerLeftMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameListPlayerLeftMessage::ArenaDtor(void* object) {
  GameListPlayerLeftMessage* _this = reinterpret_cast< GameListPlayerLeftMessage* >(object);
  (void)_this;
}
void GameListPlayerLeftMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListPlayerLeftMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListPlayerLeftMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListPlayerLeftMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListPlayerLeftMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListPlayerLeftMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListPlayerLeftMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListPlayerLeftMessage)
  return target;
}

size_t GameListPlayerLeftMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListPlayerLeftMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t GameListPlayerLeftMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListPlayerLeftMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListPlayerLeftMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListPlayerLeftMessage*>(
      &from));
}

void GameListPlayerLeftMessage::MergeFrom(const GameListPlayerLeftMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListPlayerLeftMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListPlayerLeftMessage::CopyFrom(const GameListPlayerLeftMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListPlayerLeftMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListPlayerLeftMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameListPlayerLeftMessage::InternalSwap(GameListPlayerLeftMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameListPlayerLeftMessage, playerid_)
      + sizeof(GameListPlayerLeftMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(GameListPlayerLeftMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameListPlayerLeftMessage::GetTypeName() const {
  return "GameListPlayerLeftMessage";
}


// ===================================================================

class GameListSpectatorJoinedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListSpectatorJoinedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameListSpectatorJoinedMessage::GameListSpectatorJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListSpectatorJoinedMessage)
}
GameListSpectatorJoinedMessage::GameListSpectatorJoinedMessage(const GameListSpectatorJoinedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:GameListSpectatorJoinedMessage)
}

inline void GameListSpectatorJoinedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

GameListSpectatorJoinedMessage::~GameListSpectatorJoinedMessage() {
  // @@protoc_insertion_point(destructor:GameListSpectatorJoinedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListSpectatorJoinedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameListSpectatorJoinedMessage::ArenaDtor(void* object) {
  GameListSpectatorJoinedMessage* _this = reinterpret_cast< GameListSpectatorJoinedMessage* >(object);
  (void)_this;
}
void GameListSpectatorJoinedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListSpectatorJoinedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListSpectatorJoinedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListSpectatorJoinedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListSpectatorJoinedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListSpectatorJoinedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListSpectatorJoinedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListSpectatorJoinedMessage)
  return target;
}

size_t GameListSpectatorJoinedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListSpectatorJoinedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t GameListSpectatorJoinedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListSpectatorJoinedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListSpectatorJoinedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListSpectatorJoinedMessage*>(
      &from));
}

void GameListSpectatorJoinedMessage::MergeFrom(const GameListSpectatorJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListSpectatorJoinedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListSpectatorJoinedMessage::CopyFrom(const GameListSpectatorJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListSpectatorJoinedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListSpectatorJoinedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameListSpectatorJoinedMessage::InternalSwap(GameListSpectatorJoinedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameListSpectatorJoinedMessage, playerid_)
      + sizeof(GameListSpectatorJoinedMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(GameListSpectatorJoinedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameListSpectatorJoinedMessage::GetTypeName() const {
  return "GameListSpectatorJoinedMessage";
}


// ===================================================================

class GameListSpectatorLeftMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListSpectatorLeftMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameListSpectatorLeftMessage::GameListSpectatorLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListSpectatorLeftMessage)
}
GameListSpectatorLeftMessage::GameListSpectatorLeftMessage(const GameListSpectatorLeftMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:GameListSpectatorLeftMessage)
}

inline void GameListSpectatorLeftMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

GameListSpectatorLeftMessage::~GameListSpectatorLeftMessage() {
  // @@protoc_insertion_point(destructor:GameListSpectatorLeftMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListSpectatorLeftMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameListSpectatorLeftMessage::ArenaDtor(void* object) {
  GameListSpectatorLeftMessage* _this = reinterpret_cast< GameListSpectatorLeftMessage* >(object);
  (void)_this;
}
void GameListSpectatorLeftMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListSpectatorLeftMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListSpectatorLeftMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListSpectatorLeftMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListSpectatorLeftMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListSpectatorLeftMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListSpectatorLeftMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListSpectatorLeftMessage)
  return target;
}

size_t GameListSpectatorLeftMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListSpectatorLeftMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t GameListSpectatorLeftMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListSpectatorLeftMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListSpectatorLeftMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListSpectatorLeftMessage*>(
      &from));
}

void GameListSpectatorLeftMessage::MergeFrom(const GameListSpectatorLeftMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListSpectatorLeftMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListSpectatorLeftMessage::CopyFrom(const GameListSpectatorLeftMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListSpectatorLeftMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListSpectatorLeftMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameListSpectatorLeftMessage::InternalSwap(GameListSpectatorLeftMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameListSpectatorLeftMessage, playerid_)
      + sizeof(GameListSpectatorLeftMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(GameListSpectatorLeftMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameListSpectatorLeftMessage::GetTypeName() const {
  return "GameListSpectatorLeftMessage";
}


// ===================================================================

class GameListAdminChangedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameListAdminChangedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newadminplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameListAdminChangedMessage::GameListAdminChangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameListAdminChangedMessage)
}
GameListAdminChangedMessage::GameListAdminChangedMessage(const GameListAdminChangedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&newadminplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(newadminplayerid_));
  // @@protoc_insertion_point(copy_constructor:GameListAdminChangedMessage)
}

inline void GameListAdminChangedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&newadminplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(newadminplayerid_));
}

GameListAdminChangedMessage::~GameListAdminChangedMessage() {
  // @@protoc_insertion_point(destructor:GameListAdminChangedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameListAdminChangedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameListAdminChangedMessage::ArenaDtor(void* object) {
  GameListAdminChangedMessage* _this = reinterpret_cast< GameListAdminChangedMessage* >(object);
  (void)_this;
}
void GameListAdminChangedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameListAdminChangedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameListAdminChangedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameListAdminChangedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&newadminplayerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(newadminplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameListAdminChangedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 newAdminPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_newadminplayerid(&has_bits);
          newadminplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameListAdminChangedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameListAdminChangedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 newAdminPlayerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_newadminplayerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameListAdminChangedMessage)
  return target;
}

size_t GameListAdminChangedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameListAdminChangedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_newadminplayerid()) {
    // required uint32 newAdminPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_newadminplayerid());
  }

  return total_size;
}
size_t GameListAdminChangedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameListAdminChangedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 newAdminPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_newadminplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameListAdminChangedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameListAdminChangedMessage*>(
      &from));
}

void GameListAdminChangedMessage::MergeFrom(const GameListAdminChangedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameListAdminChangedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      newadminplayerid_ = from.newadminplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameListAdminChangedMessage::CopyFrom(const GameListAdminChangedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameListAdminChangedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameListAdminChangedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameListAdminChangedMessage::InternalSwap(GameListAdminChangedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameListAdminChangedMessage, newadminplayerid_)
      + sizeof(GameListAdminChangedMessage::newadminplayerid_)
      - PROTOBUF_FIELD_OFFSET(GameListAdminChangedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameListAdminChangedMessage::GetTypeName() const {
  return "GameListAdminChangedMessage";
}


// ===================================================================

class PlayerInfoRequestMessage::_Internal {
 public:
};

PlayerInfoRequestMessage::PlayerInfoRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  playerid_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerInfoRequestMessage)
}
PlayerInfoRequestMessage::PlayerInfoRequestMessage(const PlayerInfoRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      playerid_(from.playerid_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PlayerInfoRequestMessage)
}

inline void PlayerInfoRequestMessage::SharedCtor() {
}

PlayerInfoRequestMessage::~PlayerInfoRequestMessage() {
  // @@protoc_insertion_point(destructor:PlayerInfoRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerInfoRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerInfoRequestMessage::ArenaDtor(void* object) {
  PlayerInfoRequestMessage* _this = reinterpret_cast< PlayerInfoRequestMessage* >(object);
  (void)_this;
}
void PlayerInfoRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerInfoRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerInfoRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerInfoRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  playerid_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerInfoRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 playerId = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_playerid(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_playerid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerInfoRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerInfoRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 playerId = 1 [packed = true];
  {
    int byte_size = _playerid_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_playerid(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerInfoRequestMessage)
  return target;
}

size_t PlayerInfoRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerInfoRequestMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 playerId = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->playerid_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _playerid_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerInfoRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerInfoRequestMessage*>(
      &from));
}

void PlayerInfoRequestMessage::MergeFrom(const PlayerInfoRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerInfoRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  playerid_.MergeFrom(from.playerid_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerInfoRequestMessage::CopyFrom(const PlayerInfoRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerInfoRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfoRequestMessage::IsInitialized() const {
  return true;
}

void PlayerInfoRequestMessage::InternalSwap(PlayerInfoRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  playerid_.InternalSwap(&other->playerid_);
}

std::string PlayerInfoRequestMessage::GetTypeName() const {
  return "PlayerInfoRequestMessage";
}


// ===================================================================

class PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerInfoReplyMessage_PlayerInfoData_AvatarData>()._has_bits_);
  static void set_has_avatartype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatarhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PlayerInfoReplyMessage_PlayerInfoData_AvatarData::PlayerInfoReplyMessage_PlayerInfoData_AvatarData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
}
PlayerInfoReplyMessage_PlayerInfoData_AvatarData::PlayerInfoReplyMessage_PlayerInfoData_AvatarData(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  avatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatarhash()) {
    avatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatarhash(), 
      GetArenaForAllocation());
  }
  avatartype_ = from.avatartype_;
  // @@protoc_insertion_point(copy_constructor:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
}

inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::SharedCtor() {
avatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
avatartype_ = 1;
}

PlayerInfoReplyMessage_PlayerInfoData_AvatarData::~PlayerInfoReplyMessage_PlayerInfoData_AvatarData() {
  // @@protoc_insertion_point(destructor:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  avatarhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::ArenaDtor(void* object) {
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData* _this = reinterpret_cast< PlayerInfoReplyMessage_PlayerInfoData_AvatarData* >(object);
  (void)_this;
}
void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      avatarhash_.ClearNonDefaultToEmpty();
    }
    avatartype_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .NetAvatarType avatarType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetAvatarType_IsValid(val))) {
            _internal_set_avatartype(static_cast<::NetAvatarType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes avatarHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatarhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .NetAvatarType avatarType = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_avatartype(), target);
  }

  // required bytes avatarHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_avatarhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  return target;
}

size_t PlayerInfoReplyMessage_PlayerInfoData_AvatarData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  size_t total_size = 0;

  if (_internal_has_avatarhash()) {
    // required bytes avatarHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_avatarhash());
  }

  if (_internal_has_avatartype()) {
    // required .NetAvatarType avatarType = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_avatartype());
  }

  return total_size;
}
size_t PlayerInfoReplyMessage_PlayerInfoData_AvatarData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes avatarHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_avatarhash());

    // required .NetAvatarType avatarType = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_avatartype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerInfoReplyMessage_PlayerInfoData_AvatarData*>(
      &from));
}

void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_avatarhash(from._internal_avatarhash());
    }
    if (cached_has_bits & 0x00000002u) {
      avatartype_ = from.avatartype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::InternalSwap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatarhash_, lhs_arena,
      &other->avatarhash_, rhs_arena
  );
  swap(avatartype_, other->avatartype_);
}

std::string PlayerInfoReplyMessage_PlayerInfoData_AvatarData::GetTypeName() const {
  return "PlayerInfoReplyMessage.PlayerInfoData.AvatarData";
}


// ===================================================================

class PlayerInfoReplyMessage_PlayerInfoData::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerInfoReplyMessage_PlayerInfoData>()._has_bits_);
  static void set_has_playername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ishuman(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_playerrights(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_countrycode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& avatardata(const PlayerInfoReplyMessage_PlayerInfoData* msg);
  static void set_has_avatardata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000019) ^ 0x00000019) != 0;
  }
};

const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData&
PlayerInfoReplyMessage_PlayerInfoData::_Internal::avatardata(const PlayerInfoReplyMessage_PlayerInfoData* msg) {
  return *msg->avatardata_;
}
PlayerInfoReplyMessage_PlayerInfoData::PlayerInfoReplyMessage_PlayerInfoData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerInfoReplyMessage.PlayerInfoData)
}
PlayerInfoReplyMessage_PlayerInfoData::PlayerInfoReplyMessage_PlayerInfoData(const PlayerInfoReplyMessage_PlayerInfoData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  playername_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    playername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_playername()) {
    playername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_playername(), 
      GetArenaForAllocation());
  }
  countrycode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    countrycode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_countrycode()) {
    countrycode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_countrycode(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_avatardata()) {
    avatardata_ = new ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData(*from.avatardata_);
  } else {
    avatardata_ = nullptr;
  }
  ::memcpy(&ishuman_, &from.ishuman_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerrights_) -
    reinterpret_cast<char*>(&ishuman_)) + sizeof(playerrights_));
  // @@protoc_insertion_point(copy_constructor:PlayerInfoReplyMessage.PlayerInfoData)
}

inline void PlayerInfoReplyMessage_PlayerInfoData::SharedCtor() {
playername_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  playername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
countrycode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  countrycode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&avatardata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ishuman_) -
    reinterpret_cast<char*>(&avatardata_)) + sizeof(ishuman_));
playerrights_ = 1;
}

PlayerInfoReplyMessage_PlayerInfoData::~PlayerInfoReplyMessage_PlayerInfoData() {
  // @@protoc_insertion_point(destructor:PlayerInfoReplyMessage.PlayerInfoData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerInfoReplyMessage_PlayerInfoData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  playername_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  countrycode_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete avatardata_;
}

void PlayerInfoReplyMessage_PlayerInfoData::ArenaDtor(void* object) {
  PlayerInfoReplyMessage_PlayerInfoData* _this = reinterpret_cast< PlayerInfoReplyMessage_PlayerInfoData* >(object);
  (void)_this;
}
void PlayerInfoReplyMessage_PlayerInfoData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerInfoReplyMessage_PlayerInfoData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerInfoReplyMessage_PlayerInfoData::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerInfoReplyMessage.PlayerInfoData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      playername_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      countrycode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(avatardata_ != nullptr);
      avatardata_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ishuman_ = false;
    playerrights_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerInfoReplyMessage_PlayerInfoData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string playerName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_playername();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool isHuman = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ishuman(&has_bits);
          ishuman_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetPlayerInfoRights playerRights = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetPlayerInfoRights_IsValid(val))) {
            _internal_set_playerrights(static_cast<::NetPlayerInfoRights>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string countryCode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_countrycode();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_avatardata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerInfoReplyMessage_PlayerInfoData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerInfoReplyMessage.PlayerInfoData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string playerName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_playername(), target);
  }

  // required bool isHuman = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_ishuman(), target);
  }

  // required .NetPlayerInfoRights playerRights = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_playerrights(), target);
  }

  // optional string countryCode = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_countrycode(), target);
  }

  // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::avatardata(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerInfoReplyMessage.PlayerInfoData)
  return target;
}

size_t PlayerInfoReplyMessage_PlayerInfoData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayerInfoReplyMessage.PlayerInfoData)
  size_t total_size = 0;

  if (_internal_has_playername()) {
    // required string playerName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_playername());
  }

  if (_internal_has_ishuman()) {
    // required bool isHuman = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_playerrights()) {
    // required .NetPlayerInfoRights playerRights = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playerrights());
  }

  return total_size;
}
size_t PlayerInfoReplyMessage_PlayerInfoData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerInfoReplyMessage.PlayerInfoData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required string playerName = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_playername());

    // required bool isHuman = 2;
    total_size += 1 + 1;

    // required .NetPlayerInfoRights playerRights = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playerrights());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string countryCode = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_countrycode());
    }

    // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *avatardata_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerInfoReplyMessage_PlayerInfoData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerInfoReplyMessage_PlayerInfoData*>(
      &from));
}

void PlayerInfoReplyMessage_PlayerInfoData::MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerInfoReplyMessage.PlayerInfoData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_playername(from._internal_playername());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_countrycode(from._internal_countrycode());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_avatardata()->::PlayerInfoReplyMessage_PlayerInfoData_AvatarData::MergeFrom(from._internal_avatardata());
    }
    if (cached_has_bits & 0x00000008u) {
      ishuman_ = from.ishuman_;
    }
    if (cached_has_bits & 0x00000010u) {
      playerrights_ = from.playerrights_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerInfoReplyMessage_PlayerInfoData::CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerInfoReplyMessage.PlayerInfoData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfoReplyMessage_PlayerInfoData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_avatardata()) {
    if (!avatardata_->IsInitialized()) return false;
  }
  return true;
}

void PlayerInfoReplyMessage_PlayerInfoData::InternalSwap(PlayerInfoReplyMessage_PlayerInfoData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &playername_, lhs_arena,
      &other->playername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &countrycode_, lhs_arena,
      &other->countrycode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerInfoReplyMessage_PlayerInfoData, ishuman_)
      + sizeof(PlayerInfoReplyMessage_PlayerInfoData::ishuman_)
      - PROTOBUF_FIELD_OFFSET(PlayerInfoReplyMessage_PlayerInfoData, avatardata_)>(
          reinterpret_cast<char*>(&avatardata_),
          reinterpret_cast<char*>(&other->avatardata_));
  swap(playerrights_, other->playerrights_);
}

std::string PlayerInfoReplyMessage_PlayerInfoData::GetTypeName() const {
  return "PlayerInfoReplyMessage.PlayerInfoData";
}


// ===================================================================

class PlayerInfoReplyMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerInfoReplyMessage>()._has_bits_);
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PlayerInfoReplyMessage_PlayerInfoData& playerinfodata(const PlayerInfoReplyMessage* msg);
  static void set_has_playerinfodata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::PlayerInfoReplyMessage_PlayerInfoData&
PlayerInfoReplyMessage::_Internal::playerinfodata(const PlayerInfoReplyMessage* msg) {
  return *msg->playerinfodata_;
}
PlayerInfoReplyMessage::PlayerInfoReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerInfoReplyMessage)
}
PlayerInfoReplyMessage::PlayerInfoReplyMessage(const PlayerInfoReplyMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_playerinfodata()) {
    playerinfodata_ = new ::PlayerInfoReplyMessage_PlayerInfoData(*from.playerinfodata_);
  } else {
    playerinfodata_ = nullptr;
  }
  playerid_ = from.playerid_;
  // @@protoc_insertion_point(copy_constructor:PlayerInfoReplyMessage)
}

inline void PlayerInfoReplyMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&playerinfodata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&playerinfodata_)) + sizeof(playerid_));
}

PlayerInfoReplyMessage::~PlayerInfoReplyMessage() {
  // @@protoc_insertion_point(destructor:PlayerInfoReplyMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerInfoReplyMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete playerinfodata_;
}

void PlayerInfoReplyMessage::ArenaDtor(void* object) {
  PlayerInfoReplyMessage* _this = reinterpret_cast< PlayerInfoReplyMessage* >(object);
  (void)_this;
}
void PlayerInfoReplyMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerInfoReplyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerInfoReplyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerInfoReplyMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(playerinfodata_ != nullptr);
    playerinfodata_->Clear();
  }
  playerid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerInfoReplyMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerinfodata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerInfoReplyMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerInfoReplyMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 playerId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_playerid(), target);
  }

  // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::playerinfodata(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerInfoReplyMessage)
  return target;
}

size_t PlayerInfoReplyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerInfoReplyMessage)
  size_t total_size = 0;

  // required uint32 playerId = 1;
  if (_internal_has_playerid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *playerinfodata_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerInfoReplyMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerInfoReplyMessage*>(
      &from));
}

void PlayerInfoReplyMessage::MergeFrom(const PlayerInfoReplyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerInfoReplyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_playerinfodata()->::PlayerInfoReplyMessage_PlayerInfoData::MergeFrom(from._internal_playerinfodata());
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerInfoReplyMessage::CopyFrom(const PlayerInfoReplyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerInfoReplyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfoReplyMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_playerinfodata()) {
    if (!playerinfodata_->IsInitialized()) return false;
  }
  return true;
}

void PlayerInfoReplyMessage::InternalSwap(PlayerInfoReplyMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerInfoReplyMessage, playerid_)
      + sizeof(PlayerInfoReplyMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(PlayerInfoReplyMessage, playerinfodata_)>(
          reinterpret_cast<char*>(&playerinfodata_),
          reinterpret_cast<char*>(&other->playerinfodata_));
}

std::string PlayerInfoReplyMessage::GetTypeName() const {
  return "PlayerInfoReplyMessage";
}


// ===================================================================

class SubscriptionRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscriptionRequestMessage>()._has_bits_);
  static void set_has_subscriptionaction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SubscriptionRequestMessage::SubscriptionRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SubscriptionRequestMessage)
}
SubscriptionRequestMessage::SubscriptionRequestMessage(const SubscriptionRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  subscriptionaction_ = from.subscriptionaction_;
  // @@protoc_insertion_point(copy_constructor:SubscriptionRequestMessage)
}

inline void SubscriptionRequestMessage::SharedCtor() {
subscriptionaction_ = 1;
}

SubscriptionRequestMessage::~SubscriptionRequestMessage() {
  // @@protoc_insertion_point(destructor:SubscriptionRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SubscriptionRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SubscriptionRequestMessage::ArenaDtor(void* object) {
  SubscriptionRequestMessage* _this = reinterpret_cast< SubscriptionRequestMessage* >(object);
  (void)_this;
}
void SubscriptionRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubscriptionRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SubscriptionRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SubscriptionRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subscriptionaction_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SubscriptionRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SubscriptionRequestMessage_SubscriptionAction_IsValid(val))) {
            _internal_set_subscriptionaction(static_cast<::SubscriptionRequestMessage_SubscriptionAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubscriptionRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SubscriptionRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_subscriptionaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SubscriptionRequestMessage)
  return target;
}

size_t SubscriptionRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SubscriptionRequestMessage)
  size_t total_size = 0;

  // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
  if (_internal_has_subscriptionaction()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_subscriptionaction());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubscriptionRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SubscriptionRequestMessage*>(
      &from));
}

void SubscriptionRequestMessage::MergeFrom(const SubscriptionRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SubscriptionRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subscriptionaction()) {
    _internal_set_subscriptionaction(from._internal_subscriptionaction());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SubscriptionRequestMessage::CopyFrom(const SubscriptionRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SubscriptionRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscriptionRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SubscriptionRequestMessage::InternalSwap(SubscriptionRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(subscriptionaction_, other->subscriptionaction_);
}

std::string SubscriptionRequestMessage::GetTypeName() const {
  return "SubscriptionRequestMessage";
}


// ===================================================================

class JoinExistingGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinExistingGameMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_autoleave(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_spectateonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

JoinExistingGameMessage::JoinExistingGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:JoinExistingGameMessage)
}
JoinExistingGameMessage::JoinExistingGameMessage(const JoinExistingGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&spectateonly_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(spectateonly_));
  // @@protoc_insertion_point(copy_constructor:JoinExistingGameMessage)
}

inline void JoinExistingGameMessage::SharedCtor() {
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&spectateonly_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(spectateonly_));
}

JoinExistingGameMessage::~JoinExistingGameMessage() {
  // @@protoc_insertion_point(destructor:JoinExistingGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void JoinExistingGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void JoinExistingGameMessage::ArenaDtor(void* object) {
  JoinExistingGameMessage* _this = reinterpret_cast< JoinExistingGameMessage* >(object);
  (void)_this;
}
void JoinExistingGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinExistingGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinExistingGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:JoinExistingGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    password_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&spectateonly_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(spectateonly_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JoinExistingGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoLeave = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_autoleave(&has_bits);
          autoleave_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool spectateOnly = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_spectateonly(&has_bits);
          spectateonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinExistingGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:JoinExistingGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional bool autoLeave = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_autoleave(), target);
  }

  // optional bool spectateOnly = 4 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_spectateonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:JoinExistingGameMessage)
  return target;
}

size_t JoinExistingGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:JoinExistingGameMessage)
  size_t total_size = 0;

  // required uint32 gameId = 1;
  if (_internal_has_gameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string password = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional bool autoLeave = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool spectateOnly = 4 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JoinExistingGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const JoinExistingGameMessage*>(
      &from));
}

void JoinExistingGameMessage::MergeFrom(const JoinExistingGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:JoinExistingGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000002u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000004u) {
      autoleave_ = from.autoleave_;
    }
    if (cached_has_bits & 0x00000008u) {
      spectateonly_ = from.spectateonly_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinExistingGameMessage::CopyFrom(const JoinExistingGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:JoinExistingGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinExistingGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void JoinExistingGameMessage::InternalSwap(JoinExistingGameMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinExistingGameMessage, spectateonly_)
      + sizeof(JoinExistingGameMessage::spectateonly_)
      - PROTOBUF_FIELD_OFFSET(JoinExistingGameMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string JoinExistingGameMessage::GetTypeName() const {
  return "JoinExistingGameMessage";
}


// ===================================================================

class JoinNewGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinNewGameMessage>()._has_bits_);
  static const ::NetGameInfo& gameinfo(const JoinNewGameMessage* msg);
  static void set_has_gameinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_autoleave(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::NetGameInfo&
JoinNewGameMessage::_Internal::gameinfo(const JoinNewGameMessage* msg) {
  return *msg->gameinfo_;
}
JoinNewGameMessage::JoinNewGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:JoinNewGameMessage)
}
JoinNewGameMessage::JoinNewGameMessage(const JoinNewGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_gameinfo()) {
    gameinfo_ = new ::NetGameInfo(*from.gameinfo_);
  } else {
    gameinfo_ = nullptr;
  }
  autoleave_ = from.autoleave_;
  // @@protoc_insertion_point(copy_constructor:JoinNewGameMessage)
}

inline void JoinNewGameMessage::SharedCtor() {
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&autoleave_) -
    reinterpret_cast<char*>(&gameinfo_)) + sizeof(autoleave_));
}

JoinNewGameMessage::~JoinNewGameMessage() {
  // @@protoc_insertion_point(destructor:JoinNewGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void JoinNewGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete gameinfo_;
}

void JoinNewGameMessage::ArenaDtor(void* object) {
  JoinNewGameMessage* _this = reinterpret_cast< JoinNewGameMessage* >(object);
  (void)_this;
}
void JoinNewGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinNewGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinNewGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:JoinNewGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(gameinfo_ != nullptr);
      gameinfo_->Clear();
    }
  }
  autoleave_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JoinNewGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .NetGameInfo gameInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoLeave = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_autoleave(&has_bits);
          autoleave_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinNewGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:JoinNewGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .NetGameInfo gameInfo = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::gameinfo(this), target, stream);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional bool autoLeave = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_autoleave(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:JoinNewGameMessage)
  return target;
}

size_t JoinNewGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:JoinNewGameMessage)
  size_t total_size = 0;

  // required .NetGameInfo gameInfo = 1;
  if (_internal_has_gameinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gameinfo_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string password = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // optional bool autoLeave = 3;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JoinNewGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const JoinNewGameMessage*>(
      &from));
}

void JoinNewGameMessage::MergeFrom(const JoinNewGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:JoinNewGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_gameinfo()->::NetGameInfo::MergeFrom(from._internal_gameinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      autoleave_ = from.autoleave_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinNewGameMessage::CopyFrom(const JoinNewGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:JoinNewGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinNewGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_gameinfo()) {
    if (!gameinfo_->IsInitialized()) return false;
  }
  return true;
}

void JoinNewGameMessage::InternalSwap(JoinNewGameMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinNewGameMessage, autoleave_)
      + sizeof(JoinNewGameMessage::autoleave_)
      - PROTOBUF_FIELD_OFFSET(JoinNewGameMessage, gameinfo_)>(
          reinterpret_cast<char*>(&gameinfo_),
          reinterpret_cast<char*>(&other->gameinfo_));
}

std::string JoinNewGameMessage::GetTypeName() const {
  return "JoinNewGameMessage";
}


// ===================================================================

class RejoinExistingGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RejoinExistingGameMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_autoleave(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RejoinExistingGameMessage::RejoinExistingGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RejoinExistingGameMessage)
}
RejoinExistingGameMessage::RejoinExistingGameMessage(const RejoinExistingGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&autoleave_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(autoleave_));
  // @@protoc_insertion_point(copy_constructor:RejoinExistingGameMessage)
}

inline void RejoinExistingGameMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&autoleave_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(autoleave_));
}

RejoinExistingGameMessage::~RejoinExistingGameMessage() {
  // @@protoc_insertion_point(destructor:RejoinExistingGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RejoinExistingGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RejoinExistingGameMessage::ArenaDtor(void* object) {
  RejoinExistingGameMessage* _this = reinterpret_cast< RejoinExistingGameMessage* >(object);
  (void)_this;
}
void RejoinExistingGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RejoinExistingGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RejoinExistingGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:RejoinExistingGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&autoleave_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(autoleave_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RejoinExistingGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoLeave = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_autoleave(&has_bits);
          autoleave_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RejoinExistingGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RejoinExistingGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // optional bool autoLeave = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_autoleave(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RejoinExistingGameMessage)
  return target;
}

size_t RejoinExistingGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RejoinExistingGameMessage)
  size_t total_size = 0;

  // required uint32 gameId = 1;
  if (_internal_has_gameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool autoLeave = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RejoinExistingGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RejoinExistingGameMessage*>(
      &from));
}

void RejoinExistingGameMessage::MergeFrom(const RejoinExistingGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RejoinExistingGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      autoleave_ = from.autoleave_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RejoinExistingGameMessage::CopyFrom(const RejoinExistingGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RejoinExistingGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RejoinExistingGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RejoinExistingGameMessage::InternalSwap(RejoinExistingGameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RejoinExistingGameMessage, autoleave_)
      + sizeof(RejoinExistingGameMessage::autoleave_)
      - PROTOBUF_FIELD_OFFSET(RejoinExistingGameMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string RejoinExistingGameMessage::GetTypeName() const {
  return "RejoinExistingGameMessage";
}


// ===================================================================

class JoinGameAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinGameAckMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_areyougameadmin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::NetGameInfo& gameinfo(const JoinGameAckMessage* msg);
  static void set_has_gameinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_spectateonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::NetGameInfo&
JoinGameAckMessage::_Internal::gameinfo(const JoinGameAckMessage* msg) {
  return *msg->gameinfo_;
}
JoinGameAckMessage::JoinGameAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:JoinGameAckMessage)
}
JoinGameAckMessage::JoinGameAckMessage(const JoinGameAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gameinfo()) {
    gameinfo_ = new ::NetGameInfo(*from.gameinfo_);
  } else {
    gameinfo_ = nullptr;
  }
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&spectateonly_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(spectateonly_));
  // @@protoc_insertion_point(copy_constructor:JoinGameAckMessage)
}

inline void JoinGameAckMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&spectateonly_) -
    reinterpret_cast<char*>(&gameinfo_)) + sizeof(spectateonly_));
}

JoinGameAckMessage::~JoinGameAckMessage() {
  // @@protoc_insertion_point(destructor:JoinGameAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void JoinGameAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete gameinfo_;
}

void JoinGameAckMessage::ArenaDtor(void* object) {
  JoinGameAckMessage* _this = reinterpret_cast< JoinGameAckMessage* >(object);
  (void)_this;
}
void JoinGameAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinGameAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinGameAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:JoinGameAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(gameinfo_ != nullptr);
    gameinfo_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&spectateonly_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(spectateonly_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JoinGameAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool areYouGameAdmin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_areyougameadmin(&has_bits);
          areyougameadmin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameInfo gameInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool spectateOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_spectateonly(&has_bits);
          spectateonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinGameAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:JoinGameAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required bool areYouGameAdmin = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_areyougameadmin(), target);
  }

  // required .NetGameInfo gameInfo = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::gameinfo(this), target, stream);
  }

  // optional bool spectateOnly = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_spectateonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:JoinGameAckMessage)
  return target;
}

size_t JoinGameAckMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:JoinGameAckMessage)
  size_t total_size = 0;

  if (_internal_has_gameinfo()) {
    // required .NetGameInfo gameInfo = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gameinfo_);
  }

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_areyougameadmin()) {
    // required bool areYouGameAdmin = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t JoinGameAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:JoinGameAckMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .NetGameInfo gameInfo = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gameinfo_);

    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required bool areYouGameAdmin = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool spectateOnly = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JoinGameAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const JoinGameAckMessage*>(
      &from));
}

void JoinGameAckMessage::MergeFrom(const JoinGameAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:JoinGameAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_gameinfo()->::NetGameInfo::MergeFrom(from._internal_gameinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000004u) {
      areyougameadmin_ = from.areyougameadmin_;
    }
    if (cached_has_bits & 0x00000008u) {
      spectateonly_ = from.spectateonly_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinGameAckMessage::CopyFrom(const JoinGameAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:JoinGameAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinGameAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_gameinfo()) {
    if (!gameinfo_->IsInitialized()) return false;
  }
  return true;
}

void JoinGameAckMessage::InternalSwap(JoinGameAckMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinGameAckMessage, spectateonly_)
      + sizeof(JoinGameAckMessage::spectateonly_)
      - PROTOBUF_FIELD_OFFSET(JoinGameAckMessage, gameinfo_)>(
          reinterpret_cast<char*>(&gameinfo_),
          reinterpret_cast<char*>(&other->gameinfo_));
}

std::string JoinGameAckMessage::GetTypeName() const {
  return "JoinGameAckMessage";
}


// ===================================================================

class JoinGameFailedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinGameFailedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_joingamefailurereason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

JoinGameFailedMessage::JoinGameFailedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:JoinGameFailedMessage)
}
JoinGameFailedMessage::JoinGameFailedMessage(const JoinGameFailedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&joingamefailurereason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(joingamefailurereason_));
  // @@protoc_insertion_point(copy_constructor:JoinGameFailedMessage)
}

inline void JoinGameFailedMessage::SharedCtor() {
gameid_ = 0u;
joingamefailurereason_ = 1;
}

JoinGameFailedMessage::~JoinGameFailedMessage() {
  // @@protoc_insertion_point(destructor:JoinGameFailedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void JoinGameFailedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void JoinGameFailedMessage::ArenaDtor(void* object) {
  JoinGameFailedMessage* _this = reinterpret_cast< JoinGameFailedMessage* >(object);
  (void)_this;
}
void JoinGameFailedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinGameFailedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinGameFailedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:JoinGameFailedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    gameid_ = 0u;
    joingamefailurereason_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JoinGameFailedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::JoinGameFailedMessage_JoinGameFailureReason_IsValid(val))) {
            _internal_set_joingamefailurereason(static_cast<::JoinGameFailedMessage_JoinGameFailureReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinGameFailedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:JoinGameFailedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_joingamefailurereason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:JoinGameFailedMessage)
  return target;
}

size_t JoinGameFailedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:JoinGameFailedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_joingamefailurereason()) {
    // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_joingamefailurereason());
  }

  return total_size;
}
size_t JoinGameFailedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:JoinGameFailedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_joingamefailurereason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JoinGameFailedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const JoinGameFailedMessage*>(
      &from));
}

void JoinGameFailedMessage::MergeFrom(const JoinGameFailedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:JoinGameFailedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      joingamefailurereason_ = from.joingamefailurereason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinGameFailedMessage::CopyFrom(const JoinGameFailedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:JoinGameFailedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinGameFailedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void JoinGameFailedMessage::InternalSwap(JoinGameFailedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gameid_, other->gameid_);
  swap(joingamefailurereason_, other->joingamefailurereason_);
}

std::string JoinGameFailedMessage::GetTypeName() const {
  return "JoinGameFailedMessage";
}


// ===================================================================

class GamePlayerJoinedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GamePlayerJoinedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_isgameadmin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GamePlayerJoinedMessage::GamePlayerJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GamePlayerJoinedMessage)
}
GamePlayerJoinedMessage::GamePlayerJoinedMessage(const GamePlayerJoinedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isgameadmin_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(isgameadmin_));
  // @@protoc_insertion_point(copy_constructor:GamePlayerJoinedMessage)
}

inline void GamePlayerJoinedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isgameadmin_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(isgameadmin_));
}

GamePlayerJoinedMessage::~GamePlayerJoinedMessage() {
  // @@protoc_insertion_point(destructor:GamePlayerJoinedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GamePlayerJoinedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GamePlayerJoinedMessage::ArenaDtor(void* object) {
  GamePlayerJoinedMessage* _this = reinterpret_cast< GamePlayerJoinedMessage* >(object);
  (void)_this;
}
void GamePlayerJoinedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GamePlayerJoinedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GamePlayerJoinedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GamePlayerJoinedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isgameadmin_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(isgameadmin_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GamePlayerJoinedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool isGameAdmin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_isgameadmin(&has_bits);
          isgameadmin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GamePlayerJoinedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GamePlayerJoinedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required bool isGameAdmin = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isgameadmin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GamePlayerJoinedMessage)
  return target;
}

size_t GamePlayerJoinedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GamePlayerJoinedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_isgameadmin()) {
    // required bool isGameAdmin = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t GamePlayerJoinedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GamePlayerJoinedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required bool isGameAdmin = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GamePlayerJoinedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GamePlayerJoinedMessage*>(
      &from));
}

void GamePlayerJoinedMessage::MergeFrom(const GamePlayerJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GamePlayerJoinedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      isgameadmin_ = from.isgameadmin_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GamePlayerJoinedMessage::CopyFrom(const GamePlayerJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GamePlayerJoinedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GamePlayerJoinedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GamePlayerJoinedMessage::InternalSwap(GamePlayerJoinedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GamePlayerJoinedMessage, isgameadmin_)
      + sizeof(GamePlayerJoinedMessage::isgameadmin_)
      - PROTOBUF_FIELD_OFFSET(GamePlayerJoinedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GamePlayerJoinedMessage::GetTypeName() const {
  return "GamePlayerJoinedMessage";
}


// ===================================================================

class GamePlayerLeftMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GamePlayerLeftMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gameplayerleftreason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GamePlayerLeftMessage::GamePlayerLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GamePlayerLeftMessage)
}
GamePlayerLeftMessage::GamePlayerLeftMessage(const GamePlayerLeftMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&gameplayerleftreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gameplayerleftreason_));
  // @@protoc_insertion_point(copy_constructor:GamePlayerLeftMessage)
}

inline void GamePlayerLeftMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gameplayerleftreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gameplayerleftreason_));
}

GamePlayerLeftMessage::~GamePlayerLeftMessage() {
  // @@protoc_insertion_point(destructor:GamePlayerLeftMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GamePlayerLeftMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GamePlayerLeftMessage::ArenaDtor(void* object) {
  GamePlayerLeftMessage* _this = reinterpret_cast< GamePlayerLeftMessage* >(object);
  (void)_this;
}
void GamePlayerLeftMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GamePlayerLeftMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GamePlayerLeftMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GamePlayerLeftMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gameplayerleftreason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(gameplayerleftreason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GamePlayerLeftMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(val))) {
            _internal_set_gameplayerleftreason(static_cast<::GamePlayerLeftMessage_GamePlayerLeftReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GamePlayerLeftMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GamePlayerLeftMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_gameplayerleftreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GamePlayerLeftMessage)
  return target;
}

size_t GamePlayerLeftMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GamePlayerLeftMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_gameplayerleftreason()) {
    // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gameplayerleftreason());
  }

  return total_size;
}
size_t GamePlayerLeftMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GamePlayerLeftMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gameplayerleftreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GamePlayerLeftMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GamePlayerLeftMessage*>(
      &from));
}

void GamePlayerLeftMessage::MergeFrom(const GamePlayerLeftMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GamePlayerLeftMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      gameplayerleftreason_ = from.gameplayerleftreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GamePlayerLeftMessage::CopyFrom(const GamePlayerLeftMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GamePlayerLeftMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GamePlayerLeftMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GamePlayerLeftMessage::InternalSwap(GamePlayerLeftMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GamePlayerLeftMessage, gameplayerleftreason_)
      + sizeof(GamePlayerLeftMessage::gameplayerleftreason_)
      - PROTOBUF_FIELD_OFFSET(GamePlayerLeftMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GamePlayerLeftMessage::GetTypeName() const {
  return "GamePlayerLeftMessage";
}


// ===================================================================

class GameSpectatorJoinedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameSpectatorJoinedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameSpectatorJoinedMessage::GameSpectatorJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameSpectatorJoinedMessage)
}
GameSpectatorJoinedMessage::GameSpectatorJoinedMessage(const GameSpectatorJoinedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:GameSpectatorJoinedMessage)
}

inline void GameSpectatorJoinedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

GameSpectatorJoinedMessage::~GameSpectatorJoinedMessage() {
  // @@protoc_insertion_point(destructor:GameSpectatorJoinedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameSpectatorJoinedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameSpectatorJoinedMessage::ArenaDtor(void* object) {
  GameSpectatorJoinedMessage* _this = reinterpret_cast< GameSpectatorJoinedMessage* >(object);
  (void)_this;
}
void GameSpectatorJoinedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameSpectatorJoinedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameSpectatorJoinedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameSpectatorJoinedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameSpectatorJoinedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameSpectatorJoinedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameSpectatorJoinedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameSpectatorJoinedMessage)
  return target;
}

size_t GameSpectatorJoinedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameSpectatorJoinedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t GameSpectatorJoinedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameSpectatorJoinedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameSpectatorJoinedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameSpectatorJoinedMessage*>(
      &from));
}

void GameSpectatorJoinedMessage::MergeFrom(const GameSpectatorJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameSpectatorJoinedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameSpectatorJoinedMessage::CopyFrom(const GameSpectatorJoinedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameSpectatorJoinedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameSpectatorJoinedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameSpectatorJoinedMessage::InternalSwap(GameSpectatorJoinedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameSpectatorJoinedMessage, playerid_)
      + sizeof(GameSpectatorJoinedMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(GameSpectatorJoinedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameSpectatorJoinedMessage::GetTypeName() const {
  return "GameSpectatorJoinedMessage";
}


// ===================================================================

class GameSpectatorLeftMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameSpectatorLeftMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gamespectatorleftreason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GameSpectatorLeftMessage::GameSpectatorLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameSpectatorLeftMessage)
}
GameSpectatorLeftMessage::GameSpectatorLeftMessage(const GameSpectatorLeftMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&gamespectatorleftreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gamespectatorleftreason_));
  // @@protoc_insertion_point(copy_constructor:GameSpectatorLeftMessage)
}

inline void GameSpectatorLeftMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gamespectatorleftreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gamespectatorleftreason_));
}

GameSpectatorLeftMessage::~GameSpectatorLeftMessage() {
  // @@protoc_insertion_point(destructor:GameSpectatorLeftMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameSpectatorLeftMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameSpectatorLeftMessage::ArenaDtor(void* object) {
  GameSpectatorLeftMessage* _this = reinterpret_cast< GameSpectatorLeftMessage* >(object);
  (void)_this;
}
void GameSpectatorLeftMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameSpectatorLeftMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameSpectatorLeftMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameSpectatorLeftMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gamespectatorleftreason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(gamespectatorleftreason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameSpectatorLeftMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(val))) {
            _internal_set_gamespectatorleftreason(static_cast<::GamePlayerLeftMessage_GamePlayerLeftReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameSpectatorLeftMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameSpectatorLeftMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_gamespectatorleftreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameSpectatorLeftMessage)
  return target;
}

size_t GameSpectatorLeftMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameSpectatorLeftMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_gamespectatorleftreason()) {
    // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamespectatorleftreason());
  }

  return total_size;
}
size_t GameSpectatorLeftMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameSpectatorLeftMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamespectatorleftreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameSpectatorLeftMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameSpectatorLeftMessage*>(
      &from));
}

void GameSpectatorLeftMessage::MergeFrom(const GameSpectatorLeftMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameSpectatorLeftMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      gamespectatorleftreason_ = from.gamespectatorleftreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameSpectatorLeftMessage::CopyFrom(const GameSpectatorLeftMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameSpectatorLeftMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameSpectatorLeftMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameSpectatorLeftMessage::InternalSwap(GameSpectatorLeftMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameSpectatorLeftMessage, gamespectatorleftreason_)
      + sizeof(GameSpectatorLeftMessage::gamespectatorleftreason_)
      - PROTOBUF_FIELD_OFFSET(GameSpectatorLeftMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameSpectatorLeftMessage::GetTypeName() const {
  return "GameSpectatorLeftMessage";
}


// ===================================================================

class GameAdminChangedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameAdminChangedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newadminplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameAdminChangedMessage::GameAdminChangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameAdminChangedMessage)
}
GameAdminChangedMessage::GameAdminChangedMessage(const GameAdminChangedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&newadminplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(newadminplayerid_));
  // @@protoc_insertion_point(copy_constructor:GameAdminChangedMessage)
}

inline void GameAdminChangedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&newadminplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(newadminplayerid_));
}

GameAdminChangedMessage::~GameAdminChangedMessage() {
  // @@protoc_insertion_point(destructor:GameAdminChangedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameAdminChangedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameAdminChangedMessage::ArenaDtor(void* object) {
  GameAdminChangedMessage* _this = reinterpret_cast< GameAdminChangedMessage* >(object);
  (void)_this;
}
void GameAdminChangedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameAdminChangedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameAdminChangedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameAdminChangedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&newadminplayerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(newadminplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameAdminChangedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 newAdminPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_newadminplayerid(&has_bits);
          newadminplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameAdminChangedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameAdminChangedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 newAdminPlayerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_newadminplayerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameAdminChangedMessage)
  return target;
}

size_t GameAdminChangedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameAdminChangedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_newadminplayerid()) {
    // required uint32 newAdminPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_newadminplayerid());
  }

  return total_size;
}
size_t GameAdminChangedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameAdminChangedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 newAdminPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_newadminplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameAdminChangedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameAdminChangedMessage*>(
      &from));
}

void GameAdminChangedMessage::MergeFrom(const GameAdminChangedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameAdminChangedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      newadminplayerid_ = from.newadminplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameAdminChangedMessage::CopyFrom(const GameAdminChangedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameAdminChangedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameAdminChangedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameAdminChangedMessage::InternalSwap(GameAdminChangedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameAdminChangedMessage, newadminplayerid_)
      + sizeof(GameAdminChangedMessage::newadminplayerid_)
      - PROTOBUF_FIELD_OFFSET(GameAdminChangedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameAdminChangedMessage::GetTypeName() const {
  return "GameAdminChangedMessage";
}


// ===================================================================

class RemovedFromGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RemovedFromGameMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_removedfromgamereason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RemovedFromGameMessage::RemovedFromGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RemovedFromGameMessage)
}
RemovedFromGameMessage::RemovedFromGameMessage(const RemovedFromGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&removedfromgamereason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(removedfromgamereason_));
  // @@protoc_insertion_point(copy_constructor:RemovedFromGameMessage)
}

inline void RemovedFromGameMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&removedfromgamereason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(removedfromgamereason_));
}

RemovedFromGameMessage::~RemovedFromGameMessage() {
  // @@protoc_insertion_point(destructor:RemovedFromGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RemovedFromGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RemovedFromGameMessage::ArenaDtor(void* object) {
  RemovedFromGameMessage* _this = reinterpret_cast< RemovedFromGameMessage* >(object);
  (void)_this;
}
void RemovedFromGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RemovedFromGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RemovedFromGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:RemovedFromGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&removedfromgamereason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(removedfromgamereason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RemovedFromGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::RemovedFromGameMessage_RemovedFromGameReason_IsValid(val))) {
            _internal_set_removedfromgamereason(static_cast<::RemovedFromGameMessage_RemovedFromGameReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemovedFromGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RemovedFromGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_removedfromgamereason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RemovedFromGameMessage)
  return target;
}

size_t RemovedFromGameMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RemovedFromGameMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_removedfromgamereason()) {
    // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_removedfromgamereason());
  }

  return total_size;
}
size_t RemovedFromGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RemovedFromGameMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_removedfromgamereason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemovedFromGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RemovedFromGameMessage*>(
      &from));
}

void RemovedFromGameMessage::MergeFrom(const RemovedFromGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RemovedFromGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      removedfromgamereason_ = from.removedfromgamereason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemovedFromGameMessage::CopyFrom(const RemovedFromGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RemovedFromGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemovedFromGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RemovedFromGameMessage::InternalSwap(RemovedFromGameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemovedFromGameMessage, removedfromgamereason_)
      + sizeof(RemovedFromGameMessage::removedfromgamereason_)
      - PROTOBUF_FIELD_OFFSET(RemovedFromGameMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string RemovedFromGameMessage::GetTypeName() const {
  return "RemovedFromGameMessage";
}


// ===================================================================

class KickPlayerRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<KickPlayerRequestMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KickPlayerRequestMessage::KickPlayerRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:KickPlayerRequestMessage)
}
KickPlayerRequestMessage::KickPlayerRequestMessage(const KickPlayerRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:KickPlayerRequestMessage)
}

inline void KickPlayerRequestMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

KickPlayerRequestMessage::~KickPlayerRequestMessage() {
  // @@protoc_insertion_point(destructor:KickPlayerRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KickPlayerRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KickPlayerRequestMessage::ArenaDtor(void* object) {
  KickPlayerRequestMessage* _this = reinterpret_cast< KickPlayerRequestMessage* >(object);
  (void)_this;
}
void KickPlayerRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KickPlayerRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KickPlayerRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:KickPlayerRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KickPlayerRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KickPlayerRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:KickPlayerRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KickPlayerRequestMessage)
  return target;
}

size_t KickPlayerRequestMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:KickPlayerRequestMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t KickPlayerRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:KickPlayerRequestMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KickPlayerRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KickPlayerRequestMessage*>(
      &from));
}

void KickPlayerRequestMessage::MergeFrom(const KickPlayerRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KickPlayerRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KickPlayerRequestMessage::CopyFrom(const KickPlayerRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KickPlayerRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KickPlayerRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void KickPlayerRequestMessage::InternalSwap(KickPlayerRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KickPlayerRequestMessage, playerid_)
      + sizeof(KickPlayerRequestMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(KickPlayerRequestMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string KickPlayerRequestMessage::GetTypeName() const {
  return "KickPlayerRequestMessage";
}


// ===================================================================

class LeaveGameRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaveGameRequestMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LeaveGameRequestMessage::LeaveGameRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:LeaveGameRequestMessage)
}
LeaveGameRequestMessage::LeaveGameRequestMessage(const LeaveGameRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  gameid_ = from.gameid_;
  // @@protoc_insertion_point(copy_constructor:LeaveGameRequestMessage)
}

inline void LeaveGameRequestMessage::SharedCtor() {
gameid_ = 0u;
}

LeaveGameRequestMessage::~LeaveGameRequestMessage() {
  // @@protoc_insertion_point(destructor:LeaveGameRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LeaveGameRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaveGameRequestMessage::ArenaDtor(void* object) {
  LeaveGameRequestMessage* _this = reinterpret_cast< LeaveGameRequestMessage* >(object);
  (void)_this;
}
void LeaveGameRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeaveGameRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaveGameRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:LeaveGameRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gameid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LeaveGameRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaveGameRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LeaveGameRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LeaveGameRequestMessage)
  return target;
}

size_t LeaveGameRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LeaveGameRequestMessage)
  size_t total_size = 0;

  // required uint32 gameId = 1;
  if (_internal_has_gameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LeaveGameRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LeaveGameRequestMessage*>(
      &from));
}

void LeaveGameRequestMessage::MergeFrom(const LeaveGameRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LeaveGameRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gameid()) {
    _internal_set_gameid(from._internal_gameid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LeaveGameRequestMessage::CopyFrom(const LeaveGameRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LeaveGameRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveGameRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LeaveGameRequestMessage::InternalSwap(LeaveGameRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gameid_, other->gameid_);
}

std::string LeaveGameRequestMessage::GetTypeName() const {
  return "LeaveGameRequestMessage";
}


// ===================================================================

class InvitePlayerToGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InvitePlayerToGameMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

InvitePlayerToGameMessage::InvitePlayerToGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InvitePlayerToGameMessage)
}
InvitePlayerToGameMessage::InvitePlayerToGameMessage(const InvitePlayerToGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:InvitePlayerToGameMessage)
}

inline void InvitePlayerToGameMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

InvitePlayerToGameMessage::~InvitePlayerToGameMessage() {
  // @@protoc_insertion_point(destructor:InvitePlayerToGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InvitePlayerToGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InvitePlayerToGameMessage::ArenaDtor(void* object) {
  InvitePlayerToGameMessage* _this = reinterpret_cast< InvitePlayerToGameMessage* >(object);
  (void)_this;
}
void InvitePlayerToGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InvitePlayerToGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InvitePlayerToGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:InvitePlayerToGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InvitePlayerToGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InvitePlayerToGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InvitePlayerToGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InvitePlayerToGameMessage)
  return target;
}

size_t InvitePlayerToGameMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:InvitePlayerToGameMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t InvitePlayerToGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InvitePlayerToGameMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InvitePlayerToGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InvitePlayerToGameMessage*>(
      &from));
}

void InvitePlayerToGameMessage::MergeFrom(const InvitePlayerToGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InvitePlayerToGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InvitePlayerToGameMessage::CopyFrom(const InvitePlayerToGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InvitePlayerToGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvitePlayerToGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void InvitePlayerToGameMessage::InternalSwap(InvitePlayerToGameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InvitePlayerToGameMessage, playerid_)
      + sizeof(InvitePlayerToGameMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(InvitePlayerToGameMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string InvitePlayerToGameMessage::GetTypeName() const {
  return "InvitePlayerToGameMessage";
}


// ===================================================================

class InviteNotifyMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InviteNotifyMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playeridwho(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playeridbywhom(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

InviteNotifyMessage::InviteNotifyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InviteNotifyMessage)
}
InviteNotifyMessage::InviteNotifyMessage(const InviteNotifyMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playeridbywhom_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playeridbywhom_));
  // @@protoc_insertion_point(copy_constructor:InviteNotifyMessage)
}

inline void InviteNotifyMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playeridbywhom_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playeridbywhom_));
}

InviteNotifyMessage::~InviteNotifyMessage() {
  // @@protoc_insertion_point(destructor:InviteNotifyMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InviteNotifyMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InviteNotifyMessage::ArenaDtor(void* object) {
  InviteNotifyMessage* _this = reinterpret_cast< InviteNotifyMessage* >(object);
  (void)_this;
}
void InviteNotifyMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InviteNotifyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InviteNotifyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:InviteNotifyMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playeridbywhom_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playeridbywhom_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InviteNotifyMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerIdWho = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playeridwho(&has_bits);
          playeridwho_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerIdByWhom = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_playeridbywhom(&has_bits);
          playeridbywhom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InviteNotifyMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InviteNotifyMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerIdWho = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playeridwho(), target);
  }

  // required uint32 playerIdByWhom = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_playeridbywhom(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InviteNotifyMessage)
  return target;
}

size_t InviteNotifyMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:InviteNotifyMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playeridwho()) {
    // required uint32 playerIdWho = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playeridwho());
  }

  if (_internal_has_playeridbywhom()) {
    // required uint32 playerIdByWhom = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playeridbywhom());
  }

  return total_size;
}
size_t InviteNotifyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InviteNotifyMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerIdWho = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playeridwho());

    // required uint32 playerIdByWhom = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playeridbywhom());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InviteNotifyMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InviteNotifyMessage*>(
      &from));
}

void InviteNotifyMessage::MergeFrom(const InviteNotifyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InviteNotifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playeridwho_ = from.playeridwho_;
    }
    if (cached_has_bits & 0x00000004u) {
      playeridbywhom_ = from.playeridbywhom_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InviteNotifyMessage::CopyFrom(const InviteNotifyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InviteNotifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InviteNotifyMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void InviteNotifyMessage::InternalSwap(InviteNotifyMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InviteNotifyMessage, playeridbywhom_)
      + sizeof(InviteNotifyMessage::playeridbywhom_)
      - PROTOBUF_FIELD_OFFSET(InviteNotifyMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string InviteNotifyMessage::GetTypeName() const {
  return "InviteNotifyMessage";
}


// ===================================================================

class RejectGameInvitationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RejectGameInvitationMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_myrejectreason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RejectGameInvitationMessage::RejectGameInvitationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RejectGameInvitationMessage)
}
RejectGameInvitationMessage::RejectGameInvitationMessage(const RejectGameInvitationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&myrejectreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(myrejectreason_));
  // @@protoc_insertion_point(copy_constructor:RejectGameInvitationMessage)
}

inline void RejectGameInvitationMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&myrejectreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(myrejectreason_));
}

RejectGameInvitationMessage::~RejectGameInvitationMessage() {
  // @@protoc_insertion_point(destructor:RejectGameInvitationMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RejectGameInvitationMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RejectGameInvitationMessage::ArenaDtor(void* object) {
  RejectGameInvitationMessage* _this = reinterpret_cast< RejectGameInvitationMessage* >(object);
  (void)_this;
}
void RejectGameInvitationMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RejectGameInvitationMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RejectGameInvitationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:RejectGameInvitationMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&myrejectreason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(myrejectreason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RejectGameInvitationMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(val))) {
            _internal_set_myrejectreason(static_cast<::RejectGameInvitationMessage_RejectGameInvReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RejectGameInvitationMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RejectGameInvitationMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_myrejectreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RejectGameInvitationMessage)
  return target;
}

size_t RejectGameInvitationMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RejectGameInvitationMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_myrejectreason()) {
    // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_myrejectreason());
  }

  return total_size;
}
size_t RejectGameInvitationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RejectGameInvitationMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_myrejectreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RejectGameInvitationMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RejectGameInvitationMessage*>(
      &from));
}

void RejectGameInvitationMessage::MergeFrom(const RejectGameInvitationMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RejectGameInvitationMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      myrejectreason_ = from.myrejectreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RejectGameInvitationMessage::CopyFrom(const RejectGameInvitationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RejectGameInvitationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RejectGameInvitationMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RejectGameInvitationMessage::InternalSwap(RejectGameInvitationMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RejectGameInvitationMessage, myrejectreason_)
      + sizeof(RejectGameInvitationMessage::myrejectreason_)
      - PROTOBUF_FIELD_OFFSET(RejectGameInvitationMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string RejectGameInvitationMessage::GetTypeName() const {
  return "RejectGameInvitationMessage";
}


// ===================================================================

class RejectInvNotifyMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RejectInvNotifyMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playerrejectreason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

RejectInvNotifyMessage::RejectInvNotifyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RejectInvNotifyMessage)
}
RejectInvNotifyMessage::RejectInvNotifyMessage(const RejectInvNotifyMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerrejectreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerrejectreason_));
  // @@protoc_insertion_point(copy_constructor:RejectInvNotifyMessage)
}

inline void RejectInvNotifyMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerrejectreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerrejectreason_));
}

RejectInvNotifyMessage::~RejectInvNotifyMessage() {
  // @@protoc_insertion_point(destructor:RejectInvNotifyMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RejectInvNotifyMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RejectInvNotifyMessage::ArenaDtor(void* object) {
  RejectInvNotifyMessage* _this = reinterpret_cast< RejectInvNotifyMessage* >(object);
  (void)_this;
}
void RejectInvNotifyMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RejectInvNotifyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RejectInvNotifyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:RejectInvNotifyMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerrejectreason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerrejectreason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RejectInvNotifyMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(val))) {
            _internal_set_playerrejectreason(static_cast<::RejectGameInvitationMessage_RejectGameInvReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RejectInvNotifyMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RejectInvNotifyMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_playerrejectreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RejectInvNotifyMessage)
  return target;
}

size_t RejectInvNotifyMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RejectInvNotifyMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_playerrejectreason()) {
    // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playerrejectreason());
  }

  return total_size;
}
size_t RejectInvNotifyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RejectInvNotifyMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playerrejectreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RejectInvNotifyMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RejectInvNotifyMessage*>(
      &from));
}

void RejectInvNotifyMessage::MergeFrom(const RejectInvNotifyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RejectInvNotifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      playerrejectreason_ = from.playerrejectreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RejectInvNotifyMessage::CopyFrom(const RejectInvNotifyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RejectInvNotifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RejectInvNotifyMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RejectInvNotifyMessage::InternalSwap(RejectInvNotifyMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RejectInvNotifyMessage, playerrejectreason_)
      + sizeof(RejectInvNotifyMessage::playerrejectreason_)
      - PROTOBUF_FIELD_OFFSET(RejectInvNotifyMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string RejectInvNotifyMessage::GetTypeName() const {
  return "RejectInvNotifyMessage";
}


// ===================================================================

class StartEventMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<StartEventMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_starteventtype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fillwithcomputerplayers(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StartEventMessage::StartEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StartEventMessage)
}
StartEventMessage::StartEventMessage(const StartEventMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&fillwithcomputerplayers_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(fillwithcomputerplayers_));
  // @@protoc_insertion_point(copy_constructor:StartEventMessage)
}

inline void StartEventMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fillwithcomputerplayers_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(fillwithcomputerplayers_));
}

StartEventMessage::~StartEventMessage() {
  // @@protoc_insertion_point(destructor:StartEventMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StartEventMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StartEventMessage::ArenaDtor(void* object) {
  StartEventMessage* _this = reinterpret_cast< StartEventMessage* >(object);
  (void)_this;
}
void StartEventMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StartEventMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StartEventMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:StartEventMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fillwithcomputerplayers_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(fillwithcomputerplayers_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StartEventMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .StartEventMessage.StartEventType startEventType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::StartEventMessage_StartEventType_IsValid(val))) {
            _internal_set_starteventtype(static_cast<::StartEventMessage_StartEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool fillWithComputerPlayers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fillwithcomputerplayers(&has_bits);
          fillwithcomputerplayers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartEventMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StartEventMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .StartEventMessage.StartEventType startEventType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_starteventtype(), target);
  }

  // optional bool fillWithComputerPlayers = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_fillwithcomputerplayers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StartEventMessage)
  return target;
}

size_t StartEventMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StartEventMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_starteventtype()) {
    // required .StartEventMessage.StartEventType startEventType = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_starteventtype());
  }

  return total_size;
}
size_t StartEventMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StartEventMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required .StartEventMessage.StartEventType startEventType = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_starteventtype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool fillWithComputerPlayers = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartEventMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StartEventMessage*>(
      &from));
}

void StartEventMessage::MergeFrom(const StartEventMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StartEventMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      starteventtype_ = from.starteventtype_;
    }
    if (cached_has_bits & 0x00000004u) {
      fillwithcomputerplayers_ = from.fillwithcomputerplayers_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StartEventMessage::CopyFrom(const StartEventMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StartEventMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartEventMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StartEventMessage::InternalSwap(StartEventMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartEventMessage, fillwithcomputerplayers_)
      + sizeof(StartEventMessage::fillwithcomputerplayers_)
      - PROTOBUF_FIELD_OFFSET(StartEventMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string StartEventMessage::GetTypeName() const {
  return "StartEventMessage";
}


// ===================================================================

class StartEventAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<StartEventAckMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StartEventAckMessage::StartEventAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StartEventAckMessage)
}
StartEventAckMessage::StartEventAckMessage(const StartEventAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  gameid_ = from.gameid_;
  // @@protoc_insertion_point(copy_constructor:StartEventAckMessage)
}

inline void StartEventAckMessage::SharedCtor() {
gameid_ = 0u;
}

StartEventAckMessage::~StartEventAckMessage() {
  // @@protoc_insertion_point(destructor:StartEventAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StartEventAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StartEventAckMessage::ArenaDtor(void* object) {
  StartEventAckMessage* _this = reinterpret_cast< StartEventAckMessage* >(object);
  (void)_this;
}
void StartEventAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StartEventAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StartEventAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:StartEventAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gameid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StartEventAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartEventAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StartEventAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StartEventAckMessage)
  return target;
}

size_t StartEventAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StartEventAckMessage)
  size_t total_size = 0;

  // required uint32 gameId = 1;
  if (_internal_has_gameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartEventAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StartEventAckMessage*>(
      &from));
}

void StartEventAckMessage::MergeFrom(const StartEventAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StartEventAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gameid()) {
    _internal_set_gameid(from._internal_gameid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StartEventAckMessage::CopyFrom(const StartEventAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StartEventAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartEventAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StartEventAckMessage::InternalSwap(StartEventAckMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gameid_, other->gameid_);
}

std::string StartEventAckMessage::GetTypeName() const {
  return "StartEventAckMessage";
}


// ===================================================================

class GameStartInitialMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameStartInitialMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startdealerplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameStartInitialMessage::GameStartInitialMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  playerseats_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameStartInitialMessage)
}
GameStartInitialMessage::GameStartInitialMessage(const GameStartInitialMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      playerseats_(from.playerseats_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&startdealerplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(startdealerplayerid_));
  // @@protoc_insertion_point(copy_constructor:GameStartInitialMessage)
}

inline void GameStartInitialMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&startdealerplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(startdealerplayerid_));
}

GameStartInitialMessage::~GameStartInitialMessage() {
  // @@protoc_insertion_point(destructor:GameStartInitialMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameStartInitialMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameStartInitialMessage::ArenaDtor(void* object) {
  GameStartInitialMessage* _this = reinterpret_cast< GameStartInitialMessage* >(object);
  (void)_this;
}
void GameStartInitialMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameStartInitialMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameStartInitialMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameStartInitialMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  playerseats_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&startdealerplayerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(startdealerplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameStartInitialMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 startDealerPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_startdealerplayerid(&has_bits);
          startdealerplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 playerSeats = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_playerseats(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_playerseats(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameStartInitialMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameStartInitialMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 startDealerPlayerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startdealerplayerid(), target);
  }

  // repeated uint32 playerSeats = 3 [packed = true];
  {
    int byte_size = _playerseats_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_playerseats(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameStartInitialMessage)
  return target;
}

size_t GameStartInitialMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameStartInitialMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_startdealerplayerid()) {
    // required uint32 startDealerPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_startdealerplayerid());
  }

  return total_size;
}
size_t GameStartInitialMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameStartInitialMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 startDealerPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_startdealerplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 playerSeats = 3 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->playerseats_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _playerseats_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameStartInitialMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameStartInitialMessage*>(
      &from));
}

void GameStartInitialMessage::MergeFrom(const GameStartInitialMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameStartInitialMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  playerseats_.MergeFrom(from.playerseats_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      startdealerplayerid_ = from.startdealerplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameStartInitialMessage::CopyFrom(const GameStartInitialMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameStartInitialMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameStartInitialMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameStartInitialMessage::InternalSwap(GameStartInitialMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  playerseats_.InternalSwap(&other->playerseats_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameStartInitialMessage, startdealerplayerid_)
      + sizeof(GameStartInitialMessage::startdealerplayerid_)
      - PROTOBUF_FIELD_OFFSET(GameStartInitialMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameStartInitialMessage::GetTypeName() const {
  return "GameStartInitialMessage";
}


// ===================================================================

class GameStartRejoinMessage_RejoinPlayerData::_Internal {
 public:
  using HasBits = decltype(std::declval<GameStartRejoinMessage_RejoinPlayerData>()._has_bits_);
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playermoney(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GameStartRejoinMessage_RejoinPlayerData::GameStartRejoinMessage_RejoinPlayerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameStartRejoinMessage.RejoinPlayerData)
}
GameStartRejoinMessage_RejoinPlayerData::GameStartRejoinMessage_RejoinPlayerData(const GameStartRejoinMessage_RejoinPlayerData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&playerid_, &from.playerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playermoney_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(playermoney_));
  // @@protoc_insertion_point(copy_constructor:GameStartRejoinMessage.RejoinPlayerData)
}

inline void GameStartRejoinMessage_RejoinPlayerData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&playerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playermoney_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(playermoney_));
}

GameStartRejoinMessage_RejoinPlayerData::~GameStartRejoinMessage_RejoinPlayerData() {
  // @@protoc_insertion_point(destructor:GameStartRejoinMessage.RejoinPlayerData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameStartRejoinMessage_RejoinPlayerData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameStartRejoinMessage_RejoinPlayerData::ArenaDtor(void* object) {
  GameStartRejoinMessage_RejoinPlayerData* _this = reinterpret_cast< GameStartRejoinMessage_RejoinPlayerData* >(object);
  (void)_this;
}
void GameStartRejoinMessage_RejoinPlayerData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameStartRejoinMessage_RejoinPlayerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameStartRejoinMessage_RejoinPlayerData::Clear() {
// @@protoc_insertion_point(message_clear_start:GameStartRejoinMessage.RejoinPlayerData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&playerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playermoney_) -
        reinterpret_cast<char*>(&playerid_)) + sizeof(playermoney_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameStartRejoinMessage_RejoinPlayerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerMoney = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playermoney(&has_bits);
          playermoney_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameStartRejoinMessage_RejoinPlayerData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameStartRejoinMessage.RejoinPlayerData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 playerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_playerid(), target);
  }

  // required uint32 playerMoney = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playermoney(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameStartRejoinMessage.RejoinPlayerData)
  return target;
}

size_t GameStartRejoinMessage_RejoinPlayerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameStartRejoinMessage.RejoinPlayerData)
  size_t total_size = 0;

  if (_internal_has_playerid()) {
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_playermoney()) {
    // required uint32 playerMoney = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());
  }

  return total_size;
}
size_t GameStartRejoinMessage_RejoinPlayerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameStartRejoinMessage.RejoinPlayerData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required uint32 playerMoney = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameStartRejoinMessage_RejoinPlayerData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameStartRejoinMessage_RejoinPlayerData*>(
      &from));
}

void GameStartRejoinMessage_RejoinPlayerData::MergeFrom(const GameStartRejoinMessage_RejoinPlayerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameStartRejoinMessage.RejoinPlayerData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playermoney_ = from.playermoney_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameStartRejoinMessage_RejoinPlayerData::CopyFrom(const GameStartRejoinMessage_RejoinPlayerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameStartRejoinMessage.RejoinPlayerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameStartRejoinMessage_RejoinPlayerData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GameStartRejoinMessage_RejoinPlayerData::InternalSwap(GameStartRejoinMessage_RejoinPlayerData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameStartRejoinMessage_RejoinPlayerData, playermoney_)
      + sizeof(GameStartRejoinMessage_RejoinPlayerData::playermoney_)
      - PROTOBUF_FIELD_OFFSET(GameStartRejoinMessage_RejoinPlayerData, playerid_)>(
          reinterpret_cast<char*>(&playerid_),
          reinterpret_cast<char*>(&other->playerid_));
}

std::string GameStartRejoinMessage_RejoinPlayerData::GetTypeName() const {
  return "GameStartRejoinMessage.RejoinPlayerData";
}


// ===================================================================

class GameStartRejoinMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameStartRejoinMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startdealerplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_handnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GameStartRejoinMessage::GameStartRejoinMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  rejoinplayerdata_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameStartRejoinMessage)
}
GameStartRejoinMessage::GameStartRejoinMessage(const GameStartRejoinMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      rejoinplayerdata_(from.rejoinplayerdata_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&handnum_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(handnum_));
  // @@protoc_insertion_point(copy_constructor:GameStartRejoinMessage)
}

inline void GameStartRejoinMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&handnum_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(handnum_));
}

GameStartRejoinMessage::~GameStartRejoinMessage() {
  // @@protoc_insertion_point(destructor:GameStartRejoinMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GameStartRejoinMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameStartRejoinMessage::ArenaDtor(void* object) {
  GameStartRejoinMessage* _this = reinterpret_cast< GameStartRejoinMessage* >(object);
  (void)_this;
}
void GameStartRejoinMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameStartRejoinMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameStartRejoinMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:GameStartRejoinMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rejoinplayerdata_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&handnum_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(handnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GameStartRejoinMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 startDealerPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_startdealerplayerid(&has_bits);
          startdealerplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 handNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_handnum(&has_bits);
          handnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rejoinplayerdata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameStartRejoinMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameStartRejoinMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 startDealerPlayerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startdealerplayerid(), target);
  }

  // required uint32 handNum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_handnum(), target);
  }

  // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_rejoinplayerdata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_rejoinplayerdata(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameStartRejoinMessage)
  return target;
}

size_t GameStartRejoinMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:GameStartRejoinMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_startdealerplayerid()) {
    // required uint32 startDealerPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_startdealerplayerid());
  }

  if (_internal_has_handnum()) {
    // required uint32 handNum = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_handnum());
  }

  return total_size;
}
size_t GameStartRejoinMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameStartRejoinMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 startDealerPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_startdealerplayerid());

    // required uint32 handNum = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_handnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
  total_size += 1UL * this->_internal_rejoinplayerdata_size();
  for (const auto& msg : this->rejoinplayerdata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameStartRejoinMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GameStartRejoinMessage*>(
      &from));
}

void GameStartRejoinMessage::MergeFrom(const GameStartRejoinMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameStartRejoinMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  rejoinplayerdata_.MergeFrom(from.rejoinplayerdata_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      startdealerplayerid_ = from.startdealerplayerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      handnum_ = from.handnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GameStartRejoinMessage::CopyFrom(const GameStartRejoinMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameStartRejoinMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameStartRejoinMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(rejoinplayerdata_))
    return false;
  return true;
}

void GameStartRejoinMessage::InternalSwap(GameStartRejoinMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rejoinplayerdata_.InternalSwap(&other->rejoinplayerdata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameStartRejoinMessage, handnum_)
      + sizeof(GameStartRejoinMessage::handnum_)
      - PROTOBUF_FIELD_OFFSET(GameStartRejoinMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string GameStartRejoinMessage::GetTypeName() const {
  return "GameStartRejoinMessage";
}


// ===================================================================

class HandStartMessage_PlainCards::_Internal {
 public:
  using HasBits = decltype(std::declval<HandStartMessage_PlainCards>()._has_bits_);
  static void set_has_plaincard1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_plaincard2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

HandStartMessage_PlainCards::HandStartMessage_PlainCards(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HandStartMessage.PlainCards)
}
HandStartMessage_PlainCards::HandStartMessage_PlainCards(const HandStartMessage_PlainCards& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&plaincard1_, &from.plaincard1_,
    static_cast<size_t>(reinterpret_cast<char*>(&plaincard2_) -
    reinterpret_cast<char*>(&plaincard1_)) + sizeof(plaincard2_));
  // @@protoc_insertion_point(copy_constructor:HandStartMessage.PlainCards)
}

inline void HandStartMessage_PlainCards::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&plaincard1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&plaincard2_) -
    reinterpret_cast<char*>(&plaincard1_)) + sizeof(plaincard2_));
}

HandStartMessage_PlainCards::~HandStartMessage_PlainCards() {
  // @@protoc_insertion_point(destructor:HandStartMessage.PlainCards)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void HandStartMessage_PlainCards::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HandStartMessage_PlainCards::ArenaDtor(void* object) {
  HandStartMessage_PlainCards* _this = reinterpret_cast< HandStartMessage_PlainCards* >(object);
  (void)_this;
}
void HandStartMessage_PlainCards::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HandStartMessage_PlainCards::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HandStartMessage_PlainCards::Clear() {
// @@protoc_insertion_point(message_clear_start:HandStartMessage.PlainCards)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&plaincard1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&plaincard2_) -
        reinterpret_cast<char*>(&plaincard1_)) + sizeof(plaincard2_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HandStartMessage_PlainCards::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 plainCard1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_plaincard1(&has_bits);
          plaincard1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 plainCard2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_plaincard2(&has_bits);
          plaincard2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HandStartMessage_PlainCards::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HandStartMessage.PlainCards)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 plainCard1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_plaincard1(), target);
  }

  // required uint32 plainCard2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_plaincard2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HandStartMessage.PlainCards)
  return target;
}

size_t HandStartMessage_PlainCards::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HandStartMessage.PlainCards)
  size_t total_size = 0;

  if (_internal_has_plaincard1()) {
    // required uint32 plainCard1 = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_plaincard1());
  }

  if (_internal_has_plaincard2()) {
    // required uint32 plainCard2 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_plaincard2());
  }

  return total_size;
}
size_t HandStartMessage_PlainCards::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HandStartMessage.PlainCards)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 plainCard1 = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_plaincard1());

    // required uint32 plainCard2 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_plaincard2());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HandStartMessage_PlainCards::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HandStartMessage_PlainCards*>(
      &from));
}

void HandStartMessage_PlainCards::MergeFrom(const HandStartMessage_PlainCards& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HandStartMessage.PlainCards)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      plaincard1_ = from.plaincard1_;
    }
    if (cached_has_bits & 0x00000002u) {
      plaincard2_ = from.plaincard2_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HandStartMessage_PlainCards::CopyFrom(const HandStartMessage_PlainCards& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HandStartMessage.PlainCards)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandStartMessage_PlainCards::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void HandStartMessage_PlainCards::InternalSwap(HandStartMessage_PlainCards* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HandStartMessage_PlainCards, plaincard2_)
      + sizeof(HandStartMessage_PlainCards::plaincard2_)
      - PROTOBUF_FIELD_OFFSET(HandStartMessage_PlainCards, plaincard1_)>(
          reinterpret_cast<char*>(&plaincard1_),
          reinterpret_cast<char*>(&other->plaincard1_));
}

std::string HandStartMessage_PlainCards::GetTypeName() const {
  return "HandStartMessage.PlainCards";
}


// ===================================================================

class HandStartMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<HandStartMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::HandStartMessage_PlainCards& plaincards(const HandStartMessage* msg);
  static void set_has_plaincards(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encryptedcards(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_smallblind(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dealerplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

const ::HandStartMessage_PlainCards&
HandStartMessage::_Internal::plaincards(const HandStartMessage* msg) {
  return *msg->plaincards_;
}
HandStartMessage::HandStartMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  seatstates_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HandStartMessage)
}
HandStartMessage::HandStartMessage(const HandStartMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      seatstates_(from.seatstates_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  encryptedcards_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encryptedcards_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encryptedcards()) {
    encryptedcards_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encryptedcards(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_plaincards()) {
    plaincards_ = new ::HandStartMessage_PlainCards(*from.plaincards_);
  } else {
    plaincards_ = nullptr;
  }
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&dealerplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(dealerplayerid_));
  // @@protoc_insertion_point(copy_constructor:HandStartMessage)
}

inline void HandStartMessage::SharedCtor() {
encryptedcards_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encryptedcards_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&plaincards_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dealerplayerid_) -
    reinterpret_cast<char*>(&plaincards_)) + sizeof(dealerplayerid_));
}

HandStartMessage::~HandStartMessage() {
  // @@protoc_insertion_point(destructor:HandStartMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void HandStartMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encryptedcards_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete plaincards_;
}

void HandStartMessage::ArenaDtor(void* object) {
  HandStartMessage* _this = reinterpret_cast< HandStartMessage* >(object);
  (void)_this;
}
void HandStartMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HandStartMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HandStartMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:HandStartMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  seatstates_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      encryptedcards_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(plaincards_ != nullptr);
      plaincards_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dealerplayerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(dealerplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HandStartMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HandStartMessage.PlainCards plainCards = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_plaincards(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encryptedCards = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_encryptedcards();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 smallBlind = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_smallblind(&has_bits);
          smallblind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .NetPlayerState seatStates = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::NetPlayerState_IsValid(val))) {
              _internal_add_seatstates(static_cast<::NetPlayerState>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_seatstates(), ptr, ctx, ::NetPlayerState_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dealerPlayerId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dealerplayerid(&has_bits);
          dealerplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HandStartMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HandStartMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // optional .HandStartMessage.PlainCards plainCards = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::plaincards(this), target, stream);
  }

  // optional bytes encryptedCards = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_encryptedcards(), target);
  }

  // required uint32 smallBlind = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_smallblind(), target);
  }

  // repeated .NetPlayerState seatStates = 5;
  for (int i = 0, n = this->_internal_seatstates_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        5, this->_internal_seatstates(i), target);
  }

  // optional uint32 dealerPlayerId = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_dealerplayerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HandStartMessage)
  return target;
}

size_t HandStartMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HandStartMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_smallblind()) {
    // required uint32 smallBlind = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_smallblind());
  }

  return total_size;
}
size_t HandStartMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HandStartMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 smallBlind = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_smallblind());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NetPlayerState seatStates = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_seatstates_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_seatstates(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes encryptedCards = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encryptedcards());
    }

    // optional .HandStartMessage.PlainCards plainCards = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *plaincards_);
    }

  }
  // optional uint32 dealerPlayerId = 6;
  if (cached_has_bits & 0x00000010u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_dealerplayerid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HandStartMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HandStartMessage*>(
      &from));
}

void HandStartMessage::MergeFrom(const HandStartMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HandStartMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  seatstates_.MergeFrom(from.seatstates_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_encryptedcards(from._internal_encryptedcards());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_plaincards()->::HandStartMessage_PlainCards::MergeFrom(from._internal_plaincards());
    }
    if (cached_has_bits & 0x00000004u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000008u) {
      smallblind_ = from.smallblind_;
    }
    if (cached_has_bits & 0x00000010u) {
      dealerplayerid_ = from.dealerplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HandStartMessage::CopyFrom(const HandStartMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HandStartMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandStartMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_plaincards()) {
    if (!plaincards_->IsInitialized()) return false;
  }
  return true;
}

void HandStartMessage::InternalSwap(HandStartMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  seatstates_.InternalSwap(&other->seatstates_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encryptedcards_, lhs_arena,
      &other->encryptedcards_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HandStartMessage, dealerplayerid_)
      + sizeof(HandStartMessage::dealerplayerid_)
      - PROTOBUF_FIELD_OFFSET(HandStartMessage, plaincards_)>(
          reinterpret_cast<char*>(&plaincards_),
          reinterpret_cast<char*>(&other->plaincards_));
}

std::string HandStartMessage::GetTypeName() const {
  return "HandStartMessage";
}


// ===================================================================

class PlayersTurnMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayersTurnMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gamestate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

PlayersTurnMessage::PlayersTurnMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayersTurnMessage)
}
PlayersTurnMessage::PlayersTurnMessage(const PlayersTurnMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&gamestate_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gamestate_));
  // @@protoc_insertion_point(copy_constructor:PlayersTurnMessage)
}

inline void PlayersTurnMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gamestate_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(gamestate_));
}

PlayersTurnMessage::~PlayersTurnMessage() {
  // @@protoc_insertion_point(destructor:PlayersTurnMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayersTurnMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayersTurnMessage::ArenaDtor(void* object) {
  PlayersTurnMessage* _this = reinterpret_cast< PlayersTurnMessage* >(object);
  (void)_this;
}
void PlayersTurnMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayersTurnMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayersTurnMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayersTurnMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gamestate_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(gamestate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayersTurnMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameState gameState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameState_IsValid(val))) {
            _internal_set_gamestate(static_cast<::NetGameState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayersTurnMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayersTurnMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .NetGameState gameState = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_gamestate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayersTurnMessage)
  return target;
}

size_t PlayersTurnMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayersTurnMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_gamestate()) {
    // required .NetGameState gameState = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());
  }

  return total_size;
}
size_t PlayersTurnMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayersTurnMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .NetGameState gameState = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayersTurnMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayersTurnMessage*>(
      &from));
}

void PlayersTurnMessage::MergeFrom(const PlayersTurnMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayersTurnMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      gamestate_ = from.gamestate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayersTurnMessage::CopyFrom(const PlayersTurnMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayersTurnMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayersTurnMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PlayersTurnMessage::InternalSwap(PlayersTurnMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayersTurnMessage, gamestate_)
      + sizeof(PlayersTurnMessage::gamestate_)
      - PROTOBUF_FIELD_OFFSET(PlayersTurnMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string PlayersTurnMessage::GetTypeName() const {
  return "PlayersTurnMessage";
}


// ===================================================================

class MyActionRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<MyActionRequestMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_handnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gamestate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_myaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_myrelativebet(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

MyActionRequestMessage::MyActionRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:MyActionRequestMessage)
}
MyActionRequestMessage::MyActionRequestMessage(const MyActionRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&myrelativebet_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(myrelativebet_));
  // @@protoc_insertion_point(copy_constructor:MyActionRequestMessage)
}

inline void MyActionRequestMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&myrelativebet_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(myrelativebet_));
}

MyActionRequestMessage::~MyActionRequestMessage() {
  // @@protoc_insertion_point(destructor:MyActionRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MyActionRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MyActionRequestMessage::ArenaDtor(void* object) {
  MyActionRequestMessage* _this = reinterpret_cast< MyActionRequestMessage* >(object);
  (void)_this;
}
void MyActionRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MyActionRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MyActionRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:MyActionRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&myrelativebet_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(myrelativebet_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MyActionRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 handNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_handnum(&has_bits);
          handnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameState gameState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameState_IsValid(val))) {
            _internal_set_gamestate(static_cast<::NetGameState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .NetPlayerAction myAction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetPlayerAction_IsValid(val))) {
            _internal_set_myaction(static_cast<::NetPlayerAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 myRelativeBet = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_myrelativebet(&has_bits);
          myrelativebet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MyActionRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MyActionRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 handNum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_handnum(), target);
  }

  // required .NetGameState gameState = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_gamestate(), target);
  }

  // required .NetPlayerAction myAction = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_myaction(), target);
  }

  // required uint32 myRelativeBet = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_myrelativebet(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MyActionRequestMessage)
  return target;
}

size_t MyActionRequestMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:MyActionRequestMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_handnum()) {
    // required uint32 handNum = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_handnum());
  }

  if (_internal_has_gamestate()) {
    // required .NetGameState gameState = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());
  }

  if (_internal_has_myaction()) {
    // required .NetPlayerAction myAction = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_myaction());
  }

  if (_internal_has_myrelativebet()) {
    // required uint32 myRelativeBet = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_myrelativebet());
  }

  return total_size;
}
size_t MyActionRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MyActionRequestMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 handNum = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_handnum());

    // required .NetGameState gameState = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());

    // required .NetPlayerAction myAction = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_myaction());

    // required uint32 myRelativeBet = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_myrelativebet());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MyActionRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MyActionRequestMessage*>(
      &from));
}

void MyActionRequestMessage::MergeFrom(const MyActionRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MyActionRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      handnum_ = from.handnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      gamestate_ = from.gamestate_;
    }
    if (cached_has_bits & 0x00000008u) {
      myaction_ = from.myaction_;
    }
    if (cached_has_bits & 0x00000010u) {
      myrelativebet_ = from.myrelativebet_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MyActionRequestMessage::CopyFrom(const MyActionRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MyActionRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MyActionRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void MyActionRequestMessage::InternalSwap(MyActionRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MyActionRequestMessage, myrelativebet_)
      + sizeof(MyActionRequestMessage::myrelativebet_)
      - PROTOBUF_FIELD_OFFSET(MyActionRequestMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string MyActionRequestMessage::GetTypeName() const {
  return "MyActionRequestMessage";
}


// ===================================================================

class YourActionRejectedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<YourActionRejectedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gamestate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_youraction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_yourrelativebet(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rejectionreason(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

YourActionRejectedMessage::YourActionRejectedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:YourActionRejectedMessage)
}
YourActionRejectedMessage::YourActionRejectedMessage(const YourActionRejectedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&rejectionreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(rejectionreason_));
  // @@protoc_insertion_point(copy_constructor:YourActionRejectedMessage)
}

inline void YourActionRejectedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&yourrelativebet_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(yourrelativebet_));
rejectionreason_ = 1;
}

YourActionRejectedMessage::~YourActionRejectedMessage() {
  // @@protoc_insertion_point(destructor:YourActionRejectedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void YourActionRejectedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void YourActionRejectedMessage::ArenaDtor(void* object) {
  YourActionRejectedMessage* _this = reinterpret_cast< YourActionRejectedMessage* >(object);
  (void)_this;
}
void YourActionRejectedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void YourActionRejectedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void YourActionRejectedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:YourActionRejectedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&yourrelativebet_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(yourrelativebet_));
    rejectionreason_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* YourActionRejectedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameState gameState = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameState_IsValid(val))) {
            _internal_set_gamestate(static_cast<::NetGameState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .NetPlayerAction yourAction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetPlayerAction_IsValid(val))) {
            _internal_set_youraction(static_cast<::NetPlayerAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 yourRelativeBet = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_yourrelativebet(&has_bits);
          yourrelativebet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::YourActionRejectedMessage_RejectionReason_IsValid(val))) {
            _internal_set_rejectionreason(static_cast<::YourActionRejectedMessage_RejectionReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* YourActionRejectedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:YourActionRejectedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required .NetGameState gameState = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_gamestate(), target);
  }

  // required .NetPlayerAction yourAction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_youraction(), target);
  }

  // required uint32 yourRelativeBet = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_yourrelativebet(), target);
  }

  // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_rejectionreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:YourActionRejectedMessage)
  return target;
}

size_t YourActionRejectedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:YourActionRejectedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_gamestate()) {
    // required .NetGameState gameState = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());
  }

  if (_internal_has_youraction()) {
    // required .NetPlayerAction yourAction = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_youraction());
  }

  if (_internal_has_yourrelativebet()) {
    // required uint32 yourRelativeBet = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_yourrelativebet());
  }

  if (_internal_has_rejectionreason()) {
    // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rejectionreason());
  }

  return total_size;
}
size_t YourActionRejectedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:YourActionRejectedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required .NetGameState gameState = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());

    // required .NetPlayerAction yourAction = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_youraction());

    // required uint32 yourRelativeBet = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_yourrelativebet());

    // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rejectionreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void YourActionRejectedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const YourActionRejectedMessage*>(
      &from));
}

void YourActionRejectedMessage::MergeFrom(const YourActionRejectedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:YourActionRejectedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      gamestate_ = from.gamestate_;
    }
    if (cached_has_bits & 0x00000004u) {
      youraction_ = from.youraction_;
    }
    if (cached_has_bits & 0x00000008u) {
      yourrelativebet_ = from.yourrelativebet_;
    }
    if (cached_has_bits & 0x00000010u) {
      rejectionreason_ = from.rejectionreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void YourActionRejectedMessage::CopyFrom(const YourActionRejectedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:YourActionRejectedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool YourActionRejectedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void YourActionRejectedMessage::InternalSwap(YourActionRejectedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(YourActionRejectedMessage, yourrelativebet_)
      + sizeof(YourActionRejectedMessage::yourrelativebet_)
      - PROTOBUF_FIELD_OFFSET(YourActionRejectedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
  swap(rejectionreason_, other->rejectionreason_);
}

std::string YourActionRejectedMessage::GetTypeName() const {
  return "YourActionRejectedMessage";
}


// ===================================================================

class PlayersActionDoneMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayersActionDoneMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gamestate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_playeraction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_totalplayerbet(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_playermoney(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_highestset(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_minimumraise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

PlayersActionDoneMessage::PlayersActionDoneMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayersActionDoneMessage)
}
PlayersActionDoneMessage::PlayersActionDoneMessage(const PlayersActionDoneMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&minimumraise_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(minimumraise_));
  // @@protoc_insertion_point(copy_constructor:PlayersActionDoneMessage)
}

inline void PlayersActionDoneMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minimumraise_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(minimumraise_));
}

PlayersActionDoneMessage::~PlayersActionDoneMessage() {
  // @@protoc_insertion_point(destructor:PlayersActionDoneMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayersActionDoneMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayersActionDoneMessage::ArenaDtor(void* object) {
  PlayersActionDoneMessage* _this = reinterpret_cast< PlayersActionDoneMessage* >(object);
  (void)_this;
}
void PlayersActionDoneMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayersActionDoneMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayersActionDoneMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayersActionDoneMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minimumraise_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(minimumraise_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayersActionDoneMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .NetGameState gameState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetGameState_IsValid(val))) {
            _internal_set_gamestate(static_cast<::NetGameState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .NetPlayerAction playerAction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NetPlayerAction_IsValid(val))) {
            _internal_set_playeraction(static_cast<::NetPlayerAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 totalPlayerBet = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_totalplayerbet(&has_bits);
          totalplayerbet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerMoney = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_playermoney(&has_bits);
          playermoney_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 highestSet = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_highestset(&has_bits);
          highestset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 minimumRaise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_minimumraise(&has_bits);
          minimumraise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayersActionDoneMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayersActionDoneMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .NetGameState gameState = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_gamestate(), target);
  }

  // required .NetPlayerAction playerAction = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_playeraction(), target);
  }

  // required uint32 totalPlayerBet = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_totalplayerbet(), target);
  }

  // required uint32 playerMoney = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_playermoney(), target);
  }

  // required uint32 highestSet = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_highestset(), target);
  }

  // required uint32 minimumRaise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_minimumraise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayersActionDoneMessage)
  return target;
}

size_t PlayersActionDoneMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayersActionDoneMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_gamestate()) {
    // required .NetGameState gameState = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());
  }

  if (_internal_has_playeraction()) {
    // required .NetPlayerAction playerAction = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playeraction());
  }

  if (_internal_has_totalplayerbet()) {
    // required uint32 totalPlayerBet = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_totalplayerbet());
  }

  if (_internal_has_playermoney()) {
    // required uint32 playerMoney = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());
  }

  if (_internal_has_highestset()) {
    // required uint32 highestSet = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_highestset());
  }

  if (_internal_has_minimumraise()) {
    // required uint32 minimumRaise = 8;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minimumraise());
  }

  return total_size;
}
size_t PlayersActionDoneMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayersActionDoneMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .NetGameState gameState = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gamestate());

    // required .NetPlayerAction playerAction = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_playeraction());

    // required uint32 totalPlayerBet = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_totalplayerbet());

    // required uint32 playerMoney = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());

    // required uint32 highestSet = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_highestset());

    // required uint32 minimumRaise = 8;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minimumraise());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayersActionDoneMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayersActionDoneMessage*>(
      &from));
}

void PlayersActionDoneMessage::MergeFrom(const PlayersActionDoneMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayersActionDoneMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      gamestate_ = from.gamestate_;
    }
    if (cached_has_bits & 0x00000008u) {
      playeraction_ = from.playeraction_;
    }
    if (cached_has_bits & 0x00000010u) {
      totalplayerbet_ = from.totalplayerbet_;
    }
    if (cached_has_bits & 0x00000020u) {
      playermoney_ = from.playermoney_;
    }
    if (cached_has_bits & 0x00000040u) {
      highestset_ = from.highestset_;
    }
    if (cached_has_bits & 0x00000080u) {
      minimumraise_ = from.minimumraise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayersActionDoneMessage::CopyFrom(const PlayersActionDoneMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayersActionDoneMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayersActionDoneMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PlayersActionDoneMessage::InternalSwap(PlayersActionDoneMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayersActionDoneMessage, minimumraise_)
      + sizeof(PlayersActionDoneMessage::minimumraise_)
      - PROTOBUF_FIELD_OFFSET(PlayersActionDoneMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string PlayersActionDoneMessage::GetTypeName() const {
  return "PlayersActionDoneMessage";
}


// ===================================================================

class DealFlopCardsMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DealFlopCardsMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flopcard1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flopcard2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flopcard3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

DealFlopCardsMessage::DealFlopCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DealFlopCardsMessage)
}
DealFlopCardsMessage::DealFlopCardsMessage(const DealFlopCardsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&flopcard3_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(flopcard3_));
  // @@protoc_insertion_point(copy_constructor:DealFlopCardsMessage)
}

inline void DealFlopCardsMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flopcard3_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(flopcard3_));
}

DealFlopCardsMessage::~DealFlopCardsMessage() {
  // @@protoc_insertion_point(destructor:DealFlopCardsMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DealFlopCardsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DealFlopCardsMessage::ArenaDtor(void* object) {
  DealFlopCardsMessage* _this = reinterpret_cast< DealFlopCardsMessage* >(object);
  (void)_this;
}
void DealFlopCardsMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DealFlopCardsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DealFlopCardsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:DealFlopCardsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flopcard3_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(flopcard3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DealFlopCardsMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 flopCard1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flopcard1(&has_bits);
          flopcard1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 flopCard2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flopcard2(&has_bits);
          flopcard2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 flopCard3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_flopcard3(&has_bits);
          flopcard3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DealFlopCardsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DealFlopCardsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 flopCard1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flopcard1(), target);
  }

  // required uint32 flopCard2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flopcard2(), target);
  }

  // required uint32 flopCard3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_flopcard3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DealFlopCardsMessage)
  return target;
}

size_t DealFlopCardsMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DealFlopCardsMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_flopcard1()) {
    // required uint32 flopCard1 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flopcard1());
  }

  if (_internal_has_flopcard2()) {
    // required uint32 flopCard2 = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flopcard2());
  }

  if (_internal_has_flopcard3()) {
    // required uint32 flopCard3 = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flopcard3());
  }

  return total_size;
}
size_t DealFlopCardsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DealFlopCardsMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 flopCard1 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flopcard1());

    // required uint32 flopCard2 = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flopcard2());

    // required uint32 flopCard3 = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flopcard3());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DealFlopCardsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DealFlopCardsMessage*>(
      &from));
}

void DealFlopCardsMessage::MergeFrom(const DealFlopCardsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DealFlopCardsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      flopcard1_ = from.flopcard1_;
    }
    if (cached_has_bits & 0x00000004u) {
      flopcard2_ = from.flopcard2_;
    }
    if (cached_has_bits & 0x00000008u) {
      flopcard3_ = from.flopcard3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DealFlopCardsMessage::CopyFrom(const DealFlopCardsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DealFlopCardsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DealFlopCardsMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DealFlopCardsMessage::InternalSwap(DealFlopCardsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DealFlopCardsMessage, flopcard3_)
      + sizeof(DealFlopCardsMessage::flopcard3_)
      - PROTOBUF_FIELD_OFFSET(DealFlopCardsMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string DealFlopCardsMessage::GetTypeName() const {
  return "DealFlopCardsMessage";
}


// ===================================================================

class DealTurnCardMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DealTurnCardMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_turncard(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

DealTurnCardMessage::DealTurnCardMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DealTurnCardMessage)
}
DealTurnCardMessage::DealTurnCardMessage(const DealTurnCardMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&turncard_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(turncard_));
  // @@protoc_insertion_point(copy_constructor:DealTurnCardMessage)
}

inline void DealTurnCardMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&turncard_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(turncard_));
}

DealTurnCardMessage::~DealTurnCardMessage() {
  // @@protoc_insertion_point(destructor:DealTurnCardMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DealTurnCardMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DealTurnCardMessage::ArenaDtor(void* object) {
  DealTurnCardMessage* _this = reinterpret_cast< DealTurnCardMessage* >(object);
  (void)_this;
}
void DealTurnCardMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DealTurnCardMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DealTurnCardMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:DealTurnCardMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&turncard_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(turncard_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DealTurnCardMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 turnCard = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_turncard(&has_bits);
          turncard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DealTurnCardMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DealTurnCardMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 turnCard = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_turncard(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DealTurnCardMessage)
  return target;
}

size_t DealTurnCardMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DealTurnCardMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_turncard()) {
    // required uint32 turnCard = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_turncard());
  }

  return total_size;
}
size_t DealTurnCardMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DealTurnCardMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 turnCard = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_turncard());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DealTurnCardMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DealTurnCardMessage*>(
      &from));
}

void DealTurnCardMessage::MergeFrom(const DealTurnCardMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DealTurnCardMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      turncard_ = from.turncard_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DealTurnCardMessage::CopyFrom(const DealTurnCardMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DealTurnCardMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DealTurnCardMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DealTurnCardMessage::InternalSwap(DealTurnCardMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DealTurnCardMessage, turncard_)
      + sizeof(DealTurnCardMessage::turncard_)
      - PROTOBUF_FIELD_OFFSET(DealTurnCardMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string DealTurnCardMessage::GetTypeName() const {
  return "DealTurnCardMessage";
}


// ===================================================================

class DealRiverCardMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DealRiverCardMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rivercard(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

DealRiverCardMessage::DealRiverCardMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DealRiverCardMessage)
}
DealRiverCardMessage::DealRiverCardMessage(const DealRiverCardMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&rivercard_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(rivercard_));
  // @@protoc_insertion_point(copy_constructor:DealRiverCardMessage)
}

inline void DealRiverCardMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rivercard_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(rivercard_));
}

DealRiverCardMessage::~DealRiverCardMessage() {
  // @@protoc_insertion_point(destructor:DealRiverCardMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DealRiverCardMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DealRiverCardMessage::ArenaDtor(void* object) {
  DealRiverCardMessage* _this = reinterpret_cast< DealRiverCardMessage* >(object);
  (void)_this;
}
void DealRiverCardMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DealRiverCardMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DealRiverCardMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:DealRiverCardMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rivercard_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(rivercard_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DealRiverCardMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 riverCard = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rivercard(&has_bits);
          rivercard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DealRiverCardMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DealRiverCardMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 riverCard = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rivercard(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DealRiverCardMessage)
  return target;
}

size_t DealRiverCardMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DealRiverCardMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_rivercard()) {
    // required uint32 riverCard = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rivercard());
  }

  return total_size;
}
size_t DealRiverCardMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DealRiverCardMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 riverCard = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rivercard());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DealRiverCardMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DealRiverCardMessage*>(
      &from));
}

void DealRiverCardMessage::MergeFrom(const DealRiverCardMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DealRiverCardMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      rivercard_ = from.rivercard_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DealRiverCardMessage::CopyFrom(const DealRiverCardMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DealRiverCardMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DealRiverCardMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DealRiverCardMessage::InternalSwap(DealRiverCardMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DealRiverCardMessage, rivercard_)
      + sizeof(DealRiverCardMessage::rivercard_)
      - PROTOBUF_FIELD_OFFSET(DealRiverCardMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string DealRiverCardMessage::GetTypeName() const {
  return "DealRiverCardMessage";
}


// ===================================================================

class AllInShowCardsMessage_PlayerAllIn::_Internal {
 public:
  using HasBits = decltype(std::declval<AllInShowCardsMessage_PlayerAllIn>()._has_bits_);
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allincard1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_allincard2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AllInShowCardsMessage_PlayerAllIn::AllInShowCardsMessage_PlayerAllIn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AllInShowCardsMessage.PlayerAllIn)
}
AllInShowCardsMessage_PlayerAllIn::AllInShowCardsMessage_PlayerAllIn(const AllInShowCardsMessage_PlayerAllIn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&playerid_, &from.playerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&allincard2_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(allincard2_));
  // @@protoc_insertion_point(copy_constructor:AllInShowCardsMessage.PlayerAllIn)
}

inline void AllInShowCardsMessage_PlayerAllIn::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&playerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allincard2_) -
    reinterpret_cast<char*>(&playerid_)) + sizeof(allincard2_));
}

AllInShowCardsMessage_PlayerAllIn::~AllInShowCardsMessage_PlayerAllIn() {
  // @@protoc_insertion_point(destructor:AllInShowCardsMessage.PlayerAllIn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AllInShowCardsMessage_PlayerAllIn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllInShowCardsMessage_PlayerAllIn::ArenaDtor(void* object) {
  AllInShowCardsMessage_PlayerAllIn* _this = reinterpret_cast< AllInShowCardsMessage_PlayerAllIn* >(object);
  (void)_this;
}
void AllInShowCardsMessage_PlayerAllIn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AllInShowCardsMessage_PlayerAllIn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AllInShowCardsMessage_PlayerAllIn::Clear() {
// @@protoc_insertion_point(message_clear_start:AllInShowCardsMessage.PlayerAllIn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&playerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allincard2_) -
        reinterpret_cast<char*>(&playerid_)) + sizeof(allincard2_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllInShowCardsMessage_PlayerAllIn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 allInCard1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_allincard1(&has_bits);
          allincard1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 allInCard2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_allincard2(&has_bits);
          allincard2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllInShowCardsMessage_PlayerAllIn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AllInShowCardsMessage.PlayerAllIn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 playerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_playerid(), target);
  }

  // required uint32 allInCard1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_allincard1(), target);
  }

  // required uint32 allInCard2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_allincard2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AllInShowCardsMessage.PlayerAllIn)
  return target;
}

size_t AllInShowCardsMessage_PlayerAllIn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AllInShowCardsMessage.PlayerAllIn)
  size_t total_size = 0;

  if (_internal_has_playerid()) {
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_allincard1()) {
    // required uint32 allInCard1 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_allincard1());
  }

  if (_internal_has_allincard2()) {
    // required uint32 allInCard2 = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_allincard2());
  }

  return total_size;
}
size_t AllInShowCardsMessage_PlayerAllIn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AllInShowCardsMessage.PlayerAllIn)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 playerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required uint32 allInCard1 = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_allincard1());

    // required uint32 allInCard2 = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_allincard2());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllInShowCardsMessage_PlayerAllIn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllInShowCardsMessage_PlayerAllIn*>(
      &from));
}

void AllInShowCardsMessage_PlayerAllIn::MergeFrom(const AllInShowCardsMessage_PlayerAllIn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AllInShowCardsMessage.PlayerAllIn)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      allincard1_ = from.allincard1_;
    }
    if (cached_has_bits & 0x00000004u) {
      allincard2_ = from.allincard2_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllInShowCardsMessage_PlayerAllIn::CopyFrom(const AllInShowCardsMessage_PlayerAllIn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AllInShowCardsMessage.PlayerAllIn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllInShowCardsMessage_PlayerAllIn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AllInShowCardsMessage_PlayerAllIn::InternalSwap(AllInShowCardsMessage_PlayerAllIn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllInShowCardsMessage_PlayerAllIn, allincard2_)
      + sizeof(AllInShowCardsMessage_PlayerAllIn::allincard2_)
      - PROTOBUF_FIELD_OFFSET(AllInShowCardsMessage_PlayerAllIn, playerid_)>(
          reinterpret_cast<char*>(&playerid_),
          reinterpret_cast<char*>(&other->playerid_));
}

std::string AllInShowCardsMessage_PlayerAllIn::GetTypeName() const {
  return "AllInShowCardsMessage.PlayerAllIn";
}


// ===================================================================

class AllInShowCardsMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AllInShowCardsMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AllInShowCardsMessage::AllInShowCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  playersallin_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AllInShowCardsMessage)
}
AllInShowCardsMessage::AllInShowCardsMessage(const AllInShowCardsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      playersallin_(from.playersallin_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  gameid_ = from.gameid_;
  // @@protoc_insertion_point(copy_constructor:AllInShowCardsMessage)
}

inline void AllInShowCardsMessage::SharedCtor() {
gameid_ = 0u;
}

AllInShowCardsMessage::~AllInShowCardsMessage() {
  // @@protoc_insertion_point(destructor:AllInShowCardsMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AllInShowCardsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllInShowCardsMessage::ArenaDtor(void* object) {
  AllInShowCardsMessage* _this = reinterpret_cast< AllInShowCardsMessage* >(object);
  (void)_this;
}
void AllInShowCardsMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AllInShowCardsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AllInShowCardsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AllInShowCardsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  playersallin_.Clear();
  gameid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllInShowCardsMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_playersallin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllInShowCardsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AllInShowCardsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_playersallin_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_playersallin(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AllInShowCardsMessage)
  return target;
}

size_t AllInShowCardsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AllInShowCardsMessage)
  size_t total_size = 0;

  // required uint32 gameId = 1;
  if (_internal_has_gameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
  total_size += 1UL * this->_internal_playersallin_size();
  for (const auto& msg : this->playersallin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllInShowCardsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllInShowCardsMessage*>(
      &from));
}

void AllInShowCardsMessage::MergeFrom(const AllInShowCardsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AllInShowCardsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  playersallin_.MergeFrom(from.playersallin_);
  if (from._internal_has_gameid()) {
    _internal_set_gameid(from._internal_gameid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllInShowCardsMessage::CopyFrom(const AllInShowCardsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AllInShowCardsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllInShowCardsMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(playersallin_))
    return false;
  return true;
}

void AllInShowCardsMessage::InternalSwap(AllInShowCardsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  playersallin_.InternalSwap(&other->playersallin_);
  swap(gameid_, other->gameid_);
}

std::string AllInShowCardsMessage::GetTypeName() const {
  return "AllInShowCardsMessage";
}


// ===================================================================

class EndOfHandShowCardsMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<EndOfHandShowCardsMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EndOfHandShowCardsMessage::EndOfHandShowCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  playerresults_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:EndOfHandShowCardsMessage)
}
EndOfHandShowCardsMessage::EndOfHandShowCardsMessage(const EndOfHandShowCardsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      playerresults_(from.playerresults_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  gameid_ = from.gameid_;
  // @@protoc_insertion_point(copy_constructor:EndOfHandShowCardsMessage)
}

inline void EndOfHandShowCardsMessage::SharedCtor() {
gameid_ = 0u;
}

EndOfHandShowCardsMessage::~EndOfHandShowCardsMessage() {
  // @@protoc_insertion_point(destructor:EndOfHandShowCardsMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EndOfHandShowCardsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndOfHandShowCardsMessage::ArenaDtor(void* object) {
  EndOfHandShowCardsMessage* _this = reinterpret_cast< EndOfHandShowCardsMessage* >(object);
  (void)_this;
}
void EndOfHandShowCardsMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EndOfHandShowCardsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EndOfHandShowCardsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:EndOfHandShowCardsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  playerresults_.Clear();
  gameid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndOfHandShowCardsMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PlayerResult playerResults = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_playerresults(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndOfHandShowCardsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EndOfHandShowCardsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // repeated .PlayerResult playerResults = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_playerresults_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_playerresults(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EndOfHandShowCardsMessage)
  return target;
}

size_t EndOfHandShowCardsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EndOfHandShowCardsMessage)
  size_t total_size = 0;

  // required uint32 gameId = 1;
  if (_internal_has_gameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PlayerResult playerResults = 2;
  total_size += 1UL * this->_internal_playerresults_size();
  for (const auto& msg : this->playerresults_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndOfHandShowCardsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EndOfHandShowCardsMessage*>(
      &from));
}

void EndOfHandShowCardsMessage::MergeFrom(const EndOfHandShowCardsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:EndOfHandShowCardsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  playerresults_.MergeFrom(from.playerresults_);
  if (from._internal_has_gameid()) {
    _internal_set_gameid(from._internal_gameid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndOfHandShowCardsMessage::CopyFrom(const EndOfHandShowCardsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EndOfHandShowCardsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndOfHandShowCardsMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(playerresults_))
    return false;
  return true;
}

void EndOfHandShowCardsMessage::InternalSwap(EndOfHandShowCardsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  playerresults_.InternalSwap(&other->playerresults_);
  swap(gameid_, other->gameid_);
}

std::string EndOfHandShowCardsMessage::GetTypeName() const {
  return "EndOfHandShowCardsMessage";
}


// ===================================================================

class EndOfHandHideCardsMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<EndOfHandHideCardsMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_moneywon(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_playermoney(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

EndOfHandHideCardsMessage::EndOfHandHideCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:EndOfHandHideCardsMessage)
}
EndOfHandHideCardsMessage::EndOfHandHideCardsMessage(const EndOfHandHideCardsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playermoney_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playermoney_));
  // @@protoc_insertion_point(copy_constructor:EndOfHandHideCardsMessage)
}

inline void EndOfHandHideCardsMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playermoney_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playermoney_));
}

EndOfHandHideCardsMessage::~EndOfHandHideCardsMessage() {
  // @@protoc_insertion_point(destructor:EndOfHandHideCardsMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EndOfHandHideCardsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndOfHandHideCardsMessage::ArenaDtor(void* object) {
  EndOfHandHideCardsMessage* _this = reinterpret_cast< EndOfHandHideCardsMessage* >(object);
  (void)_this;
}
void EndOfHandHideCardsMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EndOfHandHideCardsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EndOfHandHideCardsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:EndOfHandHideCardsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playermoney_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playermoney_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndOfHandHideCardsMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 moneyWon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_moneywon(&has_bits);
          moneywon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerMoney = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_playermoney(&has_bits);
          playermoney_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndOfHandHideCardsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EndOfHandHideCardsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required uint32 moneyWon = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_moneywon(), target);
  }

  // required uint32 playerMoney = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_playermoney(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EndOfHandHideCardsMessage)
  return target;
}

size_t EndOfHandHideCardsMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:EndOfHandHideCardsMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_moneywon()) {
    // required uint32 moneyWon = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_moneywon());
  }

  if (_internal_has_playermoney()) {
    // required uint32 playerMoney = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());
  }

  return total_size;
}
size_t EndOfHandHideCardsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EndOfHandHideCardsMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required uint32 moneyWon = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_moneywon());

    // required uint32 playerMoney = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playermoney());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndOfHandHideCardsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EndOfHandHideCardsMessage*>(
      &from));
}

void EndOfHandHideCardsMessage::MergeFrom(const EndOfHandHideCardsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:EndOfHandHideCardsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      moneywon_ = from.moneywon_;
    }
    if (cached_has_bits & 0x00000008u) {
      playermoney_ = from.playermoney_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndOfHandHideCardsMessage::CopyFrom(const EndOfHandHideCardsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EndOfHandHideCardsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndOfHandHideCardsMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EndOfHandHideCardsMessage::InternalSwap(EndOfHandHideCardsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EndOfHandHideCardsMessage, playermoney_)
      + sizeof(EndOfHandHideCardsMessage::playermoney_)
      - PROTOBUF_FIELD_OFFSET(EndOfHandHideCardsMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string EndOfHandHideCardsMessage::GetTypeName() const {
  return "EndOfHandHideCardsMessage";
}


// ===================================================================

class ShowMyCardsRequestMessage::_Internal {
 public:
};

ShowMyCardsRequestMessage::ShowMyCardsRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ShowMyCardsRequestMessage)
}
ShowMyCardsRequestMessage::ShowMyCardsRequestMessage(const ShowMyCardsRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ShowMyCardsRequestMessage)
}

inline void ShowMyCardsRequestMessage::SharedCtor() {
}

ShowMyCardsRequestMessage::~ShowMyCardsRequestMessage() {
  // @@protoc_insertion_point(destructor:ShowMyCardsRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ShowMyCardsRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShowMyCardsRequestMessage::ArenaDtor(void* object) {
  ShowMyCardsRequestMessage* _this = reinterpret_cast< ShowMyCardsRequestMessage* >(object);
  (void)_this;
}
void ShowMyCardsRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ShowMyCardsRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowMyCardsRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ShowMyCardsRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ShowMyCardsRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowMyCardsRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShowMyCardsRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShowMyCardsRequestMessage)
  return target;
}

size_t ShowMyCardsRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ShowMyCardsRequestMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowMyCardsRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ShowMyCardsRequestMessage*>(
      &from));
}

void ShowMyCardsRequestMessage::MergeFrom(const ShowMyCardsRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ShowMyCardsRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowMyCardsRequestMessage::CopyFrom(const ShowMyCardsRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ShowMyCardsRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowMyCardsRequestMessage::IsInitialized() const {
  return true;
}

void ShowMyCardsRequestMessage::InternalSwap(ShowMyCardsRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ShowMyCardsRequestMessage::GetTypeName() const {
  return "ShowMyCardsRequestMessage";
}


// ===================================================================

class AfterHandShowCardsMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AfterHandShowCardsMessage>()._has_bits_);
  static const ::PlayerResult& playerresult(const AfterHandShowCardsMessage* msg);
  static void set_has_playerresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PlayerResult&
AfterHandShowCardsMessage::_Internal::playerresult(const AfterHandShowCardsMessage* msg) {
  return *msg->playerresult_;
}
AfterHandShowCardsMessage::AfterHandShowCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AfterHandShowCardsMessage)
}
AfterHandShowCardsMessage::AfterHandShowCardsMessage(const AfterHandShowCardsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_playerresult()) {
    playerresult_ = new ::PlayerResult(*from.playerresult_);
  } else {
    playerresult_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:AfterHandShowCardsMessage)
}

inline void AfterHandShowCardsMessage::SharedCtor() {
playerresult_ = nullptr;
}

AfterHandShowCardsMessage::~AfterHandShowCardsMessage() {
  // @@protoc_insertion_point(destructor:AfterHandShowCardsMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AfterHandShowCardsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete playerresult_;
}

void AfterHandShowCardsMessage::ArenaDtor(void* object) {
  AfterHandShowCardsMessage* _this = reinterpret_cast< AfterHandShowCardsMessage* >(object);
  (void)_this;
}
void AfterHandShowCardsMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AfterHandShowCardsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AfterHandShowCardsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AfterHandShowCardsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(playerresult_ != nullptr);
    playerresult_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AfterHandShowCardsMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PlayerResult playerResult = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerresult(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AfterHandShowCardsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AfterHandShowCardsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PlayerResult playerResult = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::playerresult(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AfterHandShowCardsMessage)
  return target;
}

size_t AfterHandShowCardsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AfterHandShowCardsMessage)
  size_t total_size = 0;

  // required .PlayerResult playerResult = 1;
  if (_internal_has_playerresult()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *playerresult_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AfterHandShowCardsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AfterHandShowCardsMessage*>(
      &from));
}

void AfterHandShowCardsMessage::MergeFrom(const AfterHandShowCardsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AfterHandShowCardsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playerresult()) {
    _internal_mutable_playerresult()->::PlayerResult::MergeFrom(from._internal_playerresult());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AfterHandShowCardsMessage::CopyFrom(const AfterHandShowCardsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AfterHandShowCardsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AfterHandShowCardsMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_playerresult()) {
    if (!playerresult_->IsInitialized()) return false;
  }
  return true;
}

void AfterHandShowCardsMessage::InternalSwap(AfterHandShowCardsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(playerresult_, other->playerresult_);
}

std::string AfterHandShowCardsMessage::GetTypeName() const {
  return "AfterHandShowCardsMessage";
}


// ===================================================================

class EndOfGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<EndOfGameMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_winnerplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

EndOfGameMessage::EndOfGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:EndOfGameMessage)
}
EndOfGameMessage::EndOfGameMessage(const EndOfGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&winnerplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(winnerplayerid_));
  // @@protoc_insertion_point(copy_constructor:EndOfGameMessage)
}

inline void EndOfGameMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&winnerplayerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(winnerplayerid_));
}

EndOfGameMessage::~EndOfGameMessage() {
  // @@protoc_insertion_point(destructor:EndOfGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EndOfGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndOfGameMessage::ArenaDtor(void* object) {
  EndOfGameMessage* _this = reinterpret_cast< EndOfGameMessage* >(object);
  (void)_this;
}
void EndOfGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EndOfGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EndOfGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:EndOfGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&winnerplayerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(winnerplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndOfGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 winnerPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_winnerplayerid(&has_bits);
          winnerplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndOfGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EndOfGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 winnerPlayerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_winnerplayerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EndOfGameMessage)
  return target;
}

size_t EndOfGameMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:EndOfGameMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_winnerplayerid()) {
    // required uint32 winnerPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_winnerplayerid());
  }

  return total_size;
}
size_t EndOfGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EndOfGameMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 winnerPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_winnerplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndOfGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EndOfGameMessage*>(
      &from));
}

void EndOfGameMessage::MergeFrom(const EndOfGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:EndOfGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      winnerplayerid_ = from.winnerplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndOfGameMessage::CopyFrom(const EndOfGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EndOfGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndOfGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EndOfGameMessage::InternalSwap(EndOfGameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EndOfGameMessage, winnerplayerid_)
      + sizeof(EndOfGameMessage::winnerplayerid_)
      - PROTOBUF_FIELD_OFFSET(EndOfGameMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string EndOfGameMessage::GetTypeName() const {
  return "EndOfGameMessage";
}


// ===================================================================

class PlayerIdChangedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerIdChangedMessage>()._has_bits_);
  static void set_has_oldplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PlayerIdChangedMessage::PlayerIdChangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PlayerIdChangedMessage)
}
PlayerIdChangedMessage::PlayerIdChangedMessage(const PlayerIdChangedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&oldplayerid_, &from.oldplayerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&newplayerid_) -
    reinterpret_cast<char*>(&oldplayerid_)) + sizeof(newplayerid_));
  // @@protoc_insertion_point(copy_constructor:PlayerIdChangedMessage)
}

inline void PlayerIdChangedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&oldplayerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&newplayerid_) -
    reinterpret_cast<char*>(&oldplayerid_)) + sizeof(newplayerid_));
}

PlayerIdChangedMessage::~PlayerIdChangedMessage() {
  // @@protoc_insertion_point(destructor:PlayerIdChangedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PlayerIdChangedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerIdChangedMessage::ArenaDtor(void* object) {
  PlayerIdChangedMessage* _this = reinterpret_cast< PlayerIdChangedMessage* >(object);
  (void)_this;
}
void PlayerIdChangedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerIdChangedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerIdChangedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PlayerIdChangedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&oldplayerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&newplayerid_) -
        reinterpret_cast<char*>(&oldplayerid_)) + sizeof(newplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PlayerIdChangedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 oldPlayerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_oldplayerid(&has_bits);
          oldplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 newPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_newplayerid(&has_bits);
          newplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerIdChangedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PlayerIdChangedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 oldPlayerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_oldplayerid(), target);
  }

  // required uint32 newPlayerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_newplayerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PlayerIdChangedMessage)
  return target;
}

size_t PlayerIdChangedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PlayerIdChangedMessage)
  size_t total_size = 0;

  if (_internal_has_oldplayerid()) {
    // required uint32 oldPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_oldplayerid());
  }

  if (_internal_has_newplayerid()) {
    // required uint32 newPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_newplayerid());
  }

  return total_size;
}
size_t PlayerIdChangedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PlayerIdChangedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 oldPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_oldplayerid());

    // required uint32 newPlayerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_newplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerIdChangedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PlayerIdChangedMessage*>(
      &from));
}

void PlayerIdChangedMessage::MergeFrom(const PlayerIdChangedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PlayerIdChangedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      oldplayerid_ = from.oldplayerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      newplayerid_ = from.newplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlayerIdChangedMessage::CopyFrom(const PlayerIdChangedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PlayerIdChangedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerIdChangedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PlayerIdChangedMessage::InternalSwap(PlayerIdChangedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerIdChangedMessage, newplayerid_)
      + sizeof(PlayerIdChangedMessage::newplayerid_)
      - PROTOBUF_FIELD_OFFSET(PlayerIdChangedMessage, oldplayerid_)>(
          reinterpret_cast<char*>(&oldplayerid_),
          reinterpret_cast<char*>(&other->oldplayerid_));
}

std::string PlayerIdChangedMessage::GetTypeName() const {
  return "PlayerIdChangedMessage";
}


// ===================================================================

class AskKickPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AskKickPlayerMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AskKickPlayerMessage::AskKickPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AskKickPlayerMessage)
}
AskKickPlayerMessage::AskKickPlayerMessage(const AskKickPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  // @@protoc_insertion_point(copy_constructor:AskKickPlayerMessage)
}

inline void AskKickPlayerMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&playerid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
}

AskKickPlayerMessage::~AskKickPlayerMessage() {
  // @@protoc_insertion_point(destructor:AskKickPlayerMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AskKickPlayerMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AskKickPlayerMessage::ArenaDtor(void* object) {
  AskKickPlayerMessage* _this = reinterpret_cast< AskKickPlayerMessage* >(object);
  (void)_this;
}
void AskKickPlayerMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AskKickPlayerMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AskKickPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AskKickPlayerMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&playerid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(playerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AskKickPlayerMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AskKickPlayerMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AskKickPlayerMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AskKickPlayerMessage)
  return target;
}

size_t AskKickPlayerMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AskKickPlayerMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  return total_size;
}
size_t AskKickPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AskKickPlayerMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AskKickPlayerMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AskKickPlayerMessage*>(
      &from));
}

void AskKickPlayerMessage::MergeFrom(const AskKickPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AskKickPlayerMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AskKickPlayerMessage::CopyFrom(const AskKickPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AskKickPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AskKickPlayerMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AskKickPlayerMessage::InternalSwap(AskKickPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AskKickPlayerMessage, playerid_)
      + sizeof(AskKickPlayerMessage::playerid_)
      - PROTOBUF_FIELD_OFFSET(AskKickPlayerMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string AskKickPlayerMessage::GetTypeName() const {
  return "AskKickPlayerMessage";
}


// ===================================================================

class AskKickDeniedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AskKickDeniedMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_kickdeniedreason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AskKickDeniedMessage::AskKickDeniedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AskKickDeniedMessage)
}
AskKickDeniedMessage::AskKickDeniedMessage(const AskKickDeniedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&kickdeniedreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(kickdeniedreason_));
  // @@protoc_insertion_point(copy_constructor:AskKickDeniedMessage)
}

inline void AskKickDeniedMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&kickdeniedreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(kickdeniedreason_));
}

AskKickDeniedMessage::~AskKickDeniedMessage() {
  // @@protoc_insertion_point(destructor:AskKickDeniedMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AskKickDeniedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AskKickDeniedMessage::ArenaDtor(void* object) {
  AskKickDeniedMessage* _this = reinterpret_cast< AskKickDeniedMessage* >(object);
  (void)_this;
}
void AskKickDeniedMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AskKickDeniedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AskKickDeniedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AskKickDeniedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&kickdeniedreason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(kickdeniedreason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AskKickDeniedMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::AskKickDeniedMessage_KickDeniedReason_IsValid(val))) {
            _internal_set_kickdeniedreason(static_cast<::AskKickDeniedMessage_KickDeniedReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AskKickDeniedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AskKickDeniedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 playerId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_kickdeniedreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AskKickDeniedMessage)
  return target;
}

size_t AskKickDeniedMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AskKickDeniedMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_playerid()) {
    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
  }

  if (_internal_has_kickdeniedreason()) {
    // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kickdeniedreason());
  }

  return total_size;
}
size_t AskKickDeniedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AskKickDeniedMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 playerId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());

    // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kickdeniedreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AskKickDeniedMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AskKickDeniedMessage*>(
      &from));
}

void AskKickDeniedMessage::MergeFrom(const AskKickDeniedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AskKickDeniedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      kickdeniedreason_ = from.kickdeniedreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AskKickDeniedMessage::CopyFrom(const AskKickDeniedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AskKickDeniedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AskKickDeniedMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AskKickDeniedMessage::InternalSwap(AskKickDeniedMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AskKickDeniedMessage, kickdeniedreason_)
      + sizeof(AskKickDeniedMessage::kickdeniedreason_)
      - PROTOBUF_FIELD_OFFSET(AskKickDeniedMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string AskKickDeniedMessage::GetTypeName() const {
  return "AskKickDeniedMessage";
}


// ===================================================================

class StartKickPetitionMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<StartKickPetitionMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_petitionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_proposingplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kickplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kicktimeoutsec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_numvotesneededtokick(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

StartKickPetitionMessage::StartKickPetitionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StartKickPetitionMessage)
}
StartKickPetitionMessage::StartKickPetitionMessage(const StartKickPetitionMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&numvotesneededtokick_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(numvotesneededtokick_));
  // @@protoc_insertion_point(copy_constructor:StartKickPetitionMessage)
}

inline void StartKickPetitionMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&numvotesneededtokick_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(numvotesneededtokick_));
}

StartKickPetitionMessage::~StartKickPetitionMessage() {
  // @@protoc_insertion_point(destructor:StartKickPetitionMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StartKickPetitionMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StartKickPetitionMessage::ArenaDtor(void* object) {
  StartKickPetitionMessage* _this = reinterpret_cast< StartKickPetitionMessage* >(object);
  (void)_this;
}
void StartKickPetitionMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StartKickPetitionMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StartKickPetitionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:StartKickPetitionMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&numvotesneededtokick_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(numvotesneededtokick_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StartKickPetitionMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 petitionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_petitionid(&has_bits);
          petitionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 proposingPlayerId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_proposingplayerid(&has_bits);
          proposingplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 kickPlayerId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_kickplayerid(&has_bits);
          kickplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 kickTimeoutSec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_kicktimeoutsec(&has_bits);
          kicktimeoutsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numVotesNeededToKick = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_numvotesneededtokick(&has_bits);
          numvotesneededtokick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartKickPetitionMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StartKickPetitionMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 petitionId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_petitionid(), target);
  }

  // required uint32 proposingPlayerId = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_proposingplayerid(), target);
  }

  // required uint32 kickPlayerId = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_kickplayerid(), target);
  }

  // required uint32 kickTimeoutSec = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_kicktimeoutsec(), target);
  }

  // required uint32 numVotesNeededToKick = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_numvotesneededtokick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StartKickPetitionMessage)
  return target;
}

size_t StartKickPetitionMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StartKickPetitionMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_petitionid()) {
    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());
  }

  if (_internal_has_proposingplayerid()) {
    // required uint32 proposingPlayerId = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_proposingplayerid());
  }

  if (_internal_has_kickplayerid()) {
    // required uint32 kickPlayerId = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_kickplayerid());
  }

  if (_internal_has_kicktimeoutsec()) {
    // required uint32 kickTimeoutSec = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_kicktimeoutsec());
  }

  if (_internal_has_numvotesneededtokick()) {
    // required uint32 numVotesNeededToKick = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesneededtokick());
  }

  return total_size;
}
size_t StartKickPetitionMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StartKickPetitionMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());

    // required uint32 proposingPlayerId = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_proposingplayerid());

    // required uint32 kickPlayerId = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_kickplayerid());

    // required uint32 kickTimeoutSec = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_kicktimeoutsec());

    // required uint32 numVotesNeededToKick = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesneededtokick());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartKickPetitionMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StartKickPetitionMessage*>(
      &from));
}

void StartKickPetitionMessage::MergeFrom(const StartKickPetitionMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StartKickPetitionMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      petitionid_ = from.petitionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      proposingplayerid_ = from.proposingplayerid_;
    }
    if (cached_has_bits & 0x00000008u) {
      kickplayerid_ = from.kickplayerid_;
    }
    if (cached_has_bits & 0x00000010u) {
      kicktimeoutsec_ = from.kicktimeoutsec_;
    }
    if (cached_has_bits & 0x00000020u) {
      numvotesneededtokick_ = from.numvotesneededtokick_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StartKickPetitionMessage::CopyFrom(const StartKickPetitionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StartKickPetitionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartKickPetitionMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StartKickPetitionMessage::InternalSwap(StartKickPetitionMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartKickPetitionMessage, numvotesneededtokick_)
      + sizeof(StartKickPetitionMessage::numvotesneededtokick_)
      - PROTOBUF_FIELD_OFFSET(StartKickPetitionMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string StartKickPetitionMessage::GetTypeName() const {
  return "StartKickPetitionMessage";
}


// ===================================================================

class VoteKickRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<VoteKickRequestMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_petitionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_votekick(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

VoteKickRequestMessage::VoteKickRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:VoteKickRequestMessage)
}
VoteKickRequestMessage::VoteKickRequestMessage(const VoteKickRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&votekick_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(votekick_));
  // @@protoc_insertion_point(copy_constructor:VoteKickRequestMessage)
}

inline void VoteKickRequestMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&votekick_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(votekick_));
}

VoteKickRequestMessage::~VoteKickRequestMessage() {
  // @@protoc_insertion_point(destructor:VoteKickRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void VoteKickRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VoteKickRequestMessage::ArenaDtor(void* object) {
  VoteKickRequestMessage* _this = reinterpret_cast< VoteKickRequestMessage* >(object);
  (void)_this;
}
void VoteKickRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VoteKickRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VoteKickRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:VoteKickRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&votekick_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(votekick_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VoteKickRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 petitionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_petitionid(&has_bits);
          petitionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool voteKick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_votekick(&has_bits);
          votekick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VoteKickRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VoteKickRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 petitionId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_petitionid(), target);
  }

  // required bool voteKick = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_votekick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VoteKickRequestMessage)
  return target;
}

size_t VoteKickRequestMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VoteKickRequestMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_petitionid()) {
    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());
  }

  if (_internal_has_votekick()) {
    // required bool voteKick = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t VoteKickRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VoteKickRequestMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());

    // required bool voteKick = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VoteKickRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VoteKickRequestMessage*>(
      &from));
}

void VoteKickRequestMessage::MergeFrom(const VoteKickRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:VoteKickRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      petitionid_ = from.petitionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      votekick_ = from.votekick_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VoteKickRequestMessage::CopyFrom(const VoteKickRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VoteKickRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoteKickRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void VoteKickRequestMessage::InternalSwap(VoteKickRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoteKickRequestMessage, votekick_)
      + sizeof(VoteKickRequestMessage::votekick_)
      - PROTOBUF_FIELD_OFFSET(VoteKickRequestMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string VoteKickRequestMessage::GetTypeName() const {
  return "VoteKickRequestMessage";
}


// ===================================================================

class VoteKickReplyMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<VoteKickReplyMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_petitionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_votekickreplytype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

VoteKickReplyMessage::VoteKickReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:VoteKickReplyMessage)
}
VoteKickReplyMessage::VoteKickReplyMessage(const VoteKickReplyMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&votekickreplytype_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(votekickreplytype_));
  // @@protoc_insertion_point(copy_constructor:VoteKickReplyMessage)
}

inline void VoteKickReplyMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&votekickreplytype_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(votekickreplytype_));
}

VoteKickReplyMessage::~VoteKickReplyMessage() {
  // @@protoc_insertion_point(destructor:VoteKickReplyMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void VoteKickReplyMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VoteKickReplyMessage::ArenaDtor(void* object) {
  VoteKickReplyMessage* _this = reinterpret_cast< VoteKickReplyMessage* >(object);
  (void)_this;
}
void VoteKickReplyMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VoteKickReplyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VoteKickReplyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:VoteKickReplyMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&votekickreplytype_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(votekickreplytype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VoteKickReplyMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 petitionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_petitionid(&has_bits);
          petitionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::VoteKickReplyMessage_VoteKickReplyType_IsValid(val))) {
            _internal_set_votekickreplytype(static_cast<::VoteKickReplyMessage_VoteKickReplyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VoteKickReplyMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VoteKickReplyMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 petitionId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_petitionid(), target);
  }

  // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_votekickreplytype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VoteKickReplyMessage)
  return target;
}

size_t VoteKickReplyMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VoteKickReplyMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_petitionid()) {
    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());
  }

  if (_internal_has_votekickreplytype()) {
    // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_votekickreplytype());
  }

  return total_size;
}
size_t VoteKickReplyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VoteKickReplyMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());

    // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_votekickreplytype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VoteKickReplyMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VoteKickReplyMessage*>(
      &from));
}

void VoteKickReplyMessage::MergeFrom(const VoteKickReplyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:VoteKickReplyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      petitionid_ = from.petitionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      votekickreplytype_ = from.votekickreplytype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VoteKickReplyMessage::CopyFrom(const VoteKickReplyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VoteKickReplyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoteKickReplyMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void VoteKickReplyMessage::InternalSwap(VoteKickReplyMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoteKickReplyMessage, votekickreplytype_)
      + sizeof(VoteKickReplyMessage::votekickreplytype_)
      - PROTOBUF_FIELD_OFFSET(VoteKickReplyMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string VoteKickReplyMessage::GetTypeName() const {
  return "VoteKickReplyMessage";
}


// ===================================================================

class KickPetitionUpdateMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<KickPetitionUpdateMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_petitionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_numvotesagainstkicking(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numvotesinfavourofkicking(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_numvotesneededtokick(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

KickPetitionUpdateMessage::KickPetitionUpdateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:KickPetitionUpdateMessage)
}
KickPetitionUpdateMessage::KickPetitionUpdateMessage(const KickPetitionUpdateMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&numvotesneededtokick_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(numvotesneededtokick_));
  // @@protoc_insertion_point(copy_constructor:KickPetitionUpdateMessage)
}

inline void KickPetitionUpdateMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&numvotesneededtokick_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(numvotesneededtokick_));
}

KickPetitionUpdateMessage::~KickPetitionUpdateMessage() {
  // @@protoc_insertion_point(destructor:KickPetitionUpdateMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KickPetitionUpdateMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KickPetitionUpdateMessage::ArenaDtor(void* object) {
  KickPetitionUpdateMessage* _this = reinterpret_cast< KickPetitionUpdateMessage* >(object);
  (void)_this;
}
void KickPetitionUpdateMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KickPetitionUpdateMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KickPetitionUpdateMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:KickPetitionUpdateMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&numvotesneededtokick_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(numvotesneededtokick_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KickPetitionUpdateMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 petitionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_petitionid(&has_bits);
          petitionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numVotesAgainstKicking = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_numvotesagainstkicking(&has_bits);
          numvotesagainstkicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numVotesInFavourOfKicking = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numvotesinfavourofkicking(&has_bits);
          numvotesinfavourofkicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numVotesNeededToKick = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_numvotesneededtokick(&has_bits);
          numvotesneededtokick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KickPetitionUpdateMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:KickPetitionUpdateMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 petitionId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_petitionid(), target);
  }

  // required uint32 numVotesAgainstKicking = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_numvotesagainstkicking(), target);
  }

  // required uint32 numVotesInFavourOfKicking = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_numvotesinfavourofkicking(), target);
  }

  // required uint32 numVotesNeededToKick = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_numvotesneededtokick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KickPetitionUpdateMessage)
  return target;
}

size_t KickPetitionUpdateMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:KickPetitionUpdateMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_petitionid()) {
    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());
  }

  if (_internal_has_numvotesagainstkicking()) {
    // required uint32 numVotesAgainstKicking = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesagainstkicking());
  }

  if (_internal_has_numvotesinfavourofkicking()) {
    // required uint32 numVotesInFavourOfKicking = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesinfavourofkicking());
  }

  if (_internal_has_numvotesneededtokick()) {
    // required uint32 numVotesNeededToKick = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesneededtokick());
  }

  return total_size;
}
size_t KickPetitionUpdateMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:KickPetitionUpdateMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());

    // required uint32 numVotesAgainstKicking = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesagainstkicking());

    // required uint32 numVotesInFavourOfKicking = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesinfavourofkicking());

    // required uint32 numVotesNeededToKick = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesneededtokick());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KickPetitionUpdateMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KickPetitionUpdateMessage*>(
      &from));
}

void KickPetitionUpdateMessage::MergeFrom(const KickPetitionUpdateMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KickPetitionUpdateMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      petitionid_ = from.petitionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      numvotesagainstkicking_ = from.numvotesagainstkicking_;
    }
    if (cached_has_bits & 0x00000008u) {
      numvotesinfavourofkicking_ = from.numvotesinfavourofkicking_;
    }
    if (cached_has_bits & 0x00000010u) {
      numvotesneededtokick_ = from.numvotesneededtokick_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KickPetitionUpdateMessage::CopyFrom(const KickPetitionUpdateMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KickPetitionUpdateMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KickPetitionUpdateMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void KickPetitionUpdateMessage::InternalSwap(KickPetitionUpdateMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KickPetitionUpdateMessage, numvotesneededtokick_)
      + sizeof(KickPetitionUpdateMessage::numvotesneededtokick_)
      - PROTOBUF_FIELD_OFFSET(KickPetitionUpdateMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string KickPetitionUpdateMessage::GetTypeName() const {
  return "KickPetitionUpdateMessage";
}


// ===================================================================

class EndKickPetitionMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<EndKickPetitionMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_petitionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_numvotesagainstkicking(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numvotesinfavourofkicking(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_resultplayerkicked(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_petitionendreason(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

EndKickPetitionMessage::EndKickPetitionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:EndKickPetitionMessage)
}
EndKickPetitionMessage::EndKickPetitionMessage(const EndKickPetitionMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&petitionendreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(petitionendreason_));
  // @@protoc_insertion_point(copy_constructor:EndKickPetitionMessage)
}

inline void EndKickPetitionMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&petitionendreason_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(petitionendreason_));
}

EndKickPetitionMessage::~EndKickPetitionMessage() {
  // @@protoc_insertion_point(destructor:EndKickPetitionMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EndKickPetitionMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndKickPetitionMessage::ArenaDtor(void* object) {
  EndKickPetitionMessage* _this = reinterpret_cast< EndKickPetitionMessage* >(object);
  (void)_this;
}
void EndKickPetitionMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EndKickPetitionMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EndKickPetitionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:EndKickPetitionMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&petitionendreason_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(petitionendreason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndKickPetitionMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 petitionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_petitionid(&has_bits);
          petitionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numVotesAgainstKicking = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_numvotesagainstkicking(&has_bits);
          numvotesagainstkicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numVotesInFavourOfKicking = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numvotesinfavourofkicking(&has_bits);
          numvotesinfavourofkicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 resultPlayerKicked = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_resultplayerkicked(&has_bits);
          resultplayerkicked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EndKickPetitionMessage_PetitionEndReason_IsValid(val))) {
            _internal_set_petitionendreason(static_cast<::EndKickPetitionMessage_PetitionEndReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndKickPetitionMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EndKickPetitionMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 gameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // required uint32 petitionId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_petitionid(), target);
  }

  // required uint32 numVotesAgainstKicking = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_numvotesagainstkicking(), target);
  }

  // required uint32 numVotesInFavourOfKicking = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_numvotesinfavourofkicking(), target);
  }

  // required uint32 resultPlayerKicked = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_resultplayerkicked(), target);
  }

  // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_petitionendreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EndKickPetitionMessage)
  return target;
}

size_t EndKickPetitionMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:EndKickPetitionMessage)
  size_t total_size = 0;

  if (_internal_has_gameid()) {
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
  }

  if (_internal_has_petitionid()) {
    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());
  }

  if (_internal_has_numvotesagainstkicking()) {
    // required uint32 numVotesAgainstKicking = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesagainstkicking());
  }

  if (_internal_has_numvotesinfavourofkicking()) {
    // required uint32 numVotesInFavourOfKicking = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesinfavourofkicking());
  }

  if (_internal_has_resultplayerkicked()) {
    // required uint32 resultPlayerKicked = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_resultplayerkicked());
  }

  if (_internal_has_petitionendreason()) {
    // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_petitionendreason());
  }

  return total_size;
}
size_t EndKickPetitionMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EndKickPetitionMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required uint32 gameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());

    // required uint32 petitionId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_petitionid());

    // required uint32 numVotesAgainstKicking = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesagainstkicking());

    // required uint32 numVotesInFavourOfKicking = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_numvotesinfavourofkicking());

    // required uint32 resultPlayerKicked = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_resultplayerkicked());

    // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_petitionendreason());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndKickPetitionMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EndKickPetitionMessage*>(
      &from));
}

void EndKickPetitionMessage::MergeFrom(const EndKickPetitionMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:EndKickPetitionMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      petitionid_ = from.petitionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      numvotesagainstkicking_ = from.numvotesagainstkicking_;
    }
    if (cached_has_bits & 0x00000008u) {
      numvotesinfavourofkicking_ = from.numvotesinfavourofkicking_;
    }
    if (cached_has_bits & 0x00000010u) {
      resultplayerkicked_ = from.resultplayerkicked_;
    }
    if (cached_has_bits & 0x00000020u) {
      petitionendreason_ = from.petitionendreason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndKickPetitionMessage::CopyFrom(const EndKickPetitionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EndKickPetitionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndKickPetitionMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EndKickPetitionMessage::InternalSwap(EndKickPetitionMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EndKickPetitionMessage, petitionendreason_)
      + sizeof(EndKickPetitionMessage::petitionendreason_)
      - PROTOBUF_FIELD_OFFSET(EndKickPetitionMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string EndKickPetitionMessage::GetTypeName() const {
  return "EndKickPetitionMessage";
}


// ===================================================================

class StatisticsMessage_StatisticsData::_Internal {
 public:
  using HasBits = decltype(std::declval<StatisticsMessage_StatisticsData>()._has_bits_);
  static void set_has_statisticstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_statisticsvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StatisticsMessage_StatisticsData::StatisticsMessage_StatisticsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StatisticsMessage.StatisticsData)
}
StatisticsMessage_StatisticsData::StatisticsMessage_StatisticsData(const StatisticsMessage_StatisticsData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&statisticsvalue_, &from.statisticsvalue_,
    static_cast<size_t>(reinterpret_cast<char*>(&statisticstype_) -
    reinterpret_cast<char*>(&statisticsvalue_)) + sizeof(statisticstype_));
  // @@protoc_insertion_point(copy_constructor:StatisticsMessage.StatisticsData)
}

inline void StatisticsMessage_StatisticsData::SharedCtor() {
statisticsvalue_ = 0u;
statisticstype_ = 1;
}

StatisticsMessage_StatisticsData::~StatisticsMessage_StatisticsData() {
  // @@protoc_insertion_point(destructor:StatisticsMessage.StatisticsData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StatisticsMessage_StatisticsData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatisticsMessage_StatisticsData::ArenaDtor(void* object) {
  StatisticsMessage_StatisticsData* _this = reinterpret_cast< StatisticsMessage_StatisticsData* >(object);
  (void)_this;
}
void StatisticsMessage_StatisticsData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatisticsMessage_StatisticsData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatisticsMessage_StatisticsData::Clear() {
// @@protoc_insertion_point(message_clear_start:StatisticsMessage.StatisticsData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    statisticsvalue_ = 0u;
    statisticstype_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StatisticsMessage_StatisticsData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::StatisticsMessage_StatisticsData_StatisticsType_IsValid(val))) {
            _internal_set_statisticstype(static_cast<::StatisticsMessage_StatisticsData_StatisticsType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 statisticsValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_statisticsvalue(&has_bits);
          statisticsvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatisticsMessage_StatisticsData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StatisticsMessage.StatisticsData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_statisticstype(), target);
  }

  // required uint32 statisticsValue = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_statisticsvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StatisticsMessage.StatisticsData)
  return target;
}

size_t StatisticsMessage_StatisticsData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StatisticsMessage.StatisticsData)
  size_t total_size = 0;

  if (_internal_has_statisticsvalue()) {
    // required uint32 statisticsValue = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_statisticsvalue());
  }

  if (_internal_has_statisticstype()) {
    // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_statisticstype());
  }

  return total_size;
}
size_t StatisticsMessage_StatisticsData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StatisticsMessage.StatisticsData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 statisticsValue = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_statisticsvalue());

    // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_statisticstype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatisticsMessage_StatisticsData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StatisticsMessage_StatisticsData*>(
      &from));
}

void StatisticsMessage_StatisticsData::MergeFrom(const StatisticsMessage_StatisticsData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StatisticsMessage.StatisticsData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      statisticsvalue_ = from.statisticsvalue_;
    }
    if (cached_has_bits & 0x00000002u) {
      statisticstype_ = from.statisticstype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatisticsMessage_StatisticsData::CopyFrom(const StatisticsMessage_StatisticsData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StatisticsMessage.StatisticsData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatisticsMessage_StatisticsData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StatisticsMessage_StatisticsData::InternalSwap(StatisticsMessage_StatisticsData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(statisticsvalue_, other->statisticsvalue_);
  swap(statisticstype_, other->statisticstype_);
}

std::string StatisticsMessage_StatisticsData::GetTypeName() const {
  return "StatisticsMessage.StatisticsData";
}


// ===================================================================

class StatisticsMessage::_Internal {
 public:
};

StatisticsMessage::StatisticsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  statisticsdata_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StatisticsMessage)
}
StatisticsMessage::StatisticsMessage(const StatisticsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      statisticsdata_(from.statisticsdata_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:StatisticsMessage)
}

inline void StatisticsMessage::SharedCtor() {
}

StatisticsMessage::~StatisticsMessage() {
  // @@protoc_insertion_point(destructor:StatisticsMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StatisticsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatisticsMessage::ArenaDtor(void* object) {
  StatisticsMessage* _this = reinterpret_cast< StatisticsMessage* >(object);
  (void)_this;
}
void StatisticsMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatisticsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatisticsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:StatisticsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  statisticsdata_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StatisticsMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_statisticsdata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatisticsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StatisticsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_statisticsdata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_statisticsdata(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StatisticsMessage)
  return target;
}

size_t StatisticsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StatisticsMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
  total_size += 1UL * this->_internal_statisticsdata_size();
  for (const auto& msg : this->statisticsdata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatisticsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StatisticsMessage*>(
      &from));
}

void StatisticsMessage::MergeFrom(const StatisticsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StatisticsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  statisticsdata_.MergeFrom(from.statisticsdata_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatisticsMessage::CopyFrom(const StatisticsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StatisticsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatisticsMessage::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(statisticsdata_))
    return false;
  return true;
}

void StatisticsMessage::InternalSwap(StatisticsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  statisticsdata_.InternalSwap(&other->statisticsdata_);
}

std::string StatisticsMessage::GetTypeName() const {
  return "StatisticsMessage";
}


// ===================================================================

class ChatRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ChatRequestMessage>()._has_bits_);
  static void set_has_targetgameid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_targetplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_chattext(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ChatRequestMessage::ChatRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ChatRequestMessage)
}
ChatRequestMessage::ChatRequestMessage(const ChatRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  chattext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chattext()) {
    chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_chattext(), 
      GetArenaForAllocation());
  }
  ::memcpy(&targetgameid_, &from.targetgameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&targetplayerid_) -
    reinterpret_cast<char*>(&targetgameid_)) + sizeof(targetplayerid_));
  // @@protoc_insertion_point(copy_constructor:ChatRequestMessage)
}

inline void ChatRequestMessage::SharedCtor() {
chattext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&targetgameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&targetplayerid_) -
    reinterpret_cast<char*>(&targetgameid_)) + sizeof(targetplayerid_));
}

ChatRequestMessage::~ChatRequestMessage() {
  // @@protoc_insertion_point(destructor:ChatRequestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ChatRequestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chattext_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ChatRequestMessage::ArenaDtor(void* object) {
  ChatRequestMessage* _this = reinterpret_cast< ChatRequestMessage* >(object);
  (void)_this;
}
void ChatRequestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ChatRequestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChatRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ChatRequestMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    chattext_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&targetgameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&targetplayerid_) -
        reinterpret_cast<char*>(&targetgameid_)) + sizeof(targetplayerid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChatRequestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 targetGameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_targetgameid(&has_bits);
          targetgameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 targetPlayerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_targetplayerid(&has_bits);
          targetplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string chatText = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_chattext();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChatRequestMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ChatRequestMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 targetGameId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_targetgameid(), target);
  }

  // optional uint32 targetPlayerId = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_targetplayerid(), target);
  }

  // required string chatText = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_chattext(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ChatRequestMessage)
  return target;
}

size_t ChatRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ChatRequestMessage)
  size_t total_size = 0;

  // required string chatText = 3;
  if (_internal_has_chattext()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chattext());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 targetGameId = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_targetgameid());
    }

    // optional uint32 targetPlayerId = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_targetplayerid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChatRequestMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ChatRequestMessage*>(
      &from));
}

void ChatRequestMessage::MergeFrom(const ChatRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ChatRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_chattext(from._internal_chattext());
    }
    if (cached_has_bits & 0x00000002u) {
      targetgameid_ = from.targetgameid_;
    }
    if (cached_has_bits & 0x00000004u) {
      targetplayerid_ = from.targetplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChatRequestMessage::CopyFrom(const ChatRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ChatRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatRequestMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ChatRequestMessage::InternalSwap(ChatRequestMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &chattext_, lhs_arena,
      &other->chattext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChatRequestMessage, targetplayerid_)
      + sizeof(ChatRequestMessage::targetplayerid_)
      - PROTOBUF_FIELD_OFFSET(ChatRequestMessage, targetgameid_)>(
          reinterpret_cast<char*>(&targetgameid_),
          reinterpret_cast<char*>(&other->targetgameid_));
}

std::string ChatRequestMessage::GetTypeName() const {
  return "ChatRequestMessage";
}


// ===================================================================

class ChatMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ChatMessage>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_chattype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_chattext(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

ChatMessage::ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ChatMessage)
}
ChatMessage::ChatMessage(const ChatMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  chattext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chattext()) {
    chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_chattext(), 
      GetArenaForAllocation());
  }
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&chattype_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(chattype_));
  // @@protoc_insertion_point(copy_constructor:ChatMessage)
}

inline void ChatMessage::SharedCtor() {
chattext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chattype_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(chattype_));
}

ChatMessage::~ChatMessage() {
  // @@protoc_insertion_point(destructor:ChatMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ChatMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chattext_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ChatMessage::ArenaDtor(void* object) {
  ChatMessage* _this = reinterpret_cast< ChatMessage* >(object);
  (void)_this;
}
void ChatMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ChatMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChatMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ChatMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    chattext_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chattype_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(chattype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChatMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 playerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ChatMessage.ChatType chatType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ChatMessage_ChatType_IsValid(val))) {
            _internal_set_chattype(static_cast<::ChatMessage_ChatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string chatText = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_chattext();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChatMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ChatMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gameId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameid(), target);
  }

  // optional uint32 playerId = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playerid(), target);
  }

  // required .ChatMessage.ChatType chatType = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_chattype(), target);
  }

  // required string chatText = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_chattext(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ChatMessage)
  return target;
}

size_t ChatMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ChatMessage)
  size_t total_size = 0;

  if (_internal_has_chattext()) {
    // required string chatText = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chattext());
  }

  if (_internal_has_chattype()) {
    // required .ChatMessage.ChatType chatType = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chattype());
  }

  return total_size;
}
size_t ChatMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ChatMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required string chatText = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chattext());

    // required .ChatMessage.ChatType chatType = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chattype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 gameId = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gameid());
    }

    // optional uint32 playerId = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playerid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChatMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ChatMessage*>(
      &from));
}

void ChatMessage::MergeFrom(const ChatMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ChatMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_chattext(from._internal_chattext());
    }
    if (cached_has_bits & 0x00000002u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000004u) {
      playerid_ = from.playerid_;
    }
    if (cached_has_bits & 0x00000008u) {
      chattype_ = from.chattype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChatMessage::CopyFrom(const ChatMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ChatMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ChatMessage::InternalSwap(ChatMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &chattext_, lhs_arena,
      &other->chattext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChatMessage, chattype_)
      + sizeof(ChatMessage::chattype_)
      - PROTOBUF_FIELD_OFFSET(ChatMessage, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
}

std::string ChatMessage::GetTypeName() const {
  return "ChatMessage";
}


// ===================================================================

class ChatRejectMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ChatRejectMessage>()._has_bits_);
  static void set_has_chattext(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ChatRejectMessage::ChatRejectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ChatRejectMessage)
}
ChatRejectMessage::ChatRejectMessage(const ChatRejectMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  chattext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chattext()) {
    chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_chattext(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ChatRejectMessage)
}

inline void ChatRejectMessage::SharedCtor() {
chattext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChatRejectMessage::~ChatRejectMessage() {
  // @@protoc_insertion_point(destructor:ChatRejectMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ChatRejectMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chattext_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ChatRejectMessage::ArenaDtor(void* object) {
  ChatRejectMessage* _this = reinterpret_cast< ChatRejectMessage* >(object);
  (void)_this;
}
void ChatRejectMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ChatRejectMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChatRejectMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ChatRejectMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    chattext_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChatRejectMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string chatText = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_chattext();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChatRejectMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ChatRejectMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string chatText = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_chattext(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ChatRejectMessage)
  return target;
}

size_t ChatRejectMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ChatRejectMessage)
  size_t total_size = 0;

  // required string chatText = 1;
  if (_internal_has_chattext()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chattext());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChatRejectMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ChatRejectMessage*>(
      &from));
}

void ChatRejectMessage::MergeFrom(const ChatRejectMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ChatRejectMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_chattext()) {
    _internal_set_chattext(from._internal_chattext());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChatRejectMessage::CopyFrom(const ChatRejectMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ChatRejectMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatRejectMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ChatRejectMessage::InternalSwap(ChatRejectMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &chattext_, lhs_arena,
      &other->chattext_, rhs_arena
  );
}

std::string ChatRejectMessage::GetTypeName() const {
  return "ChatRejectMessage";
}


// ===================================================================

class DialogMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DialogMessage>()._has_bits_);
  static void set_has_notificationtext(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DialogMessage::DialogMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DialogMessage)
}
DialogMessage::DialogMessage(const DialogMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  notificationtext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    notificationtext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_notificationtext()) {
    notificationtext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_notificationtext(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:DialogMessage)
}

inline void DialogMessage::SharedCtor() {
notificationtext_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  notificationtext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DialogMessage::~DialogMessage() {
  // @@protoc_insertion_point(destructor:DialogMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DialogMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  notificationtext_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DialogMessage::ArenaDtor(void* object) {
  DialogMessage* _this = reinterpret_cast< DialogMessage* >(object);
  (void)_this;
}
void DialogMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DialogMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DialogMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:DialogMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    notificationtext_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DialogMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string notificationText = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_notificationtext();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DialogMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DialogMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string notificationText = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_notificationtext(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DialogMessage)
  return target;
}

size_t DialogMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DialogMessage)
  size_t total_size = 0;

  // required string notificationText = 1;
  if (_internal_has_notificationtext()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_notificationtext());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DialogMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DialogMessage*>(
      &from));
}

void DialogMessage::MergeFrom(const DialogMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DialogMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_notificationtext()) {
    _internal_set_notificationtext(from._internal_notificationtext());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DialogMessage::CopyFrom(const DialogMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DialogMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DialogMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DialogMessage::InternalSwap(DialogMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &notificationtext_, lhs_arena,
      &other->notificationtext_, rhs_arena
  );
}

std::string DialogMessage::GetTypeName() const {
  return "DialogMessage";
}


// ===================================================================

class TimeoutWarningMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TimeoutWarningMessage>()._has_bits_);
  static void set_has_timeoutreason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_remainingseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TimeoutWarningMessage::TimeoutWarningMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:TimeoutWarningMessage)
}
TimeoutWarningMessage::TimeoutWarningMessage(const TimeoutWarningMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timeoutreason_, &from.timeoutreason_,
    static_cast<size_t>(reinterpret_cast<char*>(&remainingseconds_) -
    reinterpret_cast<char*>(&timeoutreason_)) + sizeof(remainingseconds_));
  // @@protoc_insertion_point(copy_constructor:TimeoutWarningMessage)
}

inline void TimeoutWarningMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timeoutreason_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&remainingseconds_) -
    reinterpret_cast<char*>(&timeoutreason_)) + sizeof(remainingseconds_));
}

TimeoutWarningMessage::~TimeoutWarningMessage() {
  // @@protoc_insertion_point(destructor:TimeoutWarningMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TimeoutWarningMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeoutWarningMessage::ArenaDtor(void* object) {
  TimeoutWarningMessage* _this = reinterpret_cast< TimeoutWarningMessage* >(object);
  (void)_this;
}
void TimeoutWarningMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TimeoutWarningMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TimeoutWarningMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TimeoutWarningMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&timeoutreason_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&remainingseconds_) -
        reinterpret_cast<char*>(&timeoutreason_)) + sizeof(remainingseconds_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimeoutWarningMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TimeoutWarningMessage_TimeoutReason_IsValid(val))) {
            _internal_set_timeoutreason(static_cast<::TimeoutWarningMessage_TimeoutReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 remainingSeconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_remainingseconds(&has_bits);
          remainingseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimeoutWarningMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TimeoutWarningMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_timeoutreason(), target);
  }

  // required uint32 remainingSeconds = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_remainingseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TimeoutWarningMessage)
  return target;
}

size_t TimeoutWarningMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TimeoutWarningMessage)
  size_t total_size = 0;

  if (_internal_has_timeoutreason()) {
    // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_timeoutreason());
  }

  if (_internal_has_remainingseconds()) {
    // required uint32 remainingSeconds = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_remainingseconds());
  }

  return total_size;
}
size_t TimeoutWarningMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TimeoutWarningMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_timeoutreason());

    // required uint32 remainingSeconds = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_remainingseconds());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimeoutWarningMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TimeoutWarningMessage*>(
      &from));
}

void TimeoutWarningMessage::MergeFrom(const TimeoutWarningMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TimeoutWarningMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timeoutreason_ = from.timeoutreason_;
    }
    if (cached_has_bits & 0x00000002u) {
      remainingseconds_ = from.remainingseconds_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimeoutWarningMessage::CopyFrom(const TimeoutWarningMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TimeoutWarningMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeoutWarningMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TimeoutWarningMessage::InternalSwap(TimeoutWarningMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeoutWarningMessage, remainingseconds_)
      + sizeof(TimeoutWarningMessage::remainingseconds_)
      - PROTOBUF_FIELD_OFFSET(TimeoutWarningMessage, timeoutreason_)>(
          reinterpret_cast<char*>(&timeoutreason_),
          reinterpret_cast<char*>(&other->timeoutreason_));
}

std::string TimeoutWarningMessage::GetTypeName() const {
  return "TimeoutWarningMessage";
}


// ===================================================================

class ResetTimeoutMessage::_Internal {
 public:
};

ResetTimeoutMessage::ResetTimeoutMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ResetTimeoutMessage)
}
ResetTimeoutMessage::ResetTimeoutMessage(const ResetTimeoutMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ResetTimeoutMessage)
}

inline void ResetTimeoutMessage::SharedCtor() {
}

ResetTimeoutMessage::~ResetTimeoutMessage() {
  // @@protoc_insertion_point(destructor:ResetTimeoutMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ResetTimeoutMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResetTimeoutMessage::ArenaDtor(void* object) {
  ResetTimeoutMessage* _this = reinterpret_cast< ResetTimeoutMessage* >(object);
  (void)_this;
}
void ResetTimeoutMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ResetTimeoutMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ResetTimeoutMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ResetTimeoutMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ResetTimeoutMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetTimeoutMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ResetTimeoutMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ResetTimeoutMessage)
  return target;
}

size_t ResetTimeoutMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ResetTimeoutMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResetTimeoutMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ResetTimeoutMessage*>(
      &from));
}

void ResetTimeoutMessage::MergeFrom(const ResetTimeoutMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ResetTimeoutMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResetTimeoutMessage::CopyFrom(const ResetTimeoutMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ResetTimeoutMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetTimeoutMessage::IsInitialized() const {
  return true;
}

void ResetTimeoutMessage::InternalSwap(ResetTimeoutMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ResetTimeoutMessage::GetTypeName() const {
  return "ResetTimeoutMessage";
}


// ===================================================================

class ReportAvatarMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ReportAvatarMessage>()._has_bits_);
  static void set_has_reportedplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reportedavatarhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ReportAvatarMessage::ReportAvatarMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ReportAvatarMessage)
}
ReportAvatarMessage::ReportAvatarMessage(const ReportAvatarMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  reportedavatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reportedavatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reportedavatarhash()) {
    reportedavatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_reportedavatarhash(), 
      GetArenaForAllocation());
  }
  reportedplayerid_ = from.reportedplayerid_;
  // @@protoc_insertion_point(copy_constructor:ReportAvatarMessage)
}

inline void ReportAvatarMessage::SharedCtor() {
reportedavatarhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reportedavatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reportedplayerid_ = 0u;
}

ReportAvatarMessage::~ReportAvatarMessage() {
  // @@protoc_insertion_point(destructor:ReportAvatarMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReportAvatarMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  reportedavatarhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ReportAvatarMessage::ArenaDtor(void* object) {
  ReportAvatarMessage* _this = reinterpret_cast< ReportAvatarMessage* >(object);
  (void)_this;
}
void ReportAvatarMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReportAvatarMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReportAvatarMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ReportAvatarMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    reportedavatarhash_.ClearNonDefaultToEmpty();
  }
  reportedplayerid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReportAvatarMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 reportedPlayerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reportedplayerid(&has_bits);
          reportedplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes reportedAvatarHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_reportedavatarhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReportAvatarMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ReportAvatarMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 reportedPlayerId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reportedplayerid(), target);
  }

  // required bytes reportedAvatarHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_reportedavatarhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ReportAvatarMessage)
  return target;
}

size_t ReportAvatarMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ReportAvatarMessage)
  size_t total_size = 0;

  if (_internal_has_reportedavatarhash()) {
    // required bytes reportedAvatarHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_reportedavatarhash());
  }

  if (_internal_has_reportedplayerid()) {
    // required uint32 reportedPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedplayerid());
  }

  return total_size;
}
size_t ReportAvatarMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ReportAvatarMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes reportedAvatarHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_reportedavatarhash());

    // required uint32 reportedPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedplayerid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReportAvatarMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReportAvatarMessage*>(
      &from));
}

void ReportAvatarMessage::MergeFrom(const ReportAvatarMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ReportAvatarMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_reportedavatarhash(from._internal_reportedavatarhash());
    }
    if (cached_has_bits & 0x00000002u) {
      reportedplayerid_ = from.reportedplayerid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReportAvatarMessage::CopyFrom(const ReportAvatarMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ReportAvatarMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReportAvatarMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ReportAvatarMessage::InternalSwap(ReportAvatarMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &reportedavatarhash_, lhs_arena,
      &other->reportedavatarhash_, rhs_arena
  );
  swap(reportedplayerid_, other->reportedplayerid_);
}

std::string ReportAvatarMessage::GetTypeName() const {
  return "ReportAvatarMessage";
}


// ===================================================================

class ReportAvatarAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ReportAvatarAckMessage>()._has_bits_);
  static void set_has_reportedplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reportavatarresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ReportAvatarAckMessage::ReportAvatarAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ReportAvatarAckMessage)
}
ReportAvatarAckMessage::ReportAvatarAckMessage(const ReportAvatarAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&reportedplayerid_, &from.reportedplayerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&reportavatarresult_) -
    reinterpret_cast<char*>(&reportedplayerid_)) + sizeof(reportavatarresult_));
  // @@protoc_insertion_point(copy_constructor:ReportAvatarAckMessage)
}

inline void ReportAvatarAckMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&reportedplayerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reportavatarresult_) -
    reinterpret_cast<char*>(&reportedplayerid_)) + sizeof(reportavatarresult_));
}

ReportAvatarAckMessage::~ReportAvatarAckMessage() {
  // @@protoc_insertion_point(destructor:ReportAvatarAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReportAvatarAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReportAvatarAckMessage::ArenaDtor(void* object) {
  ReportAvatarAckMessage* _this = reinterpret_cast< ReportAvatarAckMessage* >(object);
  (void)_this;
}
void ReportAvatarAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReportAvatarAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReportAvatarAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ReportAvatarAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&reportedplayerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reportavatarresult_) -
        reinterpret_cast<char*>(&reportedplayerid_)) + sizeof(reportavatarresult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReportAvatarAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 reportedPlayerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reportedplayerid(&has_bits);
          reportedplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ReportAvatarAckMessage_ReportAvatarResult_IsValid(val))) {
            _internal_set_reportavatarresult(static_cast<::ReportAvatarAckMessage_ReportAvatarResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReportAvatarAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ReportAvatarAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 reportedPlayerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reportedplayerid(), target);
  }

  // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_reportavatarresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ReportAvatarAckMessage)
  return target;
}

size_t ReportAvatarAckMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ReportAvatarAckMessage)
  size_t total_size = 0;

  if (_internal_has_reportedplayerid()) {
    // required uint32 reportedPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedplayerid());
  }

  if (_internal_has_reportavatarresult()) {
    // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_reportavatarresult());
  }

  return total_size;
}
size_t ReportAvatarAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ReportAvatarAckMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 reportedPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedplayerid());

    // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_reportavatarresult());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReportAvatarAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReportAvatarAckMessage*>(
      &from));
}

void ReportAvatarAckMessage::MergeFrom(const ReportAvatarAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ReportAvatarAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      reportedplayerid_ = from.reportedplayerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      reportavatarresult_ = from.reportavatarresult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReportAvatarAckMessage::CopyFrom(const ReportAvatarAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ReportAvatarAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReportAvatarAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ReportAvatarAckMessage::InternalSwap(ReportAvatarAckMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReportAvatarAckMessage, reportavatarresult_)
      + sizeof(ReportAvatarAckMessage::reportavatarresult_)
      - PROTOBUF_FIELD_OFFSET(ReportAvatarAckMessage, reportedplayerid_)>(
          reinterpret_cast<char*>(&reportedplayerid_),
          reinterpret_cast<char*>(&other->reportedplayerid_));
}

std::string ReportAvatarAckMessage::GetTypeName() const {
  return "ReportAvatarAckMessage";
}


// ===================================================================

class ReportGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ReportGameMessage>()._has_bits_);
  static void set_has_reportedgameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ReportGameMessage::ReportGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ReportGameMessage)
}
ReportGameMessage::ReportGameMessage(const ReportGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  reportedgameid_ = from.reportedgameid_;
  // @@protoc_insertion_point(copy_constructor:ReportGameMessage)
}

inline void ReportGameMessage::SharedCtor() {
reportedgameid_ = 0u;
}

ReportGameMessage::~ReportGameMessage() {
  // @@protoc_insertion_point(destructor:ReportGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReportGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReportGameMessage::ArenaDtor(void* object) {
  ReportGameMessage* _this = reinterpret_cast< ReportGameMessage* >(object);
  (void)_this;
}
void ReportGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReportGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReportGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ReportGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reportedgameid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReportGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 reportedGameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reportedgameid(&has_bits);
          reportedgameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReportGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ReportGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 reportedGameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reportedgameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ReportGameMessage)
  return target;
}

size_t ReportGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ReportGameMessage)
  size_t total_size = 0;

  // required uint32 reportedGameId = 1;
  if (_internal_has_reportedgameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedgameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReportGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReportGameMessage*>(
      &from));
}

void ReportGameMessage::MergeFrom(const ReportGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ReportGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reportedgameid()) {
    _internal_set_reportedgameid(from._internal_reportedgameid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReportGameMessage::CopyFrom(const ReportGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ReportGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReportGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ReportGameMessage::InternalSwap(ReportGameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(reportedgameid_, other->reportedgameid_);
}

std::string ReportGameMessage::GetTypeName() const {
  return "ReportGameMessage";
}


// ===================================================================

class ReportGameAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ReportGameAckMessage>()._has_bits_);
  static void set_has_reportedgameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reportgameresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ReportGameAckMessage::ReportGameAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ReportGameAckMessage)
}
ReportGameAckMessage::ReportGameAckMessage(const ReportGameAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&reportedgameid_, &from.reportedgameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&reportgameresult_) -
    reinterpret_cast<char*>(&reportedgameid_)) + sizeof(reportgameresult_));
  // @@protoc_insertion_point(copy_constructor:ReportGameAckMessage)
}

inline void ReportGameAckMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&reportedgameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reportgameresult_) -
    reinterpret_cast<char*>(&reportedgameid_)) + sizeof(reportgameresult_));
}

ReportGameAckMessage::~ReportGameAckMessage() {
  // @@protoc_insertion_point(destructor:ReportGameAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReportGameAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReportGameAckMessage::ArenaDtor(void* object) {
  ReportGameAckMessage* _this = reinterpret_cast< ReportGameAckMessage* >(object);
  (void)_this;
}
void ReportGameAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReportGameAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReportGameAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ReportGameAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&reportedgameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reportgameresult_) -
        reinterpret_cast<char*>(&reportedgameid_)) + sizeof(reportgameresult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReportGameAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 reportedGameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reportedgameid(&has_bits);
          reportedgameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ReportGameAckMessage_ReportGameResult_IsValid(val))) {
            _internal_set_reportgameresult(static_cast<::ReportGameAckMessage_ReportGameResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReportGameAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ReportGameAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 reportedGameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reportedgameid(), target);
  }

  // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_reportgameresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ReportGameAckMessage)
  return target;
}

size_t ReportGameAckMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ReportGameAckMessage)
  size_t total_size = 0;

  if (_internal_has_reportedgameid()) {
    // required uint32 reportedGameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedgameid());
  }

  if (_internal_has_reportgameresult()) {
    // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_reportgameresult());
  }

  return total_size;
}
size_t ReportGameAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ReportGameAckMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 reportedGameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reportedgameid());

    // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_reportgameresult());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReportGameAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReportGameAckMessage*>(
      &from));
}

void ReportGameAckMessage::MergeFrom(const ReportGameAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ReportGameAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      reportedgameid_ = from.reportedgameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      reportgameresult_ = from.reportgameresult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReportGameAckMessage::CopyFrom(const ReportGameAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ReportGameAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReportGameAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ReportGameAckMessage::InternalSwap(ReportGameAckMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReportGameAckMessage, reportgameresult_)
      + sizeof(ReportGameAckMessage::reportgameresult_)
      - PROTOBUF_FIELD_OFFSET(ReportGameAckMessage, reportedgameid_)>(
          reinterpret_cast<char*>(&reportedgameid_),
          reinterpret_cast<char*>(&other->reportedgameid_));
}

std::string ReportGameAckMessage::GetTypeName() const {
  return "ReportGameAckMessage";
}


// ===================================================================

class ErrorMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ErrorMessage>()._has_bits_);
  static void set_has_errorreason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ErrorMessage::ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ErrorMessage)
}
ErrorMessage::ErrorMessage(const ErrorMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  errorreason_ = from.errorreason_;
  // @@protoc_insertion_point(copy_constructor:ErrorMessage)
}

inline void ErrorMessage::SharedCtor() {
errorreason_ = 0;
}

ErrorMessage::~ErrorMessage() {
  // @@protoc_insertion_point(destructor:ErrorMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ErrorMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ErrorMessage::ArenaDtor(void* object) {
  ErrorMessage* _this = reinterpret_cast< ErrorMessage* >(object);
  (void)_this;
}
void ErrorMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ErrorMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ErrorMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ErrorMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  errorreason_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ErrorMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ErrorMessage.ErrorReason errorReason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ErrorMessage_ErrorReason_IsValid(val))) {
            _internal_set_errorreason(static_cast<::ErrorMessage_ErrorReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ErrorMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ErrorMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ErrorMessage.ErrorReason errorReason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_errorreason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ErrorMessage)
  return target;
}

size_t ErrorMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ErrorMessage)
  size_t total_size = 0;

  // required .ErrorMessage.ErrorReason errorReason = 1;
  if (_internal_has_errorreason()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_errorreason());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ErrorMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ErrorMessage*>(
      &from));
}

void ErrorMessage::MergeFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ErrorMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_errorreason()) {
    _internal_set_errorreason(from._internal_errorreason());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ErrorMessage::CopyFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ErrorMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ErrorMessage::InternalSwap(ErrorMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(errorreason_, other->errorreason_);
}

std::string ErrorMessage::GetTypeName() const {
  return "ErrorMessage";
}


// ===================================================================

class AdminRemoveGameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AdminRemoveGameMessage>()._has_bits_);
  static void set_has_removegameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AdminRemoveGameMessage::AdminRemoveGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AdminRemoveGameMessage)
}
AdminRemoveGameMessage::AdminRemoveGameMessage(const AdminRemoveGameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  removegameid_ = from.removegameid_;
  // @@protoc_insertion_point(copy_constructor:AdminRemoveGameMessage)
}

inline void AdminRemoveGameMessage::SharedCtor() {
removegameid_ = 0u;
}

AdminRemoveGameMessage::~AdminRemoveGameMessage() {
  // @@protoc_insertion_point(destructor:AdminRemoveGameMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AdminRemoveGameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AdminRemoveGameMessage::ArenaDtor(void* object) {
  AdminRemoveGameMessage* _this = reinterpret_cast< AdminRemoveGameMessage* >(object);
  (void)_this;
}
void AdminRemoveGameMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdminRemoveGameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdminRemoveGameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AdminRemoveGameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  removegameid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AdminRemoveGameMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 removeGameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_removegameid(&has_bits);
          removegameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdminRemoveGameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdminRemoveGameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 removeGameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_removegameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdminRemoveGameMessage)
  return target;
}

size_t AdminRemoveGameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AdminRemoveGameMessage)
  size_t total_size = 0;

  // required uint32 removeGameId = 1;
  if (_internal_has_removegameid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_removegameid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AdminRemoveGameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AdminRemoveGameMessage*>(
      &from));
}

void AdminRemoveGameMessage::MergeFrom(const AdminRemoveGameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AdminRemoveGameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_removegameid()) {
    _internal_set_removegameid(from._internal_removegameid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AdminRemoveGameMessage::CopyFrom(const AdminRemoveGameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AdminRemoveGameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminRemoveGameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AdminRemoveGameMessage::InternalSwap(AdminRemoveGameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(removegameid_, other->removegameid_);
}

std::string AdminRemoveGameMessage::GetTypeName() const {
  return "AdminRemoveGameMessage";
}


// ===================================================================

class AdminRemoveGameAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AdminRemoveGameAckMessage>()._has_bits_);
  static void set_has_removegameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_removegameresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AdminRemoveGameAckMessage::AdminRemoveGameAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AdminRemoveGameAckMessage)
}
AdminRemoveGameAckMessage::AdminRemoveGameAckMessage(const AdminRemoveGameAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&removegameid_, &from.removegameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&removegameresult_) -
    reinterpret_cast<char*>(&removegameid_)) + sizeof(removegameresult_));
  // @@protoc_insertion_point(copy_constructor:AdminRemoveGameAckMessage)
}

inline void AdminRemoveGameAckMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&removegameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&removegameresult_) -
    reinterpret_cast<char*>(&removegameid_)) + sizeof(removegameresult_));
}

AdminRemoveGameAckMessage::~AdminRemoveGameAckMessage() {
  // @@protoc_insertion_point(destructor:AdminRemoveGameAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AdminRemoveGameAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AdminRemoveGameAckMessage::ArenaDtor(void* object) {
  AdminRemoveGameAckMessage* _this = reinterpret_cast< AdminRemoveGameAckMessage* >(object);
  (void)_this;
}
void AdminRemoveGameAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdminRemoveGameAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdminRemoveGameAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AdminRemoveGameAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&removegameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&removegameresult_) -
        reinterpret_cast<char*>(&removegameid_)) + sizeof(removegameresult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AdminRemoveGameAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 removeGameId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_removegameid(&has_bits);
          removegameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(val))) {
            _internal_set_removegameresult(static_cast<::AdminRemoveGameAckMessage_AdminRemoveGameResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdminRemoveGameAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdminRemoveGameAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 removeGameId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_removegameid(), target);
  }

  // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_removegameresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdminRemoveGameAckMessage)
  return target;
}

size_t AdminRemoveGameAckMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AdminRemoveGameAckMessage)
  size_t total_size = 0;

  if (_internal_has_removegameid()) {
    // required uint32 removeGameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_removegameid());
  }

  if (_internal_has_removegameresult()) {
    // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_removegameresult());
  }

  return total_size;
}
size_t AdminRemoveGameAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AdminRemoveGameAckMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 removeGameId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_removegameid());

    // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_removegameresult());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AdminRemoveGameAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AdminRemoveGameAckMessage*>(
      &from));
}

void AdminRemoveGameAckMessage::MergeFrom(const AdminRemoveGameAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AdminRemoveGameAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      removegameid_ = from.removegameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      removegameresult_ = from.removegameresult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AdminRemoveGameAckMessage::CopyFrom(const AdminRemoveGameAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AdminRemoveGameAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminRemoveGameAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AdminRemoveGameAckMessage::InternalSwap(AdminRemoveGameAckMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AdminRemoveGameAckMessage, removegameresult_)
      + sizeof(AdminRemoveGameAckMessage::removegameresult_)
      - PROTOBUF_FIELD_OFFSET(AdminRemoveGameAckMessage, removegameid_)>(
          reinterpret_cast<char*>(&removegameid_),
          reinterpret_cast<char*>(&other->removegameid_));
}

std::string AdminRemoveGameAckMessage::GetTypeName() const {
  return "AdminRemoveGameAckMessage";
}


// ===================================================================

class AdminBanPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AdminBanPlayerMessage>()._has_bits_);
  static void set_has_banplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AdminBanPlayerMessage::AdminBanPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AdminBanPlayerMessage)
}
AdminBanPlayerMessage::AdminBanPlayerMessage(const AdminBanPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  banplayerid_ = from.banplayerid_;
  // @@protoc_insertion_point(copy_constructor:AdminBanPlayerMessage)
}

inline void AdminBanPlayerMessage::SharedCtor() {
banplayerid_ = 0u;
}

AdminBanPlayerMessage::~AdminBanPlayerMessage() {
  // @@protoc_insertion_point(destructor:AdminBanPlayerMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AdminBanPlayerMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AdminBanPlayerMessage::ArenaDtor(void* object) {
  AdminBanPlayerMessage* _this = reinterpret_cast< AdminBanPlayerMessage* >(object);
  (void)_this;
}
void AdminBanPlayerMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdminBanPlayerMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdminBanPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AdminBanPlayerMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  banplayerid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AdminBanPlayerMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 banPlayerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_banplayerid(&has_bits);
          banplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdminBanPlayerMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdminBanPlayerMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 banPlayerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_banplayerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdminBanPlayerMessage)
  return target;
}

size_t AdminBanPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AdminBanPlayerMessage)
  size_t total_size = 0;

  // required uint32 banPlayerId = 1;
  if (_internal_has_banplayerid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_banplayerid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AdminBanPlayerMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AdminBanPlayerMessage*>(
      &from));
}

void AdminBanPlayerMessage::MergeFrom(const AdminBanPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AdminBanPlayerMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_banplayerid()) {
    _internal_set_banplayerid(from._internal_banplayerid());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AdminBanPlayerMessage::CopyFrom(const AdminBanPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AdminBanPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminBanPlayerMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AdminBanPlayerMessage::InternalSwap(AdminBanPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(banplayerid_, other->banplayerid_);
}

std::string AdminBanPlayerMessage::GetTypeName() const {
  return "AdminBanPlayerMessage";
}


// ===================================================================

class AdminBanPlayerAckMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AdminBanPlayerAckMessage>()._has_bits_);
  static void set_has_banplayerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_banplayerresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AdminBanPlayerAckMessage::AdminBanPlayerAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AdminBanPlayerAckMessage)
}
AdminBanPlayerAckMessage::AdminBanPlayerAckMessage(const AdminBanPlayerAckMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&banplayerid_, &from.banplayerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&banplayerresult_) -
    reinterpret_cast<char*>(&banplayerid_)) + sizeof(banplayerresult_));
  // @@protoc_insertion_point(copy_constructor:AdminBanPlayerAckMessage)
}

inline void AdminBanPlayerAckMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&banplayerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&banplayerresult_) -
    reinterpret_cast<char*>(&banplayerid_)) + sizeof(banplayerresult_));
}

AdminBanPlayerAckMessage::~AdminBanPlayerAckMessage() {
  // @@protoc_insertion_point(destructor:AdminBanPlayerAckMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AdminBanPlayerAckMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AdminBanPlayerAckMessage::ArenaDtor(void* object) {
  AdminBanPlayerAckMessage* _this = reinterpret_cast< AdminBanPlayerAckMessage* >(object);
  (void)_this;
}
void AdminBanPlayerAckMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdminBanPlayerAckMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdminBanPlayerAckMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AdminBanPlayerAckMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&banplayerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&banplayerresult_) -
        reinterpret_cast<char*>(&banplayerid_)) + sizeof(banplayerresult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AdminBanPlayerAckMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 banPlayerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_banplayerid(&has_bits);
          banplayerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(val))) {
            _internal_set_banplayerresult(static_cast<::AdminBanPlayerAckMessage_AdminBanPlayerResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdminBanPlayerAckMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdminBanPlayerAckMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 banPlayerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_banplayerid(), target);
  }

  // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_banplayerresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdminBanPlayerAckMessage)
  return target;
}

size_t AdminBanPlayerAckMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AdminBanPlayerAckMessage)
  size_t total_size = 0;

  if (_internal_has_banplayerid()) {
    // required uint32 banPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_banplayerid());
  }

  if (_internal_has_banplayerresult()) {
    // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_banplayerresult());
  }

  return total_size;
}
size_t AdminBanPlayerAckMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AdminBanPlayerAckMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 banPlayerId = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_banplayerid());

    // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_banplayerresult());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AdminBanPlayerAckMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AdminBanPlayerAckMessage*>(
      &from));
}

void AdminBanPlayerAckMessage::MergeFrom(const AdminBanPlayerAckMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AdminBanPlayerAckMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      banplayerid_ = from.banplayerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      banplayerresult_ = from.banplayerresult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AdminBanPlayerAckMessage::CopyFrom(const AdminBanPlayerAckMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AdminBanPlayerAckMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminBanPlayerAckMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AdminBanPlayerAckMessage::InternalSwap(AdminBanPlayerAckMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AdminBanPlayerAckMessage, banplayerresult_)
      + sizeof(AdminBanPlayerAckMessage::banplayerresult_)
      - PROTOBUF_FIELD_OFFSET(AdminBanPlayerAckMessage, banplayerid_)>(
          reinterpret_cast<char*>(&banplayerid_),
          reinterpret_cast<char*>(&other->banplayerid_));
}

std::string AdminBanPlayerAckMessage::GetTypeName() const {
  return "AdminBanPlayerAckMessage";
}


// ===================================================================

class PokerTHMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PokerTHMessage>()._has_bits_);
  static void set_has_messagetype(HasBits* has_bits) {
    (*has_bits)[2] |= 131072u;
  }
  static const ::AnnounceMessage& announcemessage(const PokerTHMessage* msg);
  static void set_has_announcemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::InitMessage& initmessage(const PokerTHMessage* msg);
  static void set_has_initmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::AuthServerChallengeMessage& authserverchallengemessage(const PokerTHMessage* msg);
  static void set_has_authserverchallengemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::AuthClientResponseMessage& authclientresponsemessage(const PokerTHMessage* msg);
  static void set_has_authclientresponsemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::AuthServerVerificationMessage& authserververificationmessage(const PokerTHMessage* msg);
  static void set_has_authserververificationmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::InitAckMessage& initackmessage(const PokerTHMessage* msg);
  static void set_has_initackmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::AvatarRequestMessage& avatarrequestmessage(const PokerTHMessage* msg);
  static void set_has_avatarrequestmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::AvatarHeaderMessage& avatarheadermessage(const PokerTHMessage* msg);
  static void set_has_avatarheadermessage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::AvatarDataMessage& avatardatamessage(const PokerTHMessage* msg);
  static void set_has_avatardatamessage(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::AvatarEndMessage& avatarendmessage(const PokerTHMessage* msg);
  static void set_has_avatarendmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::UnknownAvatarMessage& unknownavatarmessage(const PokerTHMessage* msg);
  static void set_has_unknownavatarmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::PlayerListMessage& playerlistmessage(const PokerTHMessage* msg);
  static void set_has_playerlistmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::GameListNewMessage& gamelistnewmessage(const PokerTHMessage* msg);
  static void set_has_gamelistnewmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::GameListUpdateMessage& gamelistupdatemessage(const PokerTHMessage* msg);
  static void set_has_gamelistupdatemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::GameListPlayerJoinedMessage& gamelistplayerjoinedmessage(const PokerTHMessage* msg);
  static void set_has_gamelistplayerjoinedmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::GameListPlayerLeftMessage& gamelistplayerleftmessage(const PokerTHMessage* msg);
  static void set_has_gamelistplayerleftmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::GameListAdminChangedMessage& gamelistadminchangedmessage(const PokerTHMessage* msg);
  static void set_has_gamelistadminchangedmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::PlayerInfoRequestMessage& playerinforequestmessage(const PokerTHMessage* msg);
  static void set_has_playerinforequestmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::PlayerInfoReplyMessage& playerinforeplymessage(const PokerTHMessage* msg);
  static void set_has_playerinforeplymessage(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::SubscriptionRequestMessage& subscriptionrequestmessage(const PokerTHMessage* msg);
  static void set_has_subscriptionrequestmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::JoinExistingGameMessage& joinexistinggamemessage(const PokerTHMessage* msg);
  static void set_has_joinexistinggamemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::JoinNewGameMessage& joinnewgamemessage(const PokerTHMessage* msg);
  static void set_has_joinnewgamemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::RejoinExistingGameMessage& rejoinexistinggamemessage(const PokerTHMessage* msg);
  static void set_has_rejoinexistinggamemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::JoinGameAckMessage& joingameackmessage(const PokerTHMessage* msg);
  static void set_has_joingameackmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::JoinGameFailedMessage& joingamefailedmessage(const PokerTHMessage* msg);
  static void set_has_joingamefailedmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::GamePlayerJoinedMessage& gameplayerjoinedmessage(const PokerTHMessage* msg);
  static void set_has_gameplayerjoinedmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::GamePlayerLeftMessage& gameplayerleftmessage(const PokerTHMessage* msg);
  static void set_has_gameplayerleftmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::GameAdminChangedMessage& gameadminchangedmessage(const PokerTHMessage* msg);
  static void set_has_gameadminchangedmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::RemovedFromGameMessage& removedfromgamemessage(const PokerTHMessage* msg);
  static void set_has_removedfromgamemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::KickPlayerRequestMessage& kickplayerrequestmessage(const PokerTHMessage* msg);
  static void set_has_kickplayerrequestmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::LeaveGameRequestMessage& leavegamerequestmessage(const PokerTHMessage* msg);
  static void set_has_leavegamerequestmessage(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::InvitePlayerToGameMessage& inviteplayertogamemessage(const PokerTHMessage* msg);
  static void set_has_inviteplayertogamemessage(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::InviteNotifyMessage& invitenotifymessage(const PokerTHMessage* msg);
  static void set_has_invitenotifymessage(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::RejectGameInvitationMessage& rejectgameinvitationmessage(const PokerTHMessage* msg);
  static void set_has_rejectgameinvitationmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::RejectInvNotifyMessage& rejectinvnotifymessage(const PokerTHMessage* msg);
  static void set_has_rejectinvnotifymessage(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::StartEventMessage& starteventmessage(const PokerTHMessage* msg);
  static void set_has_starteventmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::StartEventAckMessage& starteventackmessage(const PokerTHMessage* msg);
  static void set_has_starteventackmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::GameStartInitialMessage& gamestartinitialmessage(const PokerTHMessage* msg);
  static void set_has_gamestartinitialmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::GameStartRejoinMessage& gamestartrejoinmessage(const PokerTHMessage* msg);
  static void set_has_gamestartrejoinmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static const ::HandStartMessage& handstartmessage(const PokerTHMessage* msg);
  static void set_has_handstartmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static const ::PlayersTurnMessage& playersturnmessage(const PokerTHMessage* msg);
  static void set_has_playersturnmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static const ::MyActionRequestMessage& myactionrequestmessage(const PokerTHMessage* msg);
  static void set_has_myactionrequestmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static const ::YourActionRejectedMessage& youractionrejectedmessage(const PokerTHMessage* msg);
  static void set_has_youractionrejectedmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static const ::PlayersActionDoneMessage& playersactiondonemessage(const PokerTHMessage* msg);
  static void set_has_playersactiondonemessage(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static const ::DealFlopCardsMessage& dealflopcardsmessage(const PokerTHMessage* msg);
  static void set_has_dealflopcardsmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static const ::DealTurnCardMessage& dealturncardmessage(const PokerTHMessage* msg);
  static void set_has_dealturncardmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static const ::DealRiverCardMessage& dealrivercardmessage(const PokerTHMessage* msg);
  static void set_has_dealrivercardmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static const ::AllInShowCardsMessage& allinshowcardsmessage(const PokerTHMessage* msg);
  static void set_has_allinshowcardsmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static const ::EndOfHandShowCardsMessage& endofhandshowcardsmessage(const PokerTHMessage* msg);
  static void set_has_endofhandshowcardsmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static const ::EndOfHandHideCardsMessage& endofhandhidecardsmessage(const PokerTHMessage* msg);
  static void set_has_endofhandhidecardsmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static const ::ShowMyCardsRequestMessage& showmycardsrequestmessage(const PokerTHMessage* msg);
  static void set_has_showmycardsrequestmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static const ::AfterHandShowCardsMessage& afterhandshowcardsmessage(const PokerTHMessage* msg);
  static void set_has_afterhandshowcardsmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static const ::EndOfGameMessage& endofgamemessage(const PokerTHMessage* msg);
  static void set_has_endofgamemessage(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static const ::PlayerIdChangedMessage& playeridchangedmessage(const PokerTHMessage* msg);
  static void set_has_playeridchangedmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static const ::AskKickPlayerMessage& askkickplayermessage(const PokerTHMessage* msg);
  static void set_has_askkickplayermessage(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static const ::AskKickDeniedMessage& askkickdeniedmessage(const PokerTHMessage* msg);
  static void set_has_askkickdeniedmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static const ::StartKickPetitionMessage& startkickpetitionmessage(const PokerTHMessage* msg);
  static void set_has_startkickpetitionmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static const ::VoteKickRequestMessage& votekickrequestmessage(const PokerTHMessage* msg);
  static void set_has_votekickrequestmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static const ::VoteKickReplyMessage& votekickreplymessage(const PokerTHMessage* msg);
  static void set_has_votekickreplymessage(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static const ::KickPetitionUpdateMessage& kickpetitionupdatemessage(const PokerTHMessage* msg);
  static void set_has_kickpetitionupdatemessage(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static const ::EndKickPetitionMessage& endkickpetitionmessage(const PokerTHMessage* msg);
  static void set_has_endkickpetitionmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static const ::StatisticsMessage& statisticsmessage(const PokerTHMessage* msg);
  static void set_has_statisticsmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static const ::ChatRequestMessage& chatrequestmessage(const PokerTHMessage* msg);
  static void set_has_chatrequestmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static const ::ChatMessage& chatmessage(const PokerTHMessage* msg);
  static void set_has_chatmessage(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static const ::ChatRejectMessage& chatrejectmessage(const PokerTHMessage* msg);
  static void set_has_chatrejectmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static const ::DialogMessage& dialogmessage(const PokerTHMessage* msg);
  static void set_has_dialogmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static const ::TimeoutWarningMessage& timeoutwarningmessage(const PokerTHMessage* msg);
  static void set_has_timeoutwarningmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static const ::ResetTimeoutMessage& resettimeoutmessage(const PokerTHMessage* msg);
  static void set_has_resettimeoutmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static const ::ReportAvatarMessage& reportavatarmessage(const PokerTHMessage* msg);
  static void set_has_reportavatarmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static const ::ReportAvatarAckMessage& reportavatarackmessage(const PokerTHMessage* msg);
  static void set_has_reportavatarackmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
  static const ::ReportGameMessage& reportgamemessage(const PokerTHMessage* msg);
  static void set_has_reportgamemessage(HasBits* has_bits) {
    (*has_bits)[2] |= 64u;
  }
  static const ::ReportGameAckMessage& reportgameackmessage(const PokerTHMessage* msg);
  static void set_has_reportgameackmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 128u;
  }
  static const ::ErrorMessage& errormessage(const PokerTHMessage* msg);
  static void set_has_errormessage(HasBits* has_bits) {
    (*has_bits)[2] |= 256u;
  }
  static const ::AdminRemoveGameMessage& adminremovegamemessage(const PokerTHMessage* msg);
  static void set_has_adminremovegamemessage(HasBits* has_bits) {
    (*has_bits)[2] |= 512u;
  }
  static const ::AdminRemoveGameAckMessage& adminremovegameackmessage(const PokerTHMessage* msg);
  static void set_has_adminremovegameackmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 1024u;
  }
  static const ::AdminBanPlayerMessage& adminbanplayermessage(const PokerTHMessage* msg);
  static void set_has_adminbanplayermessage(HasBits* has_bits) {
    (*has_bits)[2] |= 2048u;
  }
  static const ::AdminBanPlayerAckMessage& adminbanplayerackmessage(const PokerTHMessage* msg);
  static void set_has_adminbanplayerackmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 4096u;
  }
  static const ::GameListSpectatorJoinedMessage& gamelistspectatorjoinedmessage(const PokerTHMessage* msg);
  static void set_has_gamelistspectatorjoinedmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 8192u;
  }
  static const ::GameListSpectatorLeftMessage& gamelistspectatorleftmessage(const PokerTHMessage* msg);
  static void set_has_gamelistspectatorleftmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 16384u;
  }
  static const ::GameSpectatorJoinedMessage& gamespectatorjoinedmessage(const PokerTHMessage* msg);
  static void set_has_gamespectatorjoinedmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 32768u;
  }
  static const ::GameSpectatorLeftMessage& gamespectatorleftmessage(const PokerTHMessage* msg);
  static void set_has_gamespectatorleftmessage(HasBits* has_bits) {
    (*has_bits)[2] |= 65536u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[2] & 0x00020000) ^ 0x00020000) != 0;
  }
};

const ::AnnounceMessage&
PokerTHMessage::_Internal::announcemessage(const PokerTHMessage* msg) {
  return *msg->announcemessage_;
}
const ::InitMessage&
PokerTHMessage::_Internal::initmessage(const PokerTHMessage* msg) {
  return *msg->initmessage_;
}
const ::AuthServerChallengeMessage&
PokerTHMessage::_Internal::authserverchallengemessage(const PokerTHMessage* msg) {
  return *msg->authserverchallengemessage_;
}
const ::AuthClientResponseMessage&
PokerTHMessage::_Internal::authclientresponsemessage(const PokerTHMessage* msg) {
  return *msg->authclientresponsemessage_;
}
const ::AuthServerVerificationMessage&
PokerTHMessage::_Internal::authserververificationmessage(const PokerTHMessage* msg) {
  return *msg->authserververificationmessage_;
}
const ::InitAckMessage&
PokerTHMessage::_Internal::initackmessage(const PokerTHMessage* msg) {
  return *msg->initackmessage_;
}
const ::AvatarRequestMessage&
PokerTHMessage::_Internal::avatarrequestmessage(const PokerTHMessage* msg) {
  return *msg->avatarrequestmessage_;
}
const ::AvatarHeaderMessage&
PokerTHMessage::_Internal::avatarheadermessage(const PokerTHMessage* msg) {
  return *msg->avatarheadermessage_;
}
const ::AvatarDataMessage&
PokerTHMessage::_Internal::avatardatamessage(const PokerTHMessage* msg) {
  return *msg->avatardatamessage_;
}
const ::AvatarEndMessage&
PokerTHMessage::_Internal::avatarendmessage(const PokerTHMessage* msg) {
  return *msg->avatarendmessage_;
}
const ::UnknownAvatarMessage&
PokerTHMessage::_Internal::unknownavatarmessage(const PokerTHMessage* msg) {
  return *msg->unknownavatarmessage_;
}
const ::PlayerListMessage&
PokerTHMessage::_Internal::playerlistmessage(const PokerTHMessage* msg) {
  return *msg->playerlistmessage_;
}
const ::GameListNewMessage&
PokerTHMessage::_Internal::gamelistnewmessage(const PokerTHMessage* msg) {
  return *msg->gamelistnewmessage_;
}
const ::GameListUpdateMessage&
PokerTHMessage::_Internal::gamelistupdatemessage(const PokerTHMessage* msg) {
  return *msg->gamelistupdatemessage_;
}
const ::GameListPlayerJoinedMessage&
PokerTHMessage::_Internal::gamelistplayerjoinedmessage(const PokerTHMessage* msg) {
  return *msg->gamelistplayerjoinedmessage_;
}
const ::GameListPlayerLeftMessage&
PokerTHMessage::_Internal::gamelistplayerleftmessage(const PokerTHMessage* msg) {
  return *msg->gamelistplayerleftmessage_;
}
const ::GameListAdminChangedMessage&
PokerTHMessage::_Internal::gamelistadminchangedmessage(const PokerTHMessage* msg) {
  return *msg->gamelistadminchangedmessage_;
}
const ::PlayerInfoRequestMessage&
PokerTHMessage::_Internal::playerinforequestmessage(const PokerTHMessage* msg) {
  return *msg->playerinforequestmessage_;
}
const ::PlayerInfoReplyMessage&
PokerTHMessage::_Internal::playerinforeplymessage(const PokerTHMessage* msg) {
  return *msg->playerinforeplymessage_;
}
const ::SubscriptionRequestMessage&
PokerTHMessage::_Internal::subscriptionrequestmessage(const PokerTHMessage* msg) {
  return *msg->subscriptionrequestmessage_;
}
const ::JoinExistingGameMessage&
PokerTHMessage::_Internal::joinexistinggamemessage(const PokerTHMessage* msg) {
  return *msg->joinexistinggamemessage_;
}
const ::JoinNewGameMessage&
PokerTHMessage::_Internal::joinnewgamemessage(const PokerTHMessage* msg) {
  return *msg->joinnewgamemessage_;
}
const ::RejoinExistingGameMessage&
PokerTHMessage::_Internal::rejoinexistinggamemessage(const PokerTHMessage* msg) {
  return *msg->rejoinexistinggamemessage_;
}
const ::JoinGameAckMessage&
PokerTHMessage::_Internal::joingameackmessage(const PokerTHMessage* msg) {
  return *msg->joingameackmessage_;
}
const ::JoinGameFailedMessage&
PokerTHMessage::_Internal::joingamefailedmessage(const PokerTHMessage* msg) {
  return *msg->joingamefailedmessage_;
}
const ::GamePlayerJoinedMessage&
PokerTHMessage::_Internal::gameplayerjoinedmessage(const PokerTHMessage* msg) {
  return *msg->gameplayerjoinedmessage_;
}
const ::GamePlayerLeftMessage&
PokerTHMessage::_Internal::gameplayerleftmessage(const PokerTHMessage* msg) {
  return *msg->gameplayerleftmessage_;
}
const ::GameAdminChangedMessage&
PokerTHMessage::_Internal::gameadminchangedmessage(const PokerTHMessage* msg) {
  return *msg->gameadminchangedmessage_;
}
const ::RemovedFromGameMessage&
PokerTHMessage::_Internal::removedfromgamemessage(const PokerTHMessage* msg) {
  return *msg->removedfromgamemessage_;
}
const ::KickPlayerRequestMessage&
PokerTHMessage::_Internal::kickplayerrequestmessage(const PokerTHMessage* msg) {
  return *msg->kickplayerrequestmessage_;
}
const ::LeaveGameRequestMessage&
PokerTHMessage::_Internal::leavegamerequestmessage(const PokerTHMessage* msg) {
  return *msg->leavegamerequestmessage_;
}
const ::InvitePlayerToGameMessage&
PokerTHMessage::_Internal::inviteplayertogamemessage(const PokerTHMessage* msg) {
  return *msg->inviteplayertogamemessage_;
}
const ::InviteNotifyMessage&
PokerTHMessage::_Internal::invitenotifymessage(const PokerTHMessage* msg) {
  return *msg->invitenotifymessage_;
}
const ::RejectGameInvitationMessage&
PokerTHMessage::_Internal::rejectgameinvitationmessage(const PokerTHMessage* msg) {
  return *msg->rejectgameinvitationmessage_;
}
const ::RejectInvNotifyMessage&
PokerTHMessage::_Internal::rejectinvnotifymessage(const PokerTHMessage* msg) {
  return *msg->rejectinvnotifymessage_;
}
const ::StartEventMessage&
PokerTHMessage::_Internal::starteventmessage(const PokerTHMessage* msg) {
  return *msg->starteventmessage_;
}
const ::StartEventAckMessage&
PokerTHMessage::_Internal::starteventackmessage(const PokerTHMessage* msg) {
  return *msg->starteventackmessage_;
}
const ::GameStartInitialMessage&
PokerTHMessage::_Internal::gamestartinitialmessage(const PokerTHMessage* msg) {
  return *msg->gamestartinitialmessage_;
}
const ::GameStartRejoinMessage&
PokerTHMessage::_Internal::gamestartrejoinmessage(const PokerTHMessage* msg) {
  return *msg->gamestartrejoinmessage_;
}
const ::HandStartMessage&
PokerTHMessage::_Internal::handstartmessage(const PokerTHMessage* msg) {
  return *msg->handstartmessage_;
}
const ::PlayersTurnMessage&
PokerTHMessage::_Internal::playersturnmessage(const PokerTHMessage* msg) {
  return *msg->playersturnmessage_;
}
const ::MyActionRequestMessage&
PokerTHMessage::_Internal::myactionrequestmessage(const PokerTHMessage* msg) {
  return *msg->myactionrequestmessage_;
}
const ::YourActionRejectedMessage&
PokerTHMessage::_Internal::youractionrejectedmessage(const PokerTHMessage* msg) {
  return *msg->youractionrejectedmessage_;
}
const ::PlayersActionDoneMessage&
PokerTHMessage::_Internal::playersactiondonemessage(const PokerTHMessage* msg) {
  return *msg->playersactiondonemessage_;
}
const ::DealFlopCardsMessage&
PokerTHMessage::_Internal::dealflopcardsmessage(const PokerTHMessage* msg) {
  return *msg->dealflopcardsmessage_;
}
const ::DealTurnCardMessage&
PokerTHMessage::_Internal::dealturncardmessage(const PokerTHMessage* msg) {
  return *msg->dealturncardmessage_;
}
const ::DealRiverCardMessage&
PokerTHMessage::_Internal::dealrivercardmessage(const PokerTHMessage* msg) {
  return *msg->dealrivercardmessage_;
}
const ::AllInShowCardsMessage&
PokerTHMessage::_Internal::allinshowcardsmessage(const PokerTHMessage* msg) {
  return *msg->allinshowcardsmessage_;
}
const ::EndOfHandShowCardsMessage&
PokerTHMessage::_Internal::endofhandshowcardsmessage(const PokerTHMessage* msg) {
  return *msg->endofhandshowcardsmessage_;
}
const ::EndOfHandHideCardsMessage&
PokerTHMessage::_Internal::endofhandhidecardsmessage(const PokerTHMessage* msg) {
  return *msg->endofhandhidecardsmessage_;
}
const ::ShowMyCardsRequestMessage&
PokerTHMessage::_Internal::showmycardsrequestmessage(const PokerTHMessage* msg) {
  return *msg->showmycardsrequestmessage_;
}
const ::AfterHandShowCardsMessage&
PokerTHMessage::_Internal::afterhandshowcardsmessage(const PokerTHMessage* msg) {
  return *msg->afterhandshowcardsmessage_;
}
const ::EndOfGameMessage&
PokerTHMessage::_Internal::endofgamemessage(const PokerTHMessage* msg) {
  return *msg->endofgamemessage_;
}
const ::PlayerIdChangedMessage&
PokerTHMessage::_Internal::playeridchangedmessage(const PokerTHMessage* msg) {
  return *msg->playeridchangedmessage_;
}
const ::AskKickPlayerMessage&
PokerTHMessage::_Internal::askkickplayermessage(const PokerTHMessage* msg) {
  return *msg->askkickplayermessage_;
}
const ::AskKickDeniedMessage&
PokerTHMessage::_Internal::askkickdeniedmessage(const PokerTHMessage* msg) {
  return *msg->askkickdeniedmessage_;
}
const ::StartKickPetitionMessage&
PokerTHMessage::_Internal::startkickpetitionmessage(const PokerTHMessage* msg) {
  return *msg->startkickpetitionmessage_;
}
const ::VoteKickRequestMessage&
PokerTHMessage::_Internal::votekickrequestmessage(const PokerTHMessage* msg) {
  return *msg->votekickrequestmessage_;
}
const ::VoteKickReplyMessage&
PokerTHMessage::_Internal::votekickreplymessage(const PokerTHMessage* msg) {
  return *msg->votekickreplymessage_;
}
const ::KickPetitionUpdateMessage&
PokerTHMessage::_Internal::kickpetitionupdatemessage(const PokerTHMessage* msg) {
  return *msg->kickpetitionupdatemessage_;
}
const ::EndKickPetitionMessage&
PokerTHMessage::_Internal::endkickpetitionmessage(const PokerTHMessage* msg) {
  return *msg->endkickpetitionmessage_;
}
const ::StatisticsMessage&
PokerTHMessage::_Internal::statisticsmessage(const PokerTHMessage* msg) {
  return *msg->statisticsmessage_;
}
const ::ChatRequestMessage&
PokerTHMessage::_Internal::chatrequestmessage(const PokerTHMessage* msg) {
  return *msg->chatrequestmessage_;
}
const ::ChatMessage&
PokerTHMessage::_Internal::chatmessage(const PokerTHMessage* msg) {
  return *msg->chatmessage_;
}
const ::ChatRejectMessage&
PokerTHMessage::_Internal::chatrejectmessage(const PokerTHMessage* msg) {
  return *msg->chatrejectmessage_;
}
const ::DialogMessage&
PokerTHMessage::_Internal::dialogmessage(const PokerTHMessage* msg) {
  return *msg->dialogmessage_;
}
const ::TimeoutWarningMessage&
PokerTHMessage::_Internal::timeoutwarningmessage(const PokerTHMessage* msg) {
  return *msg->timeoutwarningmessage_;
}
const ::ResetTimeoutMessage&
PokerTHMessage::_Internal::resettimeoutmessage(const PokerTHMessage* msg) {
  return *msg->resettimeoutmessage_;
}
const ::ReportAvatarMessage&
PokerTHMessage::_Internal::reportavatarmessage(const PokerTHMessage* msg) {
  return *msg->reportavatarmessage_;
}
const ::ReportAvatarAckMessage&
PokerTHMessage::_Internal::reportavatarackmessage(const PokerTHMessage* msg) {
  return *msg->reportavatarackmessage_;
}
const ::ReportGameMessage&
PokerTHMessage::_Internal::reportgamemessage(const PokerTHMessage* msg) {
  return *msg->reportgamemessage_;
}
const ::ReportGameAckMessage&
PokerTHMessage::_Internal::reportgameackmessage(const PokerTHMessage* msg) {
  return *msg->reportgameackmessage_;
}
const ::ErrorMessage&
PokerTHMessage::_Internal::errormessage(const PokerTHMessage* msg) {
  return *msg->errormessage_;
}
const ::AdminRemoveGameMessage&
PokerTHMessage::_Internal::adminremovegamemessage(const PokerTHMessage* msg) {
  return *msg->adminremovegamemessage_;
}
const ::AdminRemoveGameAckMessage&
PokerTHMessage::_Internal::adminremovegameackmessage(const PokerTHMessage* msg) {
  return *msg->adminremovegameackmessage_;
}
const ::AdminBanPlayerMessage&
PokerTHMessage::_Internal::adminbanplayermessage(const PokerTHMessage* msg) {
  return *msg->adminbanplayermessage_;
}
const ::AdminBanPlayerAckMessage&
PokerTHMessage::_Internal::adminbanplayerackmessage(const PokerTHMessage* msg) {
  return *msg->adminbanplayerackmessage_;
}
const ::GameListSpectatorJoinedMessage&
PokerTHMessage::_Internal::gamelistspectatorjoinedmessage(const PokerTHMessage* msg) {
  return *msg->gamelistspectatorjoinedmessage_;
}
const ::GameListSpectatorLeftMessage&
PokerTHMessage::_Internal::gamelistspectatorleftmessage(const PokerTHMessage* msg) {
  return *msg->gamelistspectatorleftmessage_;
}
const ::GameSpectatorJoinedMessage&
PokerTHMessage::_Internal::gamespectatorjoinedmessage(const PokerTHMessage* msg) {
  return *msg->gamespectatorjoinedmessage_;
}
const ::GameSpectatorLeftMessage&
PokerTHMessage::_Internal::gamespectatorleftmessage(const PokerTHMessage* msg) {
  return *msg->gamespectatorleftmessage_;
}
PokerTHMessage::PokerTHMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PokerTHMessage)
}
PokerTHMessage::PokerTHMessage(const PokerTHMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_announcemessage()) {
    announcemessage_ = new ::AnnounceMessage(*from.announcemessage_);
  } else {
    announcemessage_ = nullptr;
  }
  if (from._internal_has_initmessage()) {
    initmessage_ = new ::InitMessage(*from.initmessage_);
  } else {
    initmessage_ = nullptr;
  }
  if (from._internal_has_authserverchallengemessage()) {
    authserverchallengemessage_ = new ::AuthServerChallengeMessage(*from.authserverchallengemessage_);
  } else {
    authserverchallengemessage_ = nullptr;
  }
  if (from._internal_has_authclientresponsemessage()) {
    authclientresponsemessage_ = new ::AuthClientResponseMessage(*from.authclientresponsemessage_);
  } else {
    authclientresponsemessage_ = nullptr;
  }
  if (from._internal_has_authserververificationmessage()) {
    authserververificationmessage_ = new ::AuthServerVerificationMessage(*from.authserververificationmessage_);
  } else {
    authserververificationmessage_ = nullptr;
  }
  if (from._internal_has_initackmessage()) {
    initackmessage_ = new ::InitAckMessage(*from.initackmessage_);
  } else {
    initackmessage_ = nullptr;
  }
  if (from._internal_has_avatarrequestmessage()) {
    avatarrequestmessage_ = new ::AvatarRequestMessage(*from.avatarrequestmessage_);
  } else {
    avatarrequestmessage_ = nullptr;
  }
  if (from._internal_has_avatarheadermessage()) {
    avatarheadermessage_ = new ::AvatarHeaderMessage(*from.avatarheadermessage_);
  } else {
    avatarheadermessage_ = nullptr;
  }
  if (from._internal_has_avatardatamessage()) {
    avatardatamessage_ = new ::AvatarDataMessage(*from.avatardatamessage_);
  } else {
    avatardatamessage_ = nullptr;
  }
  if (from._internal_has_avatarendmessage()) {
    avatarendmessage_ = new ::AvatarEndMessage(*from.avatarendmessage_);
  } else {
    avatarendmessage_ = nullptr;
  }
  if (from._internal_has_unknownavatarmessage()) {
    unknownavatarmessage_ = new ::UnknownAvatarMessage(*from.unknownavatarmessage_);
  } else {
    unknownavatarmessage_ = nullptr;
  }
  if (from._internal_has_playerlistmessage()) {
    playerlistmessage_ = new ::PlayerListMessage(*from.playerlistmessage_);
  } else {
    playerlistmessage_ = nullptr;
  }
  if (from._internal_has_gamelistnewmessage()) {
    gamelistnewmessage_ = new ::GameListNewMessage(*from.gamelistnewmessage_);
  } else {
    gamelistnewmessage_ = nullptr;
  }
  if (from._internal_has_gamelistupdatemessage()) {
    gamelistupdatemessage_ = new ::GameListUpdateMessage(*from.gamelistupdatemessage_);
  } else {
    gamelistupdatemessage_ = nullptr;
  }
  if (from._internal_has_gamelistplayerjoinedmessage()) {
    gamelistplayerjoinedmessage_ = new ::GameListPlayerJoinedMessage(*from.gamelistplayerjoinedmessage_);
  } else {
    gamelistplayerjoinedmessage_ = nullptr;
  }
  if (from._internal_has_gamelistplayerleftmessage()) {
    gamelistplayerleftmessage_ = new ::GameListPlayerLeftMessage(*from.gamelistplayerleftmessage_);
  } else {
    gamelistplayerleftmessage_ = nullptr;
  }
  if (from._internal_has_gamelistadminchangedmessage()) {
    gamelistadminchangedmessage_ = new ::GameListAdminChangedMessage(*from.gamelistadminchangedmessage_);
  } else {
    gamelistadminchangedmessage_ = nullptr;
  }
  if (from._internal_has_playerinforequestmessage()) {
    playerinforequestmessage_ = new ::PlayerInfoRequestMessage(*from.playerinforequestmessage_);
  } else {
    playerinforequestmessage_ = nullptr;
  }
  if (from._internal_has_playerinforeplymessage()) {
    playerinforeplymessage_ = new ::PlayerInfoReplyMessage(*from.playerinforeplymessage_);
  } else {
    playerinforeplymessage_ = nullptr;
  }
  if (from._internal_has_subscriptionrequestmessage()) {
    subscriptionrequestmessage_ = new ::SubscriptionRequestMessage(*from.subscriptionrequestmessage_);
  } else {
    subscriptionrequestmessage_ = nullptr;
  }
  if (from._internal_has_joinexistinggamemessage()) {
    joinexistinggamemessage_ = new ::JoinExistingGameMessage(*from.joinexistinggamemessage_);
  } else {
    joinexistinggamemessage_ = nullptr;
  }
  if (from._internal_has_joinnewgamemessage()) {
    joinnewgamemessage_ = new ::JoinNewGameMessage(*from.joinnewgamemessage_);
  } else {
    joinnewgamemessage_ = nullptr;
  }
  if (from._internal_has_rejoinexistinggamemessage()) {
    rejoinexistinggamemessage_ = new ::RejoinExistingGameMessage(*from.rejoinexistinggamemessage_);
  } else {
    rejoinexistinggamemessage_ = nullptr;
  }
  if (from._internal_has_joingameackmessage()) {
    joingameackmessage_ = new ::JoinGameAckMessage(*from.joingameackmessage_);
  } else {
    joingameackmessage_ = nullptr;
  }
  if (from._internal_has_joingamefailedmessage()) {
    joingamefailedmessage_ = new ::JoinGameFailedMessage(*from.joingamefailedmessage_);
  } else {
    joingamefailedmessage_ = nullptr;
  }
  if (from._internal_has_gameplayerjoinedmessage()) {
    gameplayerjoinedmessage_ = new ::GamePlayerJoinedMessage(*from.gameplayerjoinedmessage_);
  } else {
    gameplayerjoinedmessage_ = nullptr;
  }
  if (from._internal_has_gameplayerleftmessage()) {
    gameplayerleftmessage_ = new ::GamePlayerLeftMessage(*from.gameplayerleftmessage_);
  } else {
    gameplayerleftmessage_ = nullptr;
  }
  if (from._internal_has_gameadminchangedmessage()) {
    gameadminchangedmessage_ = new ::GameAdminChangedMessage(*from.gameadminchangedmessage_);
  } else {
    gameadminchangedmessage_ = nullptr;
  }
  if (from._internal_has_removedfromgamemessage()) {
    removedfromgamemessage_ = new ::RemovedFromGameMessage(*from.removedfromgamemessage_);
  } else {
    removedfromgamemessage_ = nullptr;
  }
  if (from._internal_has_kickplayerrequestmessage()) {
    kickplayerrequestmessage_ = new ::KickPlayerRequestMessage(*from.kickplayerrequestmessage_);
  } else {
    kickplayerrequestmessage_ = nullptr;
  }
  if (from._internal_has_leavegamerequestmessage()) {
    leavegamerequestmessage_ = new ::LeaveGameRequestMessage(*from.leavegamerequestmessage_);
  } else {
    leavegamerequestmessage_ = nullptr;
  }
  if (from._internal_has_inviteplayertogamemessage()) {
    inviteplayertogamemessage_ = new ::InvitePlayerToGameMessage(*from.inviteplayertogamemessage_);
  } else {
    inviteplayertogamemessage_ = nullptr;
  }
  if (from._internal_has_invitenotifymessage()) {
    invitenotifymessage_ = new ::InviteNotifyMessage(*from.invitenotifymessage_);
  } else {
    invitenotifymessage_ = nullptr;
  }
  if (from._internal_has_rejectgameinvitationmessage()) {
    rejectgameinvitationmessage_ = new ::RejectGameInvitationMessage(*from.rejectgameinvitationmessage_);
  } else {
    rejectgameinvitationmessage_ = nullptr;
  }
  if (from._internal_has_rejectinvnotifymessage()) {
    rejectinvnotifymessage_ = new ::RejectInvNotifyMessage(*from.rejectinvnotifymessage_);
  } else {
    rejectinvnotifymessage_ = nullptr;
  }
  if (from._internal_has_starteventmessage()) {
    starteventmessage_ = new ::StartEventMessage(*from.starteventmessage_);
  } else {
    starteventmessage_ = nullptr;
  }
  if (from._internal_has_starteventackmessage()) {
    starteventackmessage_ = new ::StartEventAckMessage(*from.starteventackmessage_);
  } else {
    starteventackmessage_ = nullptr;
  }
  if (from._internal_has_gamestartinitialmessage()) {
    gamestartinitialmessage_ = new ::GameStartInitialMessage(*from.gamestartinitialmessage_);
  } else {
    gamestartinitialmessage_ = nullptr;
  }
  if (from._internal_has_gamestartrejoinmessage()) {
    gamestartrejoinmessage_ = new ::GameStartRejoinMessage(*from.gamestartrejoinmessage_);
  } else {
    gamestartrejoinmessage_ = nullptr;
  }
  if (from._internal_has_handstartmessage()) {
    handstartmessage_ = new ::HandStartMessage(*from.handstartmessage_);
  } else {
    handstartmessage_ = nullptr;
  }
  if (from._internal_has_playersturnmessage()) {
    playersturnmessage_ = new ::PlayersTurnMessage(*from.playersturnmessage_);
  } else {
    playersturnmessage_ = nullptr;
  }
  if (from._internal_has_myactionrequestmessage()) {
    myactionrequestmessage_ = new ::MyActionRequestMessage(*from.myactionrequestmessage_);
  } else {
    myactionrequestmessage_ = nullptr;
  }
  if (from._internal_has_youractionrejectedmessage()) {
    youractionrejectedmessage_ = new ::YourActionRejectedMessage(*from.youractionrejectedmessage_);
  } else {
    youractionrejectedmessage_ = nullptr;
  }
  if (from._internal_has_playersactiondonemessage()) {
    playersactiondonemessage_ = new ::PlayersActionDoneMessage(*from.playersactiondonemessage_);
  } else {
    playersactiondonemessage_ = nullptr;
  }
  if (from._internal_has_dealflopcardsmessage()) {
    dealflopcardsmessage_ = new ::DealFlopCardsMessage(*from.dealflopcardsmessage_);
  } else {
    dealflopcardsmessage_ = nullptr;
  }
  if (from._internal_has_dealturncardmessage()) {
    dealturncardmessage_ = new ::DealTurnCardMessage(*from.dealturncardmessage_);
  } else {
    dealturncardmessage_ = nullptr;
  }
  if (from._internal_has_dealrivercardmessage()) {
    dealrivercardmessage_ = new ::DealRiverCardMessage(*from.dealrivercardmessage_);
  } else {
    dealrivercardmessage_ = nullptr;
  }
  if (from._internal_has_allinshowcardsmessage()) {
    allinshowcardsmessage_ = new ::AllInShowCardsMessage(*from.allinshowcardsmessage_);
  } else {
    allinshowcardsmessage_ = nullptr;
  }
  if (from._internal_has_endofhandshowcardsmessage()) {
    endofhandshowcardsmessage_ = new ::EndOfHandShowCardsMessage(*from.endofhandshowcardsmessage_);
  } else {
    endofhandshowcardsmessage_ = nullptr;
  }
  if (from._internal_has_endofhandhidecardsmessage()) {
    endofhandhidecardsmessage_ = new ::EndOfHandHideCardsMessage(*from.endofhandhidecardsmessage_);
  } else {
    endofhandhidecardsmessage_ = nullptr;
  }
  if (from._internal_has_showmycardsrequestmessage()) {
    showmycardsrequestmessage_ = new ::ShowMyCardsRequestMessage(*from.showmycardsrequestmessage_);
  } else {
    showmycardsrequestmessage_ = nullptr;
  }
  if (from._internal_has_afterhandshowcardsmessage()) {
    afterhandshowcardsmessage_ = new ::AfterHandShowCardsMessage(*from.afterhandshowcardsmessage_);
  } else {
    afterhandshowcardsmessage_ = nullptr;
  }
  if (from._internal_has_endofgamemessage()) {
    endofgamemessage_ = new ::EndOfGameMessage(*from.endofgamemessage_);
  } else {
    endofgamemessage_ = nullptr;
  }
  if (from._internal_has_playeridchangedmessage()) {
    playeridchangedmessage_ = new ::PlayerIdChangedMessage(*from.playeridchangedmessage_);
  } else {
    playeridchangedmessage_ = nullptr;
  }
  if (from._internal_has_askkickplayermessage()) {
    askkickplayermessage_ = new ::AskKickPlayerMessage(*from.askkickplayermessage_);
  } else {
    askkickplayermessage_ = nullptr;
  }
  if (from._internal_has_askkickdeniedmessage()) {
    askkickdeniedmessage_ = new ::AskKickDeniedMessage(*from.askkickdeniedmessage_);
  } else {
    askkickdeniedmessage_ = nullptr;
  }
  if (from._internal_has_startkickpetitionmessage()) {
    startkickpetitionmessage_ = new ::StartKickPetitionMessage(*from.startkickpetitionmessage_);
  } else {
    startkickpetitionmessage_ = nullptr;
  }
  if (from._internal_has_votekickrequestmessage()) {
    votekickrequestmessage_ = new ::VoteKickRequestMessage(*from.votekickrequestmessage_);
  } else {
    votekickrequestmessage_ = nullptr;
  }
  if (from._internal_has_votekickreplymessage()) {
    votekickreplymessage_ = new ::VoteKickReplyMessage(*from.votekickreplymessage_);
  } else {
    votekickreplymessage_ = nullptr;
  }
  if (from._internal_has_kickpetitionupdatemessage()) {
    kickpetitionupdatemessage_ = new ::KickPetitionUpdateMessage(*from.kickpetitionupdatemessage_);
  } else {
    kickpetitionupdatemessage_ = nullptr;
  }
  if (from._internal_has_endkickpetitionmessage()) {
    endkickpetitionmessage_ = new ::EndKickPetitionMessage(*from.endkickpetitionmessage_);
  } else {
    endkickpetitionmessage_ = nullptr;
  }
  if (from._internal_has_statisticsmessage()) {
    statisticsmessage_ = new ::StatisticsMessage(*from.statisticsmessage_);
  } else {
    statisticsmessage_ = nullptr;
  }
  if (from._internal_has_chatrequestmessage()) {
    chatrequestmessage_ = new ::ChatRequestMessage(*from.chatrequestmessage_);
  } else {
    chatrequestmessage_ = nullptr;
  }
  if (from._internal_has_chatmessage()) {
    chatmessage_ = new ::ChatMessage(*from.chatmessage_);
  } else {
    chatmessage_ = nullptr;
  }
  if (from._internal_has_chatrejectmessage()) {
    chatrejectmessage_ = new ::ChatRejectMessage(*from.chatrejectmessage_);
  } else {
    chatrejectmessage_ = nullptr;
  }
  if (from._internal_has_dialogmessage()) {
    dialogmessage_ = new ::DialogMessage(*from.dialogmessage_);
  } else {
    dialogmessage_ = nullptr;
  }
  if (from._internal_has_timeoutwarningmessage()) {
    timeoutwarningmessage_ = new ::TimeoutWarningMessage(*from.timeoutwarningmessage_);
  } else {
    timeoutwarningmessage_ = nullptr;
  }
  if (from._internal_has_resettimeoutmessage()) {
    resettimeoutmessage_ = new ::ResetTimeoutMessage(*from.resettimeoutmessage_);
  } else {
    resettimeoutmessage_ = nullptr;
  }
  if (from._internal_has_reportavatarmessage()) {
    reportavatarmessage_ = new ::ReportAvatarMessage(*from.reportavatarmessage_);
  } else {
    reportavatarmessage_ = nullptr;
  }
  if (from._internal_has_reportavatarackmessage()) {
    reportavatarackmessage_ = new ::ReportAvatarAckMessage(*from.reportavatarackmessage_);
  } else {
    reportavatarackmessage_ = nullptr;
  }
  if (from._internal_has_reportgamemessage()) {
    reportgamemessage_ = new ::ReportGameMessage(*from.reportgamemessage_);
  } else {
    reportgamemessage_ = nullptr;
  }
  if (from._internal_has_reportgameackmessage()) {
    reportgameackmessage_ = new ::ReportGameAckMessage(*from.reportgameackmessage_);
  } else {
    reportgameackmessage_ = nullptr;
  }
  if (from._internal_has_errormessage()) {
    errormessage_ = new ::ErrorMessage(*from.errormessage_);
  } else {
    errormessage_ = nullptr;
  }
  if (from._internal_has_adminremovegamemessage()) {
    adminremovegamemessage_ = new ::AdminRemoveGameMessage(*from.adminremovegamemessage_);
  } else {
    adminremovegamemessage_ = nullptr;
  }
  if (from._internal_has_adminremovegameackmessage()) {
    adminremovegameackmessage_ = new ::AdminRemoveGameAckMessage(*from.adminremovegameackmessage_);
  } else {
    adminremovegameackmessage_ = nullptr;
  }
  if (from._internal_has_adminbanplayermessage()) {
    adminbanplayermessage_ = new ::AdminBanPlayerMessage(*from.adminbanplayermessage_);
  } else {
    adminbanplayermessage_ = nullptr;
  }
  if (from._internal_has_adminbanplayerackmessage()) {
    adminbanplayerackmessage_ = new ::AdminBanPlayerAckMessage(*from.adminbanplayerackmessage_);
  } else {
    adminbanplayerackmessage_ = nullptr;
  }
  if (from._internal_has_gamelistspectatorjoinedmessage()) {
    gamelistspectatorjoinedmessage_ = new ::GameListSpectatorJoinedMessage(*from.gamelistspectatorjoinedmessage_);
  } else {
    gamelistspectatorjoinedmessage_ = nullptr;
  }
  if (from._internal_has_gamelistspectatorleftmessage()) {
    gamelistspectatorleftmessage_ = new ::GameListSpectatorLeftMessage(*from.gamelistspectatorleftmessage_);
  } else {
    gamelistspectatorleftmessage_ = nullptr;
  }
  if (from._internal_has_gamespectatorjoinedmessage()) {
    gamespectatorjoinedmessage_ = new ::GameSpectatorJoinedMessage(*from.gamespectatorjoinedmessage_);
  } else {
    gamespectatorjoinedmessage_ = nullptr;
  }
  if (from._internal_has_gamespectatorleftmessage()) {
    gamespectatorleftmessage_ = new ::GameSpectatorLeftMessage(*from.gamespectatorleftmessage_);
  } else {
    gamespectatorleftmessage_ = nullptr;
  }
  messagetype_ = from.messagetype_;
  // @@protoc_insertion_point(copy_constructor:PokerTHMessage)
}

inline void PokerTHMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&announcemessage_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gamespectatorleftmessage_) -
    reinterpret_cast<char*>(&announcemessage_)) + sizeof(gamespectatorleftmessage_));
messagetype_ = 1;
}

PokerTHMessage::~PokerTHMessage() {
  // @@protoc_insertion_point(destructor:PokerTHMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PokerTHMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete announcemessage_;
  if (this != internal_default_instance()) delete initmessage_;
  if (this != internal_default_instance()) delete authserverchallengemessage_;
  if (this != internal_default_instance()) delete authclientresponsemessage_;
  if (this != internal_default_instance()) delete authserververificationmessage_;
  if (this != internal_default_instance()) delete initackmessage_;
  if (this != internal_default_instance()) delete avatarrequestmessage_;
  if (this != internal_default_instance()) delete avatarheadermessage_;
  if (this != internal_default_instance()) delete avatardatamessage_;
  if (this != internal_default_instance()) delete avatarendmessage_;
  if (this != internal_default_instance()) delete unknownavatarmessage_;
  if (this != internal_default_instance()) delete playerlistmessage_;
  if (this != internal_default_instance()) delete gamelistnewmessage_;
  if (this != internal_default_instance()) delete gamelistupdatemessage_;
  if (this != internal_default_instance()) delete gamelistplayerjoinedmessage_;
  if (this != internal_default_instance()) delete gamelistplayerleftmessage_;
  if (this != internal_default_instance()) delete gamelistadminchangedmessage_;
  if (this != internal_default_instance()) delete playerinforequestmessage_;
  if (this != internal_default_instance()) delete playerinforeplymessage_;
  if (this != internal_default_instance()) delete subscriptionrequestmessage_;
  if (this != internal_default_instance()) delete joinexistinggamemessage_;
  if (this != internal_default_instance()) delete joinnewgamemessage_;
  if (this != internal_default_instance()) delete rejoinexistinggamemessage_;
  if (this != internal_default_instance()) delete joingameackmessage_;
  if (this != internal_default_instance()) delete joingamefailedmessage_;
  if (this != internal_default_instance()) delete gameplayerjoinedmessage_;
  if (this != internal_default_instance()) delete gameplayerleftmessage_;
  if (this != internal_default_instance()) delete gameadminchangedmessage_;
  if (this != internal_default_instance()) delete removedfromgamemessage_;
  if (this != internal_default_instance()) delete kickplayerrequestmessage_;
  if (this != internal_default_instance()) delete leavegamerequestmessage_;
  if (this != internal_default_instance()) delete inviteplayertogamemessage_;
  if (this != internal_default_instance()) delete invitenotifymessage_;
  if (this != internal_default_instance()) delete rejectgameinvitationmessage_;
  if (this != internal_default_instance()) delete rejectinvnotifymessage_;
  if (this != internal_default_instance()) delete starteventmessage_;
  if (this != internal_default_instance()) delete starteventackmessage_;
  if (this != internal_default_instance()) delete gamestartinitialmessage_;
  if (this != internal_default_instance()) delete gamestartrejoinmessage_;
  if (this != internal_default_instance()) delete handstartmessage_;
  if (this != internal_default_instance()) delete playersturnmessage_;
  if (this != internal_default_instance()) delete myactionrequestmessage_;
  if (this != internal_default_instance()) delete youractionrejectedmessage_;
  if (this != internal_default_instance()) delete playersactiondonemessage_;
  if (this != internal_default_instance()) delete dealflopcardsmessage_;
  if (this != internal_default_instance()) delete dealturncardmessage_;
  if (this != internal_default_instance()) delete dealrivercardmessage_;
  if (this != internal_default_instance()) delete allinshowcardsmessage_;
  if (this != internal_default_instance()) delete endofhandshowcardsmessage_;
  if (this != internal_default_instance()) delete endofhandhidecardsmessage_;
  if (this != internal_default_instance()) delete showmycardsrequestmessage_;
  if (this != internal_default_instance()) delete afterhandshowcardsmessage_;
  if (this != internal_default_instance()) delete endofgamemessage_;
  if (this != internal_default_instance()) delete playeridchangedmessage_;
  if (this != internal_default_instance()) delete askkickplayermessage_;
  if (this != internal_default_instance()) delete askkickdeniedmessage_;
  if (this != internal_default_instance()) delete startkickpetitionmessage_;
  if (this != internal_default_instance()) delete votekickrequestmessage_;
  if (this != internal_default_instance()) delete votekickreplymessage_;
  if (this != internal_default_instance()) delete kickpetitionupdatemessage_;
  if (this != internal_default_instance()) delete endkickpetitionmessage_;
  if (this != internal_default_instance()) delete statisticsmessage_;
  if (this != internal_default_instance()) delete chatrequestmessage_;
  if (this != internal_default_instance()) delete chatmessage_;
  if (this != internal_default_instance()) delete chatrejectmessage_;
  if (this != internal_default_instance()) delete dialogmessage_;
  if (this != internal_default_instance()) delete timeoutwarningmessage_;
  if (this != internal_default_instance()) delete resettimeoutmessage_;
  if (this != internal_default_instance()) delete reportavatarmessage_;
  if (this != internal_default_instance()) delete reportavatarackmessage_;
  if (this != internal_default_instance()) delete reportgamemessage_;
  if (this != internal_default_instance()) delete reportgameackmessage_;
  if (this != internal_default_instance()) delete errormessage_;
  if (this != internal_default_instance()) delete adminremovegamemessage_;
  if (this != internal_default_instance()) delete adminremovegameackmessage_;
  if (this != internal_default_instance()) delete adminbanplayermessage_;
  if (this != internal_default_instance()) delete adminbanplayerackmessage_;
  if (this != internal_default_instance()) delete gamelistspectatorjoinedmessage_;
  if (this != internal_default_instance()) delete gamelistspectatorleftmessage_;
  if (this != internal_default_instance()) delete gamespectatorjoinedmessage_;
  if (this != internal_default_instance()) delete gamespectatorleftmessage_;
}

void PokerTHMessage::ArenaDtor(void* object) {
  PokerTHMessage* _this = reinterpret_cast< PokerTHMessage* >(object);
  (void)_this;
}
void PokerTHMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PokerTHMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PokerTHMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:PokerTHMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(announcemessage_ != nullptr);
      announcemessage_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(initmessage_ != nullptr);
      initmessage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(authserverchallengemessage_ != nullptr);
      authserverchallengemessage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(authclientresponsemessage_ != nullptr);
      authclientresponsemessage_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(authserververificationmessage_ != nullptr);
      authserververificationmessage_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(initackmessage_ != nullptr);
      initackmessage_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(avatarrequestmessage_ != nullptr);
      avatarrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(avatarheadermessage_ != nullptr);
      avatarheadermessage_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(avatardatamessage_ != nullptr);
      avatardatamessage_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(avatarendmessage_ != nullptr);
      avatarendmessage_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(unknownavatarmessage_ != nullptr);
      unknownavatarmessage_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(playerlistmessage_ != nullptr);
      playerlistmessage_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(gamelistnewmessage_ != nullptr);
      gamelistnewmessage_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(gamelistupdatemessage_ != nullptr);
      gamelistupdatemessage_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(gamelistplayerjoinedmessage_ != nullptr);
      gamelistplayerjoinedmessage_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(gamelistplayerleftmessage_ != nullptr);
      gamelistplayerleftmessage_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(gamelistadminchangedmessage_ != nullptr);
      gamelistadminchangedmessage_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(playerinforequestmessage_ != nullptr);
      playerinforequestmessage_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(playerinforeplymessage_ != nullptr);
      playerinforeplymessage_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(subscriptionrequestmessage_ != nullptr);
      subscriptionrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(joinexistinggamemessage_ != nullptr);
      joinexistinggamemessage_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(joinnewgamemessage_ != nullptr);
      joinnewgamemessage_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(rejoinexistinggamemessage_ != nullptr);
      rejoinexistinggamemessage_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(joingameackmessage_ != nullptr);
      joingameackmessage_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(joingamefailedmessage_ != nullptr);
      joingamefailedmessage_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(gameplayerjoinedmessage_ != nullptr);
      gameplayerjoinedmessage_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(gameplayerleftmessage_ != nullptr);
      gameplayerleftmessage_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(gameadminchangedmessage_ != nullptr);
      gameadminchangedmessage_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(removedfromgamemessage_ != nullptr);
      removedfromgamemessage_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(kickplayerrequestmessage_ != nullptr);
      kickplayerrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(leavegamerequestmessage_ != nullptr);
      leavegamerequestmessage_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(inviteplayertogamemessage_ != nullptr);
      inviteplayertogamemessage_->Clear();
    }
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(invitenotifymessage_ != nullptr);
      invitenotifymessage_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rejectgameinvitationmessage_ != nullptr);
      rejectgameinvitationmessage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rejectinvnotifymessage_ != nullptr);
      rejectinvnotifymessage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(starteventmessage_ != nullptr);
      starteventmessage_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(starteventackmessage_ != nullptr);
      starteventackmessage_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(gamestartinitialmessage_ != nullptr);
      gamestartinitialmessage_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(gamestartrejoinmessage_ != nullptr);
      gamestartrejoinmessage_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(handstartmessage_ != nullptr);
      handstartmessage_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(playersturnmessage_ != nullptr);
      playersturnmessage_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(myactionrequestmessage_ != nullptr);
      myactionrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(youractionrejectedmessage_ != nullptr);
      youractionrejectedmessage_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(playersactiondonemessage_ != nullptr);
      playersactiondonemessage_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(dealflopcardsmessage_ != nullptr);
      dealflopcardsmessage_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(dealturncardmessage_ != nullptr);
      dealturncardmessage_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(dealrivercardmessage_ != nullptr);
      dealrivercardmessage_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(allinshowcardsmessage_ != nullptr);
      allinshowcardsmessage_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(endofhandshowcardsmessage_ != nullptr);
      endofhandshowcardsmessage_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(endofhandhidecardsmessage_ != nullptr);
      endofhandhidecardsmessage_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(showmycardsrequestmessage_ != nullptr);
      showmycardsrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(afterhandshowcardsmessage_ != nullptr);
      afterhandshowcardsmessage_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(endofgamemessage_ != nullptr);
      endofgamemessage_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(playeridchangedmessage_ != nullptr);
      playeridchangedmessage_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(askkickplayermessage_ != nullptr);
      askkickplayermessage_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(askkickdeniedmessage_ != nullptr);
      askkickdeniedmessage_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(startkickpetitionmessage_ != nullptr);
      startkickpetitionmessage_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(votekickrequestmessage_ != nullptr);
      votekickrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(votekickreplymessage_ != nullptr);
      votekickreplymessage_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(kickpetitionupdatemessage_ != nullptr);
      kickpetitionupdatemessage_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(endkickpetitionmessage_ != nullptr);
      endkickpetitionmessage_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(statisticsmessage_ != nullptr);
      statisticsmessage_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(chatrequestmessage_ != nullptr);
      chatrequestmessage_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(chatmessage_ != nullptr);
      chatmessage_->Clear();
    }
  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(chatrejectmessage_ != nullptr);
      chatrejectmessage_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dialogmessage_ != nullptr);
      dialogmessage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(timeoutwarningmessage_ != nullptr);
      timeoutwarningmessage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(resettimeoutmessage_ != nullptr);
      resettimeoutmessage_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(reportavatarmessage_ != nullptr);
      reportavatarmessage_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(reportavatarackmessage_ != nullptr);
      reportavatarackmessage_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(reportgamemessage_ != nullptr);
      reportgamemessage_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(reportgameackmessage_ != nullptr);
      reportgameackmessage_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(errormessage_ != nullptr);
      errormessage_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(adminremovegamemessage_ != nullptr);
      adminremovegamemessage_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(adminremovegameackmessage_ != nullptr);
      adminremovegameackmessage_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(adminbanplayermessage_ != nullptr);
      adminbanplayermessage_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(adminbanplayerackmessage_ != nullptr);
      adminbanplayerackmessage_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(gamelistspectatorjoinedmessage_ != nullptr);
      gamelistspectatorjoinedmessage_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(gamelistspectatorleftmessage_ != nullptr);
      gamelistspectatorleftmessage_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(gamespectatorjoinedmessage_ != nullptr);
      gamespectatorjoinedmessage_->Clear();
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(gamespectatorleftmessage_ != nullptr);
      gamespectatorleftmessage_->Clear();
    }
    messagetype_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PokerTHMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PokerTHMessage.PokerTHMessageType messageType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PokerTHMessage_PokerTHMessageType_IsValid(val))) {
            _internal_set_messagetype(static_cast<::PokerTHMessage_PokerTHMessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .AnnounceMessage announceMessage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_announcemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .InitMessage initMessage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_initmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_authserverchallengemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AuthClientResponseMessage authClientResponseMessage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_authclientresponsemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_authserververificationmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .InitAckMessage initAckMessage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_initackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AvatarRequestMessage avatarRequestMessage = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_avatarrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_avatarheadermessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AvatarDataMessage avatarDataMessage = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_avatardatamessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AvatarEndMessage avatarEndMessage = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_avatarendmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_unknownavatarmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayerListMessage playerListMessage = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerlistmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListNewMessage gameListNewMessage = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistnewmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListUpdateMessage gameListUpdateMessage = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistupdatemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistplayerjoinedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistplayerleftmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistadminchangedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerinforequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerinforeplymessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscriptionrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_joinexistinggamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .JoinNewGameMessage joinNewGameMessage = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_joinnewgamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_rejoinexistinggamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .JoinGameAckMessage joinGameAckMessage = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_joingameackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_joingamefailedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameplayerjoinedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameplayerleftmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameadminchangedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .RemovedFromGameMessage removedFromGameMessage = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_removedfromgamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_kickplayerrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_leavegamerequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_inviteplayertogamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .InviteNotifyMessage inviteNotifyMessage = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_invitenotifymessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rejectgameinvitationmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rejectinvnotifymessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StartEventMessage startEventMessage = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_starteventmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StartEventAckMessage startEventAckMessage = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_starteventackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameStartInitialMessage gameStartInitialMessage = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamestartinitialmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamestartrejoinmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HandStartMessage handStartMessage = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_handstartmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayersTurnMessage playersTurnMessage = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_playersturnmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .MyActionRequestMessage myActionRequestMessage = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_myactionrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_youractionrejectedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_playersactiondonemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_dealflopcardsmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DealTurnCardMessage dealTurnCardMessage = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_dealturncardmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DealRiverCardMessage dealRiverCardMessage = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_dealrivercardmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_allinshowcardsmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_endofhandshowcardsmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_endofhandhidecardsmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_showmycardsrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_afterhandshowcardsmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EndOfGameMessage endOfGameMessage = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_endofgamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_playeridchangedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_askkickplayermessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_askkickdeniedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_startkickpetitionmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_votekickrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_votekickreplymessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_kickpetitionupdatemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_endkickpetitionmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StatisticsMessage statisticsMessage = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_statisticsmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ChatRequestMessage chatRequestMessage = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_chatrequestmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ChatMessage chatMessage = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chatmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ChatRejectMessage chatRejectMessage = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_chatrejectmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DialogMessage dialogMessage = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dialogmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeoutwarningmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_resettimeoutmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ReportAvatarMessage reportAvatarMessage = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_reportavatarmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_reportavatarackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ReportGameMessage reportGameMessage = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_reportgamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ReportGameAckMessage reportGameAckMessage = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_reportgameackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ErrorMessage errorMessage = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_errormessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_adminremovegamemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_adminremovegameackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_adminbanplayermessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_adminbanplayerackmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistspectatorjoinedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamelistspectatorleftmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamespectatorjoinedmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamespectatorleftmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PokerTHMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PokerTHMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[2];
  // required .PokerTHMessage.PokerTHMessageType messageType = 1;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_messagetype(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .AnnounceMessage announceMessage = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::announcemessage(this), target, stream);
  }

  // optional .InitMessage initMessage = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::initmessage(this), target, stream);
  }

  // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::authserverchallengemessage(this), target, stream);
  }

  // optional .AuthClientResponseMessage authClientResponseMessage = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::authclientresponsemessage(this), target, stream);
  }

  // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::authserververificationmessage(this), target, stream);
  }

  // optional .InitAckMessage initAckMessage = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::initackmessage(this), target, stream);
  }

  // optional .AvatarRequestMessage avatarRequestMessage = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::avatarrequestmessage(this), target, stream);
  }

  // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::avatarheadermessage(this), target, stream);
  }

  // optional .AvatarDataMessage avatarDataMessage = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::avatardatamessage(this), target, stream);
  }

  // optional .AvatarEndMessage avatarEndMessage = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::avatarendmessage(this), target, stream);
  }

  // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::unknownavatarmessage(this), target, stream);
  }

  // optional .PlayerListMessage playerListMessage = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::playerlistmessage(this), target, stream);
  }

  // optional .GameListNewMessage gameListNewMessage = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::gamelistnewmessage(this), target, stream);
  }

  // optional .GameListUpdateMessage gameListUpdateMessage = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::gamelistupdatemessage(this), target, stream);
  }

  // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::gamelistplayerjoinedmessage(this), target, stream);
  }

  // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::gamelistplayerleftmessage(this), target, stream);
  }

  // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::gamelistadminchangedmessage(this), target, stream);
  }

  // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::playerinforequestmessage(this), target, stream);
  }

  // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::playerinforeplymessage(this), target, stream);
  }

  // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::subscriptionrequestmessage(this), target, stream);
  }

  // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::joinexistinggamemessage(this), target, stream);
  }

  // optional .JoinNewGameMessage joinNewGameMessage = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::joinnewgamemessage(this), target, stream);
  }

  // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::rejoinexistinggamemessage(this), target, stream);
  }

  // optional .JoinGameAckMessage joinGameAckMessage = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::joingameackmessage(this), target, stream);
  }

  // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::joingamefailedmessage(this), target, stream);
  }

  // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::gameplayerjoinedmessage(this), target, stream);
  }

  // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        28, _Internal::gameplayerleftmessage(this), target, stream);
  }

  // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        29, _Internal::gameadminchangedmessage(this), target, stream);
  }

  // optional .RemovedFromGameMessage removedFromGameMessage = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::removedfromgamemessage(this), target, stream);
  }

  // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::kickplayerrequestmessage(this), target, stream);
  }

  // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::leavegamerequestmessage(this), target, stream);
  }

  // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        33, _Internal::inviteplayertogamemessage(this), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional .InviteNotifyMessage inviteNotifyMessage = 34;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        34, _Internal::invitenotifymessage(this), target, stream);
  }

  // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        35, _Internal::rejectgameinvitationmessage(this), target, stream);
  }

  // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        36, _Internal::rejectinvnotifymessage(this), target, stream);
  }

  // optional .StartEventMessage startEventMessage = 37;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        37, _Internal::starteventmessage(this), target, stream);
  }

  // optional .StartEventAckMessage startEventAckMessage = 38;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        38, _Internal::starteventackmessage(this), target, stream);
  }

  // optional .GameStartInitialMessage gameStartInitialMessage = 39;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        39, _Internal::gamestartinitialmessage(this), target, stream);
  }

  // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::gamestartrejoinmessage(this), target, stream);
  }

  // optional .HandStartMessage handStartMessage = 41;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        41, _Internal::handstartmessage(this), target, stream);
  }

  // optional .PlayersTurnMessage playersTurnMessage = 42;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        42, _Internal::playersturnmessage(this), target, stream);
  }

  // optional .MyActionRequestMessage myActionRequestMessage = 43;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        43, _Internal::myactionrequestmessage(this), target, stream);
  }

  // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        44, _Internal::youractionrejectedmessage(this), target, stream);
  }

  // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        45, _Internal::playersactiondonemessage(this), target, stream);
  }

  // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        46, _Internal::dealflopcardsmessage(this), target, stream);
  }

  // optional .DealTurnCardMessage dealTurnCardMessage = 47;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        47, _Internal::dealturncardmessage(this), target, stream);
  }

  // optional .DealRiverCardMessage dealRiverCardMessage = 48;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        48, _Internal::dealrivercardmessage(this), target, stream);
  }

  // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        49, _Internal::allinshowcardsmessage(this), target, stream);
  }

  // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        50, _Internal::endofhandshowcardsmessage(this), target, stream);
  }

  // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        51, _Internal::endofhandhidecardsmessage(this), target, stream);
  }

  // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        52, _Internal::showmycardsrequestmessage(this), target, stream);
  }

  // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        53, _Internal::afterhandshowcardsmessage(this), target, stream);
  }

  // optional .EndOfGameMessage endOfGameMessage = 54;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        54, _Internal::endofgamemessage(this), target, stream);
  }

  // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        55, _Internal::playeridchangedmessage(this), target, stream);
  }

  // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        56, _Internal::askkickplayermessage(this), target, stream);
  }

  // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        57, _Internal::askkickdeniedmessage(this), target, stream);
  }

  // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        58, _Internal::startkickpetitionmessage(this), target, stream);
  }

  // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        59, _Internal::votekickrequestmessage(this), target, stream);
  }

  // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        60, _Internal::votekickreplymessage(this), target, stream);
  }

  // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        61, _Internal::kickpetitionupdatemessage(this), target, stream);
  }

  // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        62, _Internal::endkickpetitionmessage(this), target, stream);
  }

  // optional .StatisticsMessage statisticsMessage = 63;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        63, _Internal::statisticsmessage(this), target, stream);
  }

  // optional .ChatRequestMessage chatRequestMessage = 64;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        64, _Internal::chatrequestmessage(this), target, stream);
  }

  // optional .ChatMessage chatMessage = 65;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        65, _Internal::chatmessage(this), target, stream);
  }

  cached_has_bits = _has_bits_[2];
  // optional .ChatRejectMessage chatRejectMessage = 66;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        66, _Internal::chatrejectmessage(this), target, stream);
  }

  // optional .DialogMessage dialogMessage = 67;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        67, _Internal::dialogmessage(this), target, stream);
  }

  // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        68, _Internal::timeoutwarningmessage(this), target, stream);
  }

  // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        69, _Internal::resettimeoutmessage(this), target, stream);
  }

  // optional .ReportAvatarMessage reportAvatarMessage = 70;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        70, _Internal::reportavatarmessage(this), target, stream);
  }

  // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        71, _Internal::reportavatarackmessage(this), target, stream);
  }

  // optional .ReportGameMessage reportGameMessage = 72;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        72, _Internal::reportgamemessage(this), target, stream);
  }

  // optional .ReportGameAckMessage reportGameAckMessage = 73;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        73, _Internal::reportgameackmessage(this), target, stream);
  }

  // optional .ErrorMessage errorMessage = 74;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        74, _Internal::errormessage(this), target, stream);
  }

  // optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        75, _Internal::adminremovegamemessage(this), target, stream);
  }

  // optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        76, _Internal::adminremovegameackmessage(this), target, stream);
  }

  // optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        77, _Internal::adminbanplayermessage(this), target, stream);
  }

  // optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        78, _Internal::adminbanplayerackmessage(this), target, stream);
  }

  // optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        79, _Internal::gamelistspectatorjoinedmessage(this), target, stream);
  }

  // optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        80, _Internal::gamelistspectatorleftmessage(this), target, stream);
  }

  // optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        81, _Internal::gamespectatorjoinedmessage(this), target, stream);
  }

  // optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        82, _Internal::gamespectatorleftmessage(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PokerTHMessage)
  return target;
}

size_t PokerTHMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PokerTHMessage)
  size_t total_size = 0;

  // required .PokerTHMessage.PokerTHMessageType messageType = 1;
  if (_internal_has_messagetype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_messagetype());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .AnnounceMessage announceMessage = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *announcemessage_);
    }

    // optional .InitMessage initMessage = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *initmessage_);
    }

    // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authserverchallengemessage_);
    }

    // optional .AuthClientResponseMessage authClientResponseMessage = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authclientresponsemessage_);
    }

    // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authserververificationmessage_);
    }

    // optional .InitAckMessage initAckMessage = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *initackmessage_);
    }

    // optional .AvatarRequestMessage avatarRequestMessage = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *avatarrequestmessage_);
    }

    // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *avatarheadermessage_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .AvatarDataMessage avatarDataMessage = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *avatardatamessage_);
    }

    // optional .AvatarEndMessage avatarEndMessage = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *avatarendmessage_);
    }

    // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *unknownavatarmessage_);
    }

    // optional .PlayerListMessage playerListMessage = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playerlistmessage_);
    }

    // optional .GameListNewMessage gameListNewMessage = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistnewmessage_);
    }

    // optional .GameListUpdateMessage gameListUpdateMessage = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistupdatemessage_);
    }

    // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistplayerjoinedmessage_);
    }

    // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistplayerleftmessage_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistadminchangedmessage_);
    }

    // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playerinforequestmessage_);
    }

    // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playerinforeplymessage_);
    }

    // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *subscriptionrequestmessage_);
    }

    // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joinexistinggamemessage_);
    }

    // optional .JoinNewGameMessage joinNewGameMessage = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joinnewgamemessage_);
    }

    // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rejoinexistinggamemessage_);
    }

    // optional .JoinGameAckMessage joinGameAckMessage = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joingameackmessage_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joingamefailedmessage_);
    }

    // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gameplayerjoinedmessage_);
    }

    // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gameplayerleftmessage_);
    }

    // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gameadminchangedmessage_);
    }

    // optional .RemovedFromGameMessage removedFromGameMessage = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *removedfromgamemessage_);
    }

    // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kickplayerrequestmessage_);
    }

    // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *leavegamerequestmessage_);
    }

    // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *inviteplayertogamemessage_);
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .InviteNotifyMessage inviteNotifyMessage = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *invitenotifymessage_);
    }

    // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rejectgameinvitationmessage_);
    }

    // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rejectinvnotifymessage_);
    }

    // optional .StartEventMessage startEventMessage = 37;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *starteventmessage_);
    }

    // optional .StartEventAckMessage startEventAckMessage = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *starteventackmessage_);
    }

    // optional .GameStartInitialMessage gameStartInitialMessage = 39;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamestartinitialmessage_);
    }

    // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamestartrejoinmessage_);
    }

    // optional .HandStartMessage handStartMessage = 41;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *handstartmessage_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .PlayersTurnMessage playersTurnMessage = 42;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playersturnmessage_);
    }

    // optional .MyActionRequestMessage myActionRequestMessage = 43;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *myactionrequestmessage_);
    }

    // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *youractionrejectedmessage_);
    }

    // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playersactiondonemessage_);
    }

    // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dealflopcardsmessage_);
    }

    // optional .DealTurnCardMessage dealTurnCardMessage = 47;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dealturncardmessage_);
    }

    // optional .DealRiverCardMessage dealRiverCardMessage = 48;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dealrivercardmessage_);
    }

    // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *allinshowcardsmessage_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endofhandshowcardsmessage_);
    }

    // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endofhandhidecardsmessage_);
    }

    // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *showmycardsrequestmessage_);
    }

    // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *afterhandshowcardsmessage_);
    }

    // optional .EndOfGameMessage endOfGameMessage = 54;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endofgamemessage_);
    }

    // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playeridchangedmessage_);
    }

    // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *askkickplayermessage_);
    }

    // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *askkickdeniedmessage_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *startkickpetitionmessage_);
    }

    // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *votekickrequestmessage_);
    }

    // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *votekickreplymessage_);
    }

    // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kickpetitionupdatemessage_);
    }

    // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endkickpetitionmessage_);
    }

    // optional .StatisticsMessage statisticsMessage = 63;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *statisticsmessage_);
    }

    // optional .ChatRequestMessage chatRequestMessage = 64;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chatrequestmessage_);
    }

    // optional .ChatMessage chatMessage = 65;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chatmessage_);
    }

  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ChatRejectMessage chatRejectMessage = 66;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chatrejectmessage_);
    }

    // optional .DialogMessage dialogMessage = 67;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dialogmessage_);
    }

    // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timeoutwarningmessage_);
    }

    // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *resettimeoutmessage_);
    }

    // optional .ReportAvatarMessage reportAvatarMessage = 70;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reportavatarmessage_);
    }

    // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reportavatarackmessage_);
    }

    // optional .ReportGameMessage reportGameMessage = 72;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reportgamemessage_);
    }

    // optional .ReportGameAckMessage reportGameAckMessage = 73;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reportgameackmessage_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .ErrorMessage errorMessage = 74;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *errormessage_);
    }

    // optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *adminremovegamemessage_);
    }

    // optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *adminremovegameackmessage_);
    }

    // optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *adminbanplayermessage_);
    }

    // optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *adminbanplayerackmessage_);
    }

    // optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistspectatorjoinedmessage_);
    }

    // optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamelistspectatorleftmessage_);
    }

    // optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gamespectatorjoinedmessage_);
    }

  }
  // optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gamespectatorleftmessage_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PokerTHMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PokerTHMessage*>(
      &from));
}

void PokerTHMessage::MergeFrom(const PokerTHMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PokerTHMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_announcemessage()->::AnnounceMessage::MergeFrom(from._internal_announcemessage());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_initmessage()->::InitMessage::MergeFrom(from._internal_initmessage());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_authserverchallengemessage()->::AuthServerChallengeMessage::MergeFrom(from._internal_authserverchallengemessage());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_authclientresponsemessage()->::AuthClientResponseMessage::MergeFrom(from._internal_authclientresponsemessage());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_authserververificationmessage()->::AuthServerVerificationMessage::MergeFrom(from._internal_authserververificationmessage());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_initackmessage()->::InitAckMessage::MergeFrom(from._internal_initackmessage());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_avatarrequestmessage()->::AvatarRequestMessage::MergeFrom(from._internal_avatarrequestmessage());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_avatarheadermessage()->::AvatarHeaderMessage::MergeFrom(from._internal_avatarheadermessage());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_avatardatamessage()->::AvatarDataMessage::MergeFrom(from._internal_avatardatamessage());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_avatarendmessage()->::AvatarEndMessage::MergeFrom(from._internal_avatarendmessage());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_unknownavatarmessage()->::UnknownAvatarMessage::MergeFrom(from._internal_unknownavatarmessage());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_playerlistmessage()->::PlayerListMessage::MergeFrom(from._internal_playerlistmessage());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_gamelistnewmessage()->::GameListNewMessage::MergeFrom(from._internal_gamelistnewmessage());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_gamelistupdatemessage()->::GameListUpdateMessage::MergeFrom(from._internal_gamelistupdatemessage());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_gamelistplayerjoinedmessage()->::GameListPlayerJoinedMessage::MergeFrom(from._internal_gamelistplayerjoinedmessage());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_gamelistplayerleftmessage()->::GameListPlayerLeftMessage::MergeFrom(from._internal_gamelistplayerleftmessage());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_gamelistadminchangedmessage()->::GameListAdminChangedMessage::MergeFrom(from._internal_gamelistadminchangedmessage());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_playerinforequestmessage()->::PlayerInfoRequestMessage::MergeFrom(from._internal_playerinforequestmessage());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_playerinforeplymessage()->::PlayerInfoReplyMessage::MergeFrom(from._internal_playerinforeplymessage());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_mutable_subscriptionrequestmessage()->::SubscriptionRequestMessage::MergeFrom(from._internal_subscriptionrequestmessage());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_joinexistinggamemessage()->::JoinExistingGameMessage::MergeFrom(from._internal_joinexistinggamemessage());
    }
    if (cached_has_bits & 0x00200000u) {
      _internal_mutable_joinnewgamemessage()->::JoinNewGameMessage::MergeFrom(from._internal_joinnewgamemessage());
    }
    if (cached_has_bits & 0x00400000u) {
      _internal_mutable_rejoinexistinggamemessage()->::RejoinExistingGameMessage::MergeFrom(from._internal_rejoinexistinggamemessage());
    }
    if (cached_has_bits & 0x00800000u) {
      _internal_mutable_joingameackmessage()->::JoinGameAckMessage::MergeFrom(from._internal_joingameackmessage());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _internal_mutable_joingamefailedmessage()->::JoinGameFailedMessage::MergeFrom(from._internal_joingamefailedmessage());
    }
    if (cached_has_bits & 0x02000000u) {
      _internal_mutable_gameplayerjoinedmessage()->::GamePlayerJoinedMessage::MergeFrom(from._internal_gameplayerjoinedmessage());
    }
    if (cached_has_bits & 0x04000000u) {
      _internal_mutable_gameplayerleftmessage()->::GamePlayerLeftMessage::MergeFrom(from._internal_gameplayerleftmessage());
    }
    if (cached_has_bits & 0x08000000u) {
      _internal_mutable_gameadminchangedmessage()->::GameAdminChangedMessage::MergeFrom(from._internal_gameadminchangedmessage());
    }
    if (cached_has_bits & 0x10000000u) {
      _internal_mutable_removedfromgamemessage()->::RemovedFromGameMessage::MergeFrom(from._internal_removedfromgamemessage());
    }
    if (cached_has_bits & 0x20000000u) {
      _internal_mutable_kickplayerrequestmessage()->::KickPlayerRequestMessage::MergeFrom(from._internal_kickplayerrequestmessage());
    }
    if (cached_has_bits & 0x40000000u) {
      _internal_mutable_leavegamerequestmessage()->::LeaveGameRequestMessage::MergeFrom(from._internal_leavegamerequestmessage());
    }
    if (cached_has_bits & 0x80000000u) {
      _internal_mutable_inviteplayertogamemessage()->::InvitePlayerToGameMessage::MergeFrom(from._internal_inviteplayertogamemessage());
    }
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_invitenotifymessage()->::InviteNotifyMessage::MergeFrom(from._internal_invitenotifymessage());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rejectgameinvitationmessage()->::RejectGameInvitationMessage::MergeFrom(from._internal_rejectgameinvitationmessage());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rejectinvnotifymessage()->::RejectInvNotifyMessage::MergeFrom(from._internal_rejectinvnotifymessage());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_starteventmessage()->::StartEventMessage::MergeFrom(from._internal_starteventmessage());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_starteventackmessage()->::StartEventAckMessage::MergeFrom(from._internal_starteventackmessage());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_gamestartinitialmessage()->::GameStartInitialMessage::MergeFrom(from._internal_gamestartinitialmessage());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_gamestartrejoinmessage()->::GameStartRejoinMessage::MergeFrom(from._internal_gamestartrejoinmessage());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_handstartmessage()->::HandStartMessage::MergeFrom(from._internal_handstartmessage());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_playersturnmessage()->::PlayersTurnMessage::MergeFrom(from._internal_playersturnmessage());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_myactionrequestmessage()->::MyActionRequestMessage::MergeFrom(from._internal_myactionrequestmessage());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_youractionrejectedmessage()->::YourActionRejectedMessage::MergeFrom(from._internal_youractionrejectedmessage());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_playersactiondonemessage()->::PlayersActionDoneMessage::MergeFrom(from._internal_playersactiondonemessage());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_dealflopcardsmessage()->::DealFlopCardsMessage::MergeFrom(from._internal_dealflopcardsmessage());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_dealturncardmessage()->::DealTurnCardMessage::MergeFrom(from._internal_dealturncardmessage());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_dealrivercardmessage()->::DealRiverCardMessage::MergeFrom(from._internal_dealrivercardmessage());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_allinshowcardsmessage()->::AllInShowCardsMessage::MergeFrom(from._internal_allinshowcardsmessage());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_endofhandshowcardsmessage()->::EndOfHandShowCardsMessage::MergeFrom(from._internal_endofhandshowcardsmessage());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_endofhandhidecardsmessage()->::EndOfHandHideCardsMessage::MergeFrom(from._internal_endofhandhidecardsmessage());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_showmycardsrequestmessage()->::ShowMyCardsRequestMessage::MergeFrom(from._internal_showmycardsrequestmessage());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_mutable_afterhandshowcardsmessage()->::AfterHandShowCardsMessage::MergeFrom(from._internal_afterhandshowcardsmessage());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_endofgamemessage()->::EndOfGameMessage::MergeFrom(from._internal_endofgamemessage());
    }
    if (cached_has_bits & 0x00200000u) {
      _internal_mutable_playeridchangedmessage()->::PlayerIdChangedMessage::MergeFrom(from._internal_playeridchangedmessage());
    }
    if (cached_has_bits & 0x00400000u) {
      _internal_mutable_askkickplayermessage()->::AskKickPlayerMessage::MergeFrom(from._internal_askkickplayermessage());
    }
    if (cached_has_bits & 0x00800000u) {
      _internal_mutable_askkickdeniedmessage()->::AskKickDeniedMessage::MergeFrom(from._internal_askkickdeniedmessage());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _internal_mutable_startkickpetitionmessage()->::StartKickPetitionMessage::MergeFrom(from._internal_startkickpetitionmessage());
    }
    if (cached_has_bits & 0x02000000u) {
      _internal_mutable_votekickrequestmessage()->::VoteKickRequestMessage::MergeFrom(from._internal_votekickrequestmessage());
    }
    if (cached_has_bits & 0x04000000u) {
      _internal_mutable_votekickreplymessage()->::VoteKickReplyMessage::MergeFrom(from._internal_votekickreplymessage());
    }
    if (cached_has_bits & 0x08000000u) {
      _internal_mutable_kickpetitionupdatemessage()->::KickPetitionUpdateMessage::MergeFrom(from._internal_kickpetitionupdatemessage());
    }
    if (cached_has_bits & 0x10000000u) {
      _internal_mutable_endkickpetitionmessage()->::EndKickPetitionMessage::MergeFrom(from._internal_endkickpetitionmessage());
    }
    if (cached_has_bits & 0x20000000u) {
      _internal_mutable_statisticsmessage()->::StatisticsMessage::MergeFrom(from._internal_statisticsmessage());
    }
    if (cached_has_bits & 0x40000000u) {
      _internal_mutable_chatrequestmessage()->::ChatRequestMessage::MergeFrom(from._internal_chatrequestmessage());
    }
    if (cached_has_bits & 0x80000000u) {
      _internal_mutable_chatmessage()->::ChatMessage::MergeFrom(from._internal_chatmessage());
    }
  }
  cached_has_bits = from._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_chatrejectmessage()->::ChatRejectMessage::MergeFrom(from._internal_chatrejectmessage());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_dialogmessage()->::DialogMessage::MergeFrom(from._internal_dialogmessage());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_timeoutwarningmessage()->::TimeoutWarningMessage::MergeFrom(from._internal_timeoutwarningmessage());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_resettimeoutmessage()->::ResetTimeoutMessage::MergeFrom(from._internal_resettimeoutmessage());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_reportavatarmessage()->::ReportAvatarMessage::MergeFrom(from._internal_reportavatarmessage());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_reportavatarackmessage()->::ReportAvatarAckMessage::MergeFrom(from._internal_reportavatarackmessage());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_reportgamemessage()->::ReportGameMessage::MergeFrom(from._internal_reportgamemessage());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_reportgameackmessage()->::ReportGameAckMessage::MergeFrom(from._internal_reportgameackmessage());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_errormessage()->::ErrorMessage::MergeFrom(from._internal_errormessage());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_adminremovegamemessage()->::AdminRemoveGameMessage::MergeFrom(from._internal_adminremovegamemessage());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_adminremovegameackmessage()->::AdminRemoveGameAckMessage::MergeFrom(from._internal_adminremovegameackmessage());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_adminbanplayermessage()->::AdminBanPlayerMessage::MergeFrom(from._internal_adminbanplayermessage());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_adminbanplayerackmessage()->::AdminBanPlayerAckMessage::MergeFrom(from._internal_adminbanplayerackmessage());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_gamelistspectatorjoinedmessage()->::GameListSpectatorJoinedMessage::MergeFrom(from._internal_gamelistspectatorjoinedmessage());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_gamelistspectatorleftmessage()->::GameListSpectatorLeftMessage::MergeFrom(from._internal_gamelistspectatorleftmessage());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_gamespectatorjoinedmessage()->::GameSpectatorJoinedMessage::MergeFrom(from._internal_gamespectatorjoinedmessage());
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_gamespectatorleftmessage()->::GameSpectatorLeftMessage::MergeFrom(from._internal_gamespectatorleftmessage());
    }
    if (cached_has_bits & 0x00020000u) {
      messagetype_ = from.messagetype_;
    }
    _has_bits_[2] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PokerTHMessage::CopyFrom(const PokerTHMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PokerTHMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PokerTHMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_announcemessage()) {
    if (!announcemessage_->IsInitialized()) return false;
  }
  if (_internal_has_initmessage()) {
    if (!initmessage_->IsInitialized()) return false;
  }
  if (_internal_has_authserverchallengemessage()) {
    if (!authserverchallengemessage_->IsInitialized()) return false;
  }
  if (_internal_has_authclientresponsemessage()) {
    if (!authclientresponsemessage_->IsInitialized()) return false;
  }
  if (_internal_has_authserververificationmessage()) {
    if (!authserververificationmessage_->IsInitialized()) return false;
  }
  if (_internal_has_initackmessage()) {
    if (!initackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_avatarrequestmessage()) {
    if (!avatarrequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_avatarheadermessage()) {
    if (!avatarheadermessage_->IsInitialized()) return false;
  }
  if (_internal_has_avatardatamessage()) {
    if (!avatardatamessage_->IsInitialized()) return false;
  }
  if (_internal_has_avatarendmessage()) {
    if (!avatarendmessage_->IsInitialized()) return false;
  }
  if (_internal_has_unknownavatarmessage()) {
    if (!unknownavatarmessage_->IsInitialized()) return false;
  }
  if (_internal_has_playerlistmessage()) {
    if (!playerlistmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistnewmessage()) {
    if (!gamelistnewmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistupdatemessage()) {
    if (!gamelistupdatemessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistplayerjoinedmessage()) {
    if (!gamelistplayerjoinedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistplayerleftmessage()) {
    if (!gamelistplayerleftmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistadminchangedmessage()) {
    if (!gamelistadminchangedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_playerinforeplymessage()) {
    if (!playerinforeplymessage_->IsInitialized()) return false;
  }
  if (_internal_has_subscriptionrequestmessage()) {
    if (!subscriptionrequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_joinexistinggamemessage()) {
    if (!joinexistinggamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_joinnewgamemessage()) {
    if (!joinnewgamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_rejoinexistinggamemessage()) {
    if (!rejoinexistinggamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_joingameackmessage()) {
    if (!joingameackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_joingamefailedmessage()) {
    if (!joingamefailedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gameplayerjoinedmessage()) {
    if (!gameplayerjoinedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gameplayerleftmessage()) {
    if (!gameplayerleftmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gameadminchangedmessage()) {
    if (!gameadminchangedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_removedfromgamemessage()) {
    if (!removedfromgamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_kickplayerrequestmessage()) {
    if (!kickplayerrequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_leavegamerequestmessage()) {
    if (!leavegamerequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_inviteplayertogamemessage()) {
    if (!inviteplayertogamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_invitenotifymessage()) {
    if (!invitenotifymessage_->IsInitialized()) return false;
  }
  if (_internal_has_rejectgameinvitationmessage()) {
    if (!rejectgameinvitationmessage_->IsInitialized()) return false;
  }
  if (_internal_has_rejectinvnotifymessage()) {
    if (!rejectinvnotifymessage_->IsInitialized()) return false;
  }
  if (_internal_has_starteventmessage()) {
    if (!starteventmessage_->IsInitialized()) return false;
  }
  if (_internal_has_starteventackmessage()) {
    if (!starteventackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamestartinitialmessage()) {
    if (!gamestartinitialmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamestartrejoinmessage()) {
    if (!gamestartrejoinmessage_->IsInitialized()) return false;
  }
  if (_internal_has_handstartmessage()) {
    if (!handstartmessage_->IsInitialized()) return false;
  }
  if (_internal_has_playersturnmessage()) {
    if (!playersturnmessage_->IsInitialized()) return false;
  }
  if (_internal_has_myactionrequestmessage()) {
    if (!myactionrequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_youractionrejectedmessage()) {
    if (!youractionrejectedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_playersactiondonemessage()) {
    if (!playersactiondonemessage_->IsInitialized()) return false;
  }
  if (_internal_has_dealflopcardsmessage()) {
    if (!dealflopcardsmessage_->IsInitialized()) return false;
  }
  if (_internal_has_dealturncardmessage()) {
    if (!dealturncardmessage_->IsInitialized()) return false;
  }
  if (_internal_has_dealrivercardmessage()) {
    if (!dealrivercardmessage_->IsInitialized()) return false;
  }
  if (_internal_has_allinshowcardsmessage()) {
    if (!allinshowcardsmessage_->IsInitialized()) return false;
  }
  if (_internal_has_endofhandshowcardsmessage()) {
    if (!endofhandshowcardsmessage_->IsInitialized()) return false;
  }
  if (_internal_has_endofhandhidecardsmessage()) {
    if (!endofhandhidecardsmessage_->IsInitialized()) return false;
  }
  if (_internal_has_afterhandshowcardsmessage()) {
    if (!afterhandshowcardsmessage_->IsInitialized()) return false;
  }
  if (_internal_has_endofgamemessage()) {
    if (!endofgamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_playeridchangedmessage()) {
    if (!playeridchangedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_askkickplayermessage()) {
    if (!askkickplayermessage_->IsInitialized()) return false;
  }
  if (_internal_has_askkickdeniedmessage()) {
    if (!askkickdeniedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_startkickpetitionmessage()) {
    if (!startkickpetitionmessage_->IsInitialized()) return false;
  }
  if (_internal_has_votekickrequestmessage()) {
    if (!votekickrequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_votekickreplymessage()) {
    if (!votekickreplymessage_->IsInitialized()) return false;
  }
  if (_internal_has_kickpetitionupdatemessage()) {
    if (!kickpetitionupdatemessage_->IsInitialized()) return false;
  }
  if (_internal_has_endkickpetitionmessage()) {
    if (!endkickpetitionmessage_->IsInitialized()) return false;
  }
  if (_internal_has_statisticsmessage()) {
    if (!statisticsmessage_->IsInitialized()) return false;
  }
  if (_internal_has_chatrequestmessage()) {
    if (!chatrequestmessage_->IsInitialized()) return false;
  }
  if (_internal_has_chatmessage()) {
    if (!chatmessage_->IsInitialized()) return false;
  }
  if (_internal_has_chatrejectmessage()) {
    if (!chatrejectmessage_->IsInitialized()) return false;
  }
  if (_internal_has_dialogmessage()) {
    if (!dialogmessage_->IsInitialized()) return false;
  }
  if (_internal_has_timeoutwarningmessage()) {
    if (!timeoutwarningmessage_->IsInitialized()) return false;
  }
  if (_internal_has_reportavatarmessage()) {
    if (!reportavatarmessage_->IsInitialized()) return false;
  }
  if (_internal_has_reportavatarackmessage()) {
    if (!reportavatarackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_reportgamemessage()) {
    if (!reportgamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_reportgameackmessage()) {
    if (!reportgameackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_errormessage()) {
    if (!errormessage_->IsInitialized()) return false;
  }
  if (_internal_has_adminremovegamemessage()) {
    if (!adminremovegamemessage_->IsInitialized()) return false;
  }
  if (_internal_has_adminremovegameackmessage()) {
    if (!adminremovegameackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_adminbanplayermessage()) {
    if (!adminbanplayermessage_->IsInitialized()) return false;
  }
  if (_internal_has_adminbanplayerackmessage()) {
    if (!adminbanplayerackmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistspectatorjoinedmessage()) {
    if (!gamelistspectatorjoinedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamelistspectatorleftmessage()) {
    if (!gamelistspectatorleftmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamespectatorjoinedmessage()) {
    if (!gamespectatorjoinedmessage_->IsInitialized()) return false;
  }
  if (_internal_has_gamespectatorleftmessage()) {
    if (!gamespectatorleftmessage_->IsInitialized()) return false;
  }
  return true;
}

void PokerTHMessage::InternalSwap(PokerTHMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(_has_bits_[2], other->_has_bits_[2]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PokerTHMessage, gamespectatorleftmessage_)
      + sizeof(PokerTHMessage::gamespectatorleftmessage_)
      - PROTOBUF_FIELD_OFFSET(PokerTHMessage, announcemessage_)>(
          reinterpret_cast<char*>(&announcemessage_),
          reinterpret_cast<char*>(&other->announcemessage_));
  swap(messagetype_, other->messagetype_);
}

std::string PokerTHMessage::GetTypeName() const {
  return "PokerTHMessage";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::NetGameInfo* Arena::CreateMaybeMessage< ::NetGameInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::NetGameInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerResult* Arena::CreateMaybeMessage< ::PlayerResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerResult >(arena);
}
template<> PROTOBUF_NOINLINE ::AnnounceMessage_Version* Arena::CreateMaybeMessage< ::AnnounceMessage_Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AnnounceMessage_Version >(arena);
}
template<> PROTOBUF_NOINLINE ::AnnounceMessage* Arena::CreateMaybeMessage< ::AnnounceMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AnnounceMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::InitMessage* Arena::CreateMaybeMessage< ::InitMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AuthServerChallengeMessage* Arena::CreateMaybeMessage< ::AuthServerChallengeMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AuthServerChallengeMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AuthClientResponseMessage* Arena::CreateMaybeMessage< ::AuthClientResponseMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AuthClientResponseMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AuthServerVerificationMessage* Arena::CreateMaybeMessage< ::AuthServerVerificationMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AuthServerVerificationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::InitAckMessage* Arena::CreateMaybeMessage< ::InitAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AvatarRequestMessage* Arena::CreateMaybeMessage< ::AvatarRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AvatarRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AvatarHeaderMessage* Arena::CreateMaybeMessage< ::AvatarHeaderMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AvatarHeaderMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AvatarDataMessage* Arena::CreateMaybeMessage< ::AvatarDataMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AvatarDataMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AvatarEndMessage* Arena::CreateMaybeMessage< ::AvatarEndMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AvatarEndMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::UnknownAvatarMessage* Arena::CreateMaybeMessage< ::UnknownAvatarMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UnknownAvatarMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerListMessage* Arena::CreateMaybeMessage< ::PlayerListMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerListMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListNewMessage* Arena::CreateMaybeMessage< ::GameListNewMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListNewMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListUpdateMessage* Arena::CreateMaybeMessage< ::GameListUpdateMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListUpdateMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListPlayerJoinedMessage* Arena::CreateMaybeMessage< ::GameListPlayerJoinedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListPlayerJoinedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListPlayerLeftMessage* Arena::CreateMaybeMessage< ::GameListPlayerLeftMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListPlayerLeftMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListSpectatorJoinedMessage* Arena::CreateMaybeMessage< ::GameListSpectatorJoinedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListSpectatorJoinedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListSpectatorLeftMessage* Arena::CreateMaybeMessage< ::GameListSpectatorLeftMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListSpectatorLeftMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameListAdminChangedMessage* Arena::CreateMaybeMessage< ::GameListAdminChangedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameListAdminChangedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerInfoRequestMessage* Arena::CreateMaybeMessage< ::PlayerInfoRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerInfoRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* Arena::CreateMaybeMessage< ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerInfoReplyMessage_PlayerInfoData* Arena::CreateMaybeMessage< ::PlayerInfoReplyMessage_PlayerInfoData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerInfoReplyMessage_PlayerInfoData >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerInfoReplyMessage* Arena::CreateMaybeMessage< ::PlayerInfoReplyMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerInfoReplyMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::SubscriptionRequestMessage* Arena::CreateMaybeMessage< ::SubscriptionRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SubscriptionRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::JoinExistingGameMessage* Arena::CreateMaybeMessage< ::JoinExistingGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::JoinExistingGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::JoinNewGameMessage* Arena::CreateMaybeMessage< ::JoinNewGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::JoinNewGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::RejoinExistingGameMessage* Arena::CreateMaybeMessage< ::RejoinExistingGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RejoinExistingGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::JoinGameAckMessage* Arena::CreateMaybeMessage< ::JoinGameAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::JoinGameAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::JoinGameFailedMessage* Arena::CreateMaybeMessage< ::JoinGameFailedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::JoinGameFailedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GamePlayerJoinedMessage* Arena::CreateMaybeMessage< ::GamePlayerJoinedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GamePlayerJoinedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GamePlayerLeftMessage* Arena::CreateMaybeMessage< ::GamePlayerLeftMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GamePlayerLeftMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameSpectatorJoinedMessage* Arena::CreateMaybeMessage< ::GameSpectatorJoinedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameSpectatorJoinedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameSpectatorLeftMessage* Arena::CreateMaybeMessage< ::GameSpectatorLeftMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameSpectatorLeftMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameAdminChangedMessage* Arena::CreateMaybeMessage< ::GameAdminChangedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameAdminChangedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::RemovedFromGameMessage* Arena::CreateMaybeMessage< ::RemovedFromGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RemovedFromGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::KickPlayerRequestMessage* Arena::CreateMaybeMessage< ::KickPlayerRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::KickPlayerRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::LeaveGameRequestMessage* Arena::CreateMaybeMessage< ::LeaveGameRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LeaveGameRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::InvitePlayerToGameMessage* Arena::CreateMaybeMessage< ::InvitePlayerToGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InvitePlayerToGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::InviteNotifyMessage* Arena::CreateMaybeMessage< ::InviteNotifyMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InviteNotifyMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::RejectGameInvitationMessage* Arena::CreateMaybeMessage< ::RejectGameInvitationMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RejectGameInvitationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::RejectInvNotifyMessage* Arena::CreateMaybeMessage< ::RejectInvNotifyMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RejectInvNotifyMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::StartEventMessage* Arena::CreateMaybeMessage< ::StartEventMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StartEventMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::StartEventAckMessage* Arena::CreateMaybeMessage< ::StartEventAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StartEventAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameStartInitialMessage* Arena::CreateMaybeMessage< ::GameStartInitialMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameStartInitialMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::GameStartRejoinMessage_RejoinPlayerData* Arena::CreateMaybeMessage< ::GameStartRejoinMessage_RejoinPlayerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameStartRejoinMessage_RejoinPlayerData >(arena);
}
template<> PROTOBUF_NOINLINE ::GameStartRejoinMessage* Arena::CreateMaybeMessage< ::GameStartRejoinMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameStartRejoinMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::HandStartMessage_PlainCards* Arena::CreateMaybeMessage< ::HandStartMessage_PlainCards >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HandStartMessage_PlainCards >(arena);
}
template<> PROTOBUF_NOINLINE ::HandStartMessage* Arena::CreateMaybeMessage< ::HandStartMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HandStartMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayersTurnMessage* Arena::CreateMaybeMessage< ::PlayersTurnMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayersTurnMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::MyActionRequestMessage* Arena::CreateMaybeMessage< ::MyActionRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MyActionRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::YourActionRejectedMessage* Arena::CreateMaybeMessage< ::YourActionRejectedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::YourActionRejectedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayersActionDoneMessage* Arena::CreateMaybeMessage< ::PlayersActionDoneMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayersActionDoneMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::DealFlopCardsMessage* Arena::CreateMaybeMessage< ::DealFlopCardsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DealFlopCardsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::DealTurnCardMessage* Arena::CreateMaybeMessage< ::DealTurnCardMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DealTurnCardMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::DealRiverCardMessage* Arena::CreateMaybeMessage< ::DealRiverCardMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DealRiverCardMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AllInShowCardsMessage_PlayerAllIn* Arena::CreateMaybeMessage< ::AllInShowCardsMessage_PlayerAllIn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AllInShowCardsMessage_PlayerAllIn >(arena);
}
template<> PROTOBUF_NOINLINE ::AllInShowCardsMessage* Arena::CreateMaybeMessage< ::AllInShowCardsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AllInShowCardsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::EndOfHandShowCardsMessage* Arena::CreateMaybeMessage< ::EndOfHandShowCardsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::EndOfHandShowCardsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::EndOfHandHideCardsMessage* Arena::CreateMaybeMessage< ::EndOfHandHideCardsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::EndOfHandHideCardsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ShowMyCardsRequestMessage* Arena::CreateMaybeMessage< ::ShowMyCardsRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShowMyCardsRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AfterHandShowCardsMessage* Arena::CreateMaybeMessage< ::AfterHandShowCardsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AfterHandShowCardsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::EndOfGameMessage* Arena::CreateMaybeMessage< ::EndOfGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::EndOfGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PlayerIdChangedMessage* Arena::CreateMaybeMessage< ::PlayerIdChangedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PlayerIdChangedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AskKickPlayerMessage* Arena::CreateMaybeMessage< ::AskKickPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AskKickPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AskKickDeniedMessage* Arena::CreateMaybeMessage< ::AskKickDeniedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AskKickDeniedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::StartKickPetitionMessage* Arena::CreateMaybeMessage< ::StartKickPetitionMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StartKickPetitionMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::VoteKickRequestMessage* Arena::CreateMaybeMessage< ::VoteKickRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VoteKickRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::VoteKickReplyMessage* Arena::CreateMaybeMessage< ::VoteKickReplyMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VoteKickReplyMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::KickPetitionUpdateMessage* Arena::CreateMaybeMessage< ::KickPetitionUpdateMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::KickPetitionUpdateMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::EndKickPetitionMessage* Arena::CreateMaybeMessage< ::EndKickPetitionMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::EndKickPetitionMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::StatisticsMessage_StatisticsData* Arena::CreateMaybeMessage< ::StatisticsMessage_StatisticsData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StatisticsMessage_StatisticsData >(arena);
}
template<> PROTOBUF_NOINLINE ::StatisticsMessage* Arena::CreateMaybeMessage< ::StatisticsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StatisticsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ChatRequestMessage* Arena::CreateMaybeMessage< ::ChatRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ChatRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ChatMessage* Arena::CreateMaybeMessage< ::ChatMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ChatMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ChatRejectMessage* Arena::CreateMaybeMessage< ::ChatRejectMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ChatRejectMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::DialogMessage* Arena::CreateMaybeMessage< ::DialogMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DialogMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::TimeoutWarningMessage* Arena::CreateMaybeMessage< ::TimeoutWarningMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TimeoutWarningMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ResetTimeoutMessage* Arena::CreateMaybeMessage< ::ResetTimeoutMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ResetTimeoutMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ReportAvatarMessage* Arena::CreateMaybeMessage< ::ReportAvatarMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ReportAvatarMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ReportAvatarAckMessage* Arena::CreateMaybeMessage< ::ReportAvatarAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ReportAvatarAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ReportGameMessage* Arena::CreateMaybeMessage< ::ReportGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ReportGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ReportGameAckMessage* Arena::CreateMaybeMessage< ::ReportGameAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ReportGameAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ErrorMessage* Arena::CreateMaybeMessage< ::ErrorMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ErrorMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AdminRemoveGameMessage* Arena::CreateMaybeMessage< ::AdminRemoveGameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AdminRemoveGameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AdminRemoveGameAckMessage* Arena::CreateMaybeMessage< ::AdminRemoveGameAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AdminRemoveGameAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AdminBanPlayerMessage* Arena::CreateMaybeMessage< ::AdminBanPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AdminBanPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AdminBanPlayerAckMessage* Arena::CreateMaybeMessage< ::AdminBanPlayerAckMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AdminBanPlayerAckMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::PokerTHMessage* Arena::CreateMaybeMessage< ::PokerTHMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PokerTHMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
