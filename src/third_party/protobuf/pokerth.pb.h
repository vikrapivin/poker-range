// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pokerth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pokerth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pokerth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pokerth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pokerth_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[91]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
class AdminBanPlayerAckMessage;
struct AdminBanPlayerAckMessageDefaultTypeInternal;
extern AdminBanPlayerAckMessageDefaultTypeInternal _AdminBanPlayerAckMessage_default_instance_;
class AdminBanPlayerMessage;
struct AdminBanPlayerMessageDefaultTypeInternal;
extern AdminBanPlayerMessageDefaultTypeInternal _AdminBanPlayerMessage_default_instance_;
class AdminRemoveGameAckMessage;
struct AdminRemoveGameAckMessageDefaultTypeInternal;
extern AdminRemoveGameAckMessageDefaultTypeInternal _AdminRemoveGameAckMessage_default_instance_;
class AdminRemoveGameMessage;
struct AdminRemoveGameMessageDefaultTypeInternal;
extern AdminRemoveGameMessageDefaultTypeInternal _AdminRemoveGameMessage_default_instance_;
class AfterHandShowCardsMessage;
struct AfterHandShowCardsMessageDefaultTypeInternal;
extern AfterHandShowCardsMessageDefaultTypeInternal _AfterHandShowCardsMessage_default_instance_;
class AllInShowCardsMessage;
struct AllInShowCardsMessageDefaultTypeInternal;
extern AllInShowCardsMessageDefaultTypeInternal _AllInShowCardsMessage_default_instance_;
class AllInShowCardsMessage_PlayerAllIn;
struct AllInShowCardsMessage_PlayerAllInDefaultTypeInternal;
extern AllInShowCardsMessage_PlayerAllInDefaultTypeInternal _AllInShowCardsMessage_PlayerAllIn_default_instance_;
class AnnounceMessage;
struct AnnounceMessageDefaultTypeInternal;
extern AnnounceMessageDefaultTypeInternal _AnnounceMessage_default_instance_;
class AnnounceMessage_Version;
struct AnnounceMessage_VersionDefaultTypeInternal;
extern AnnounceMessage_VersionDefaultTypeInternal _AnnounceMessage_Version_default_instance_;
class AskKickDeniedMessage;
struct AskKickDeniedMessageDefaultTypeInternal;
extern AskKickDeniedMessageDefaultTypeInternal _AskKickDeniedMessage_default_instance_;
class AskKickPlayerMessage;
struct AskKickPlayerMessageDefaultTypeInternal;
extern AskKickPlayerMessageDefaultTypeInternal _AskKickPlayerMessage_default_instance_;
class AuthClientResponseMessage;
struct AuthClientResponseMessageDefaultTypeInternal;
extern AuthClientResponseMessageDefaultTypeInternal _AuthClientResponseMessage_default_instance_;
class AuthServerChallengeMessage;
struct AuthServerChallengeMessageDefaultTypeInternal;
extern AuthServerChallengeMessageDefaultTypeInternal _AuthServerChallengeMessage_default_instance_;
class AuthServerVerificationMessage;
struct AuthServerVerificationMessageDefaultTypeInternal;
extern AuthServerVerificationMessageDefaultTypeInternal _AuthServerVerificationMessage_default_instance_;
class AvatarDataMessage;
struct AvatarDataMessageDefaultTypeInternal;
extern AvatarDataMessageDefaultTypeInternal _AvatarDataMessage_default_instance_;
class AvatarEndMessage;
struct AvatarEndMessageDefaultTypeInternal;
extern AvatarEndMessageDefaultTypeInternal _AvatarEndMessage_default_instance_;
class AvatarHeaderMessage;
struct AvatarHeaderMessageDefaultTypeInternal;
extern AvatarHeaderMessageDefaultTypeInternal _AvatarHeaderMessage_default_instance_;
class AvatarRequestMessage;
struct AvatarRequestMessageDefaultTypeInternal;
extern AvatarRequestMessageDefaultTypeInternal _AvatarRequestMessage_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ChatRejectMessage;
struct ChatRejectMessageDefaultTypeInternal;
extern ChatRejectMessageDefaultTypeInternal _ChatRejectMessage_default_instance_;
class ChatRequestMessage;
struct ChatRequestMessageDefaultTypeInternal;
extern ChatRequestMessageDefaultTypeInternal _ChatRequestMessage_default_instance_;
class DealFlopCardsMessage;
struct DealFlopCardsMessageDefaultTypeInternal;
extern DealFlopCardsMessageDefaultTypeInternal _DealFlopCardsMessage_default_instance_;
class DealRiverCardMessage;
struct DealRiverCardMessageDefaultTypeInternal;
extern DealRiverCardMessageDefaultTypeInternal _DealRiverCardMessage_default_instance_;
class DealTurnCardMessage;
struct DealTurnCardMessageDefaultTypeInternal;
extern DealTurnCardMessageDefaultTypeInternal _DealTurnCardMessage_default_instance_;
class DialogMessage;
struct DialogMessageDefaultTypeInternal;
extern DialogMessageDefaultTypeInternal _DialogMessage_default_instance_;
class EndKickPetitionMessage;
struct EndKickPetitionMessageDefaultTypeInternal;
extern EndKickPetitionMessageDefaultTypeInternal _EndKickPetitionMessage_default_instance_;
class EndOfGameMessage;
struct EndOfGameMessageDefaultTypeInternal;
extern EndOfGameMessageDefaultTypeInternal _EndOfGameMessage_default_instance_;
class EndOfHandHideCardsMessage;
struct EndOfHandHideCardsMessageDefaultTypeInternal;
extern EndOfHandHideCardsMessageDefaultTypeInternal _EndOfHandHideCardsMessage_default_instance_;
class EndOfHandShowCardsMessage;
struct EndOfHandShowCardsMessageDefaultTypeInternal;
extern EndOfHandShowCardsMessageDefaultTypeInternal _EndOfHandShowCardsMessage_default_instance_;
class ErrorMessage;
struct ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class GameAdminChangedMessage;
struct GameAdminChangedMessageDefaultTypeInternal;
extern GameAdminChangedMessageDefaultTypeInternal _GameAdminChangedMessage_default_instance_;
class GameListAdminChangedMessage;
struct GameListAdminChangedMessageDefaultTypeInternal;
extern GameListAdminChangedMessageDefaultTypeInternal _GameListAdminChangedMessage_default_instance_;
class GameListNewMessage;
struct GameListNewMessageDefaultTypeInternal;
extern GameListNewMessageDefaultTypeInternal _GameListNewMessage_default_instance_;
class GameListPlayerJoinedMessage;
struct GameListPlayerJoinedMessageDefaultTypeInternal;
extern GameListPlayerJoinedMessageDefaultTypeInternal _GameListPlayerJoinedMessage_default_instance_;
class GameListPlayerLeftMessage;
struct GameListPlayerLeftMessageDefaultTypeInternal;
extern GameListPlayerLeftMessageDefaultTypeInternal _GameListPlayerLeftMessage_default_instance_;
class GameListSpectatorJoinedMessage;
struct GameListSpectatorJoinedMessageDefaultTypeInternal;
extern GameListSpectatorJoinedMessageDefaultTypeInternal _GameListSpectatorJoinedMessage_default_instance_;
class GameListSpectatorLeftMessage;
struct GameListSpectatorLeftMessageDefaultTypeInternal;
extern GameListSpectatorLeftMessageDefaultTypeInternal _GameListSpectatorLeftMessage_default_instance_;
class GameListUpdateMessage;
struct GameListUpdateMessageDefaultTypeInternal;
extern GameListUpdateMessageDefaultTypeInternal _GameListUpdateMessage_default_instance_;
class GamePlayerJoinedMessage;
struct GamePlayerJoinedMessageDefaultTypeInternal;
extern GamePlayerJoinedMessageDefaultTypeInternal _GamePlayerJoinedMessage_default_instance_;
class GamePlayerLeftMessage;
struct GamePlayerLeftMessageDefaultTypeInternal;
extern GamePlayerLeftMessageDefaultTypeInternal _GamePlayerLeftMessage_default_instance_;
class GameSpectatorJoinedMessage;
struct GameSpectatorJoinedMessageDefaultTypeInternal;
extern GameSpectatorJoinedMessageDefaultTypeInternal _GameSpectatorJoinedMessage_default_instance_;
class GameSpectatorLeftMessage;
struct GameSpectatorLeftMessageDefaultTypeInternal;
extern GameSpectatorLeftMessageDefaultTypeInternal _GameSpectatorLeftMessage_default_instance_;
class GameStartInitialMessage;
struct GameStartInitialMessageDefaultTypeInternal;
extern GameStartInitialMessageDefaultTypeInternal _GameStartInitialMessage_default_instance_;
class GameStartRejoinMessage;
struct GameStartRejoinMessageDefaultTypeInternal;
extern GameStartRejoinMessageDefaultTypeInternal _GameStartRejoinMessage_default_instance_;
class GameStartRejoinMessage_RejoinPlayerData;
struct GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal;
extern GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal _GameStartRejoinMessage_RejoinPlayerData_default_instance_;
class HandStartMessage;
struct HandStartMessageDefaultTypeInternal;
extern HandStartMessageDefaultTypeInternal _HandStartMessage_default_instance_;
class HandStartMessage_PlainCards;
struct HandStartMessage_PlainCardsDefaultTypeInternal;
extern HandStartMessage_PlainCardsDefaultTypeInternal _HandStartMessage_PlainCards_default_instance_;
class InitAckMessage;
struct InitAckMessageDefaultTypeInternal;
extern InitAckMessageDefaultTypeInternal _InitAckMessage_default_instance_;
class InitMessage;
struct InitMessageDefaultTypeInternal;
extern InitMessageDefaultTypeInternal _InitMessage_default_instance_;
class InviteNotifyMessage;
struct InviteNotifyMessageDefaultTypeInternal;
extern InviteNotifyMessageDefaultTypeInternal _InviteNotifyMessage_default_instance_;
class InvitePlayerToGameMessage;
struct InvitePlayerToGameMessageDefaultTypeInternal;
extern InvitePlayerToGameMessageDefaultTypeInternal _InvitePlayerToGameMessage_default_instance_;
class JoinExistingGameMessage;
struct JoinExistingGameMessageDefaultTypeInternal;
extern JoinExistingGameMessageDefaultTypeInternal _JoinExistingGameMessage_default_instance_;
class JoinGameAckMessage;
struct JoinGameAckMessageDefaultTypeInternal;
extern JoinGameAckMessageDefaultTypeInternal _JoinGameAckMessage_default_instance_;
class JoinGameFailedMessage;
struct JoinGameFailedMessageDefaultTypeInternal;
extern JoinGameFailedMessageDefaultTypeInternal _JoinGameFailedMessage_default_instance_;
class JoinNewGameMessage;
struct JoinNewGameMessageDefaultTypeInternal;
extern JoinNewGameMessageDefaultTypeInternal _JoinNewGameMessage_default_instance_;
class KickPetitionUpdateMessage;
struct KickPetitionUpdateMessageDefaultTypeInternal;
extern KickPetitionUpdateMessageDefaultTypeInternal _KickPetitionUpdateMessage_default_instance_;
class KickPlayerRequestMessage;
struct KickPlayerRequestMessageDefaultTypeInternal;
extern KickPlayerRequestMessageDefaultTypeInternal _KickPlayerRequestMessage_default_instance_;
class LeaveGameRequestMessage;
struct LeaveGameRequestMessageDefaultTypeInternal;
extern LeaveGameRequestMessageDefaultTypeInternal _LeaveGameRequestMessage_default_instance_;
class MyActionRequestMessage;
struct MyActionRequestMessageDefaultTypeInternal;
extern MyActionRequestMessageDefaultTypeInternal _MyActionRequestMessage_default_instance_;
class NetGameInfo;
struct NetGameInfoDefaultTypeInternal;
extern NetGameInfoDefaultTypeInternal _NetGameInfo_default_instance_;
class PlayerIdChangedMessage;
struct PlayerIdChangedMessageDefaultTypeInternal;
extern PlayerIdChangedMessageDefaultTypeInternal _PlayerIdChangedMessage_default_instance_;
class PlayerInfoReplyMessage;
struct PlayerInfoReplyMessageDefaultTypeInternal;
extern PlayerInfoReplyMessageDefaultTypeInternal _PlayerInfoReplyMessage_default_instance_;
class PlayerInfoReplyMessage_PlayerInfoData;
struct PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal;
extern PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal _PlayerInfoReplyMessage_PlayerInfoData_default_instance_;
class PlayerInfoReplyMessage_PlayerInfoData_AvatarData;
struct PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal;
extern PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal _PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_;
class PlayerInfoRequestMessage;
struct PlayerInfoRequestMessageDefaultTypeInternal;
extern PlayerInfoRequestMessageDefaultTypeInternal _PlayerInfoRequestMessage_default_instance_;
class PlayerListMessage;
struct PlayerListMessageDefaultTypeInternal;
extern PlayerListMessageDefaultTypeInternal _PlayerListMessage_default_instance_;
class PlayerResult;
struct PlayerResultDefaultTypeInternal;
extern PlayerResultDefaultTypeInternal _PlayerResult_default_instance_;
class PlayersActionDoneMessage;
struct PlayersActionDoneMessageDefaultTypeInternal;
extern PlayersActionDoneMessageDefaultTypeInternal _PlayersActionDoneMessage_default_instance_;
class PlayersTurnMessage;
struct PlayersTurnMessageDefaultTypeInternal;
extern PlayersTurnMessageDefaultTypeInternal _PlayersTurnMessage_default_instance_;
class PokerTHMessage;
struct PokerTHMessageDefaultTypeInternal;
extern PokerTHMessageDefaultTypeInternal _PokerTHMessage_default_instance_;
class RejectGameInvitationMessage;
struct RejectGameInvitationMessageDefaultTypeInternal;
extern RejectGameInvitationMessageDefaultTypeInternal _RejectGameInvitationMessage_default_instance_;
class RejectInvNotifyMessage;
struct RejectInvNotifyMessageDefaultTypeInternal;
extern RejectInvNotifyMessageDefaultTypeInternal _RejectInvNotifyMessage_default_instance_;
class RejoinExistingGameMessage;
struct RejoinExistingGameMessageDefaultTypeInternal;
extern RejoinExistingGameMessageDefaultTypeInternal _RejoinExistingGameMessage_default_instance_;
class RemovedFromGameMessage;
struct RemovedFromGameMessageDefaultTypeInternal;
extern RemovedFromGameMessageDefaultTypeInternal _RemovedFromGameMessage_default_instance_;
class ReportAvatarAckMessage;
struct ReportAvatarAckMessageDefaultTypeInternal;
extern ReportAvatarAckMessageDefaultTypeInternal _ReportAvatarAckMessage_default_instance_;
class ReportAvatarMessage;
struct ReportAvatarMessageDefaultTypeInternal;
extern ReportAvatarMessageDefaultTypeInternal _ReportAvatarMessage_default_instance_;
class ReportGameAckMessage;
struct ReportGameAckMessageDefaultTypeInternal;
extern ReportGameAckMessageDefaultTypeInternal _ReportGameAckMessage_default_instance_;
class ReportGameMessage;
struct ReportGameMessageDefaultTypeInternal;
extern ReportGameMessageDefaultTypeInternal _ReportGameMessage_default_instance_;
class ResetTimeoutMessage;
struct ResetTimeoutMessageDefaultTypeInternal;
extern ResetTimeoutMessageDefaultTypeInternal _ResetTimeoutMessage_default_instance_;
class ShowMyCardsRequestMessage;
struct ShowMyCardsRequestMessageDefaultTypeInternal;
extern ShowMyCardsRequestMessageDefaultTypeInternal _ShowMyCardsRequestMessage_default_instance_;
class StartEventAckMessage;
struct StartEventAckMessageDefaultTypeInternal;
extern StartEventAckMessageDefaultTypeInternal _StartEventAckMessage_default_instance_;
class StartEventMessage;
struct StartEventMessageDefaultTypeInternal;
extern StartEventMessageDefaultTypeInternal _StartEventMessage_default_instance_;
class StartKickPetitionMessage;
struct StartKickPetitionMessageDefaultTypeInternal;
extern StartKickPetitionMessageDefaultTypeInternal _StartKickPetitionMessage_default_instance_;
class StatisticsMessage;
struct StatisticsMessageDefaultTypeInternal;
extern StatisticsMessageDefaultTypeInternal _StatisticsMessage_default_instance_;
class StatisticsMessage_StatisticsData;
struct StatisticsMessage_StatisticsDataDefaultTypeInternal;
extern StatisticsMessage_StatisticsDataDefaultTypeInternal _StatisticsMessage_StatisticsData_default_instance_;
class SubscriptionRequestMessage;
struct SubscriptionRequestMessageDefaultTypeInternal;
extern SubscriptionRequestMessageDefaultTypeInternal _SubscriptionRequestMessage_default_instance_;
class TimeoutWarningMessage;
struct TimeoutWarningMessageDefaultTypeInternal;
extern TimeoutWarningMessageDefaultTypeInternal _TimeoutWarningMessage_default_instance_;
class UnknownAvatarMessage;
struct UnknownAvatarMessageDefaultTypeInternal;
extern UnknownAvatarMessageDefaultTypeInternal _UnknownAvatarMessage_default_instance_;
class VoteKickReplyMessage;
struct VoteKickReplyMessageDefaultTypeInternal;
extern VoteKickReplyMessageDefaultTypeInternal _VoteKickReplyMessage_default_instance_;
class VoteKickRequestMessage;
struct VoteKickRequestMessageDefaultTypeInternal;
extern VoteKickRequestMessageDefaultTypeInternal _VoteKickRequestMessage_default_instance_;
class YourActionRejectedMessage;
struct YourActionRejectedMessageDefaultTypeInternal;
extern YourActionRejectedMessageDefaultTypeInternal _YourActionRejectedMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AdminBanPlayerAckMessage* Arena::CreateMaybeMessage<::AdminBanPlayerAckMessage>(Arena*);
template<> ::AdminBanPlayerMessage* Arena::CreateMaybeMessage<::AdminBanPlayerMessage>(Arena*);
template<> ::AdminRemoveGameAckMessage* Arena::CreateMaybeMessage<::AdminRemoveGameAckMessage>(Arena*);
template<> ::AdminRemoveGameMessage* Arena::CreateMaybeMessage<::AdminRemoveGameMessage>(Arena*);
template<> ::AfterHandShowCardsMessage* Arena::CreateMaybeMessage<::AfterHandShowCardsMessage>(Arena*);
template<> ::AllInShowCardsMessage* Arena::CreateMaybeMessage<::AllInShowCardsMessage>(Arena*);
template<> ::AllInShowCardsMessage_PlayerAllIn* Arena::CreateMaybeMessage<::AllInShowCardsMessage_PlayerAllIn>(Arena*);
template<> ::AnnounceMessage* Arena::CreateMaybeMessage<::AnnounceMessage>(Arena*);
template<> ::AnnounceMessage_Version* Arena::CreateMaybeMessage<::AnnounceMessage_Version>(Arena*);
template<> ::AskKickDeniedMessage* Arena::CreateMaybeMessage<::AskKickDeniedMessage>(Arena*);
template<> ::AskKickPlayerMessage* Arena::CreateMaybeMessage<::AskKickPlayerMessage>(Arena*);
template<> ::AuthClientResponseMessage* Arena::CreateMaybeMessage<::AuthClientResponseMessage>(Arena*);
template<> ::AuthServerChallengeMessage* Arena::CreateMaybeMessage<::AuthServerChallengeMessage>(Arena*);
template<> ::AuthServerVerificationMessage* Arena::CreateMaybeMessage<::AuthServerVerificationMessage>(Arena*);
template<> ::AvatarDataMessage* Arena::CreateMaybeMessage<::AvatarDataMessage>(Arena*);
template<> ::AvatarEndMessage* Arena::CreateMaybeMessage<::AvatarEndMessage>(Arena*);
template<> ::AvatarHeaderMessage* Arena::CreateMaybeMessage<::AvatarHeaderMessage>(Arena*);
template<> ::AvatarRequestMessage* Arena::CreateMaybeMessage<::AvatarRequestMessage>(Arena*);
template<> ::ChatMessage* Arena::CreateMaybeMessage<::ChatMessage>(Arena*);
template<> ::ChatRejectMessage* Arena::CreateMaybeMessage<::ChatRejectMessage>(Arena*);
template<> ::ChatRequestMessage* Arena::CreateMaybeMessage<::ChatRequestMessage>(Arena*);
template<> ::DealFlopCardsMessage* Arena::CreateMaybeMessage<::DealFlopCardsMessage>(Arena*);
template<> ::DealRiverCardMessage* Arena::CreateMaybeMessage<::DealRiverCardMessage>(Arena*);
template<> ::DealTurnCardMessage* Arena::CreateMaybeMessage<::DealTurnCardMessage>(Arena*);
template<> ::DialogMessage* Arena::CreateMaybeMessage<::DialogMessage>(Arena*);
template<> ::EndKickPetitionMessage* Arena::CreateMaybeMessage<::EndKickPetitionMessage>(Arena*);
template<> ::EndOfGameMessage* Arena::CreateMaybeMessage<::EndOfGameMessage>(Arena*);
template<> ::EndOfHandHideCardsMessage* Arena::CreateMaybeMessage<::EndOfHandHideCardsMessage>(Arena*);
template<> ::EndOfHandShowCardsMessage* Arena::CreateMaybeMessage<::EndOfHandShowCardsMessage>(Arena*);
template<> ::ErrorMessage* Arena::CreateMaybeMessage<::ErrorMessage>(Arena*);
template<> ::GameAdminChangedMessage* Arena::CreateMaybeMessage<::GameAdminChangedMessage>(Arena*);
template<> ::GameListAdminChangedMessage* Arena::CreateMaybeMessage<::GameListAdminChangedMessage>(Arena*);
template<> ::GameListNewMessage* Arena::CreateMaybeMessage<::GameListNewMessage>(Arena*);
template<> ::GameListPlayerJoinedMessage* Arena::CreateMaybeMessage<::GameListPlayerJoinedMessage>(Arena*);
template<> ::GameListPlayerLeftMessage* Arena::CreateMaybeMessage<::GameListPlayerLeftMessage>(Arena*);
template<> ::GameListSpectatorJoinedMessage* Arena::CreateMaybeMessage<::GameListSpectatorJoinedMessage>(Arena*);
template<> ::GameListSpectatorLeftMessage* Arena::CreateMaybeMessage<::GameListSpectatorLeftMessage>(Arena*);
template<> ::GameListUpdateMessage* Arena::CreateMaybeMessage<::GameListUpdateMessage>(Arena*);
template<> ::GamePlayerJoinedMessage* Arena::CreateMaybeMessage<::GamePlayerJoinedMessage>(Arena*);
template<> ::GamePlayerLeftMessage* Arena::CreateMaybeMessage<::GamePlayerLeftMessage>(Arena*);
template<> ::GameSpectatorJoinedMessage* Arena::CreateMaybeMessage<::GameSpectatorJoinedMessage>(Arena*);
template<> ::GameSpectatorLeftMessage* Arena::CreateMaybeMessage<::GameSpectatorLeftMessage>(Arena*);
template<> ::GameStartInitialMessage* Arena::CreateMaybeMessage<::GameStartInitialMessage>(Arena*);
template<> ::GameStartRejoinMessage* Arena::CreateMaybeMessage<::GameStartRejoinMessage>(Arena*);
template<> ::GameStartRejoinMessage_RejoinPlayerData* Arena::CreateMaybeMessage<::GameStartRejoinMessage_RejoinPlayerData>(Arena*);
template<> ::HandStartMessage* Arena::CreateMaybeMessage<::HandStartMessage>(Arena*);
template<> ::HandStartMessage_PlainCards* Arena::CreateMaybeMessage<::HandStartMessage_PlainCards>(Arena*);
template<> ::InitAckMessage* Arena::CreateMaybeMessage<::InitAckMessage>(Arena*);
template<> ::InitMessage* Arena::CreateMaybeMessage<::InitMessage>(Arena*);
template<> ::InviteNotifyMessage* Arena::CreateMaybeMessage<::InviteNotifyMessage>(Arena*);
template<> ::InvitePlayerToGameMessage* Arena::CreateMaybeMessage<::InvitePlayerToGameMessage>(Arena*);
template<> ::JoinExistingGameMessage* Arena::CreateMaybeMessage<::JoinExistingGameMessage>(Arena*);
template<> ::JoinGameAckMessage* Arena::CreateMaybeMessage<::JoinGameAckMessage>(Arena*);
template<> ::JoinGameFailedMessage* Arena::CreateMaybeMessage<::JoinGameFailedMessage>(Arena*);
template<> ::JoinNewGameMessage* Arena::CreateMaybeMessage<::JoinNewGameMessage>(Arena*);
template<> ::KickPetitionUpdateMessage* Arena::CreateMaybeMessage<::KickPetitionUpdateMessage>(Arena*);
template<> ::KickPlayerRequestMessage* Arena::CreateMaybeMessage<::KickPlayerRequestMessage>(Arena*);
template<> ::LeaveGameRequestMessage* Arena::CreateMaybeMessage<::LeaveGameRequestMessage>(Arena*);
template<> ::MyActionRequestMessage* Arena::CreateMaybeMessage<::MyActionRequestMessage>(Arena*);
template<> ::NetGameInfo* Arena::CreateMaybeMessage<::NetGameInfo>(Arena*);
template<> ::PlayerIdChangedMessage* Arena::CreateMaybeMessage<::PlayerIdChangedMessage>(Arena*);
template<> ::PlayerInfoReplyMessage* Arena::CreateMaybeMessage<::PlayerInfoReplyMessage>(Arena*);
template<> ::PlayerInfoReplyMessage_PlayerInfoData* Arena::CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData>(Arena*);
template<> ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* Arena::CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(Arena*);
template<> ::PlayerInfoRequestMessage* Arena::CreateMaybeMessage<::PlayerInfoRequestMessage>(Arena*);
template<> ::PlayerListMessage* Arena::CreateMaybeMessage<::PlayerListMessage>(Arena*);
template<> ::PlayerResult* Arena::CreateMaybeMessage<::PlayerResult>(Arena*);
template<> ::PlayersActionDoneMessage* Arena::CreateMaybeMessage<::PlayersActionDoneMessage>(Arena*);
template<> ::PlayersTurnMessage* Arena::CreateMaybeMessage<::PlayersTurnMessage>(Arena*);
template<> ::PokerTHMessage* Arena::CreateMaybeMessage<::PokerTHMessage>(Arena*);
template<> ::RejectGameInvitationMessage* Arena::CreateMaybeMessage<::RejectGameInvitationMessage>(Arena*);
template<> ::RejectInvNotifyMessage* Arena::CreateMaybeMessage<::RejectInvNotifyMessage>(Arena*);
template<> ::RejoinExistingGameMessage* Arena::CreateMaybeMessage<::RejoinExistingGameMessage>(Arena*);
template<> ::RemovedFromGameMessage* Arena::CreateMaybeMessage<::RemovedFromGameMessage>(Arena*);
template<> ::ReportAvatarAckMessage* Arena::CreateMaybeMessage<::ReportAvatarAckMessage>(Arena*);
template<> ::ReportAvatarMessage* Arena::CreateMaybeMessage<::ReportAvatarMessage>(Arena*);
template<> ::ReportGameAckMessage* Arena::CreateMaybeMessage<::ReportGameAckMessage>(Arena*);
template<> ::ReportGameMessage* Arena::CreateMaybeMessage<::ReportGameMessage>(Arena*);
template<> ::ResetTimeoutMessage* Arena::CreateMaybeMessage<::ResetTimeoutMessage>(Arena*);
template<> ::ShowMyCardsRequestMessage* Arena::CreateMaybeMessage<::ShowMyCardsRequestMessage>(Arena*);
template<> ::StartEventAckMessage* Arena::CreateMaybeMessage<::StartEventAckMessage>(Arena*);
template<> ::StartEventMessage* Arena::CreateMaybeMessage<::StartEventMessage>(Arena*);
template<> ::StartKickPetitionMessage* Arena::CreateMaybeMessage<::StartKickPetitionMessage>(Arena*);
template<> ::StatisticsMessage* Arena::CreateMaybeMessage<::StatisticsMessage>(Arena*);
template<> ::StatisticsMessage_StatisticsData* Arena::CreateMaybeMessage<::StatisticsMessage_StatisticsData>(Arena*);
template<> ::SubscriptionRequestMessage* Arena::CreateMaybeMessage<::SubscriptionRequestMessage>(Arena*);
template<> ::TimeoutWarningMessage* Arena::CreateMaybeMessage<::TimeoutWarningMessage>(Arena*);
template<> ::UnknownAvatarMessage* Arena::CreateMaybeMessage<::UnknownAvatarMessage>(Arena*);
template<> ::VoteKickReplyMessage* Arena::CreateMaybeMessage<::VoteKickReplyMessage>(Arena*);
template<> ::VoteKickRequestMessage* Arena::CreateMaybeMessage<::VoteKickRequestMessage>(Arena*);
template<> ::YourActionRejectedMessage* Arena::CreateMaybeMessage<::YourActionRejectedMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum NetGameInfo_NetGameType : int {
  NetGameInfo_NetGameType_normalGame = 1,
  NetGameInfo_NetGameType_registeredOnlyGame = 2,
  NetGameInfo_NetGameType_inviteOnlyGame = 3,
  NetGameInfo_NetGameType_rankingGame = 4
};
bool NetGameInfo_NetGameType_IsValid(int value);
constexpr NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MIN = NetGameInfo_NetGameType_normalGame;
constexpr NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MAX = NetGameInfo_NetGameType_rankingGame;
constexpr int NetGameInfo_NetGameType_NetGameType_ARRAYSIZE = NetGameInfo_NetGameType_NetGameType_MAX + 1;

const std::string& NetGameInfo_NetGameType_Name(NetGameInfo_NetGameType value);
template<typename T>
inline const std::string& NetGameInfo_NetGameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetGameInfo_NetGameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetGameInfo_NetGameType_Name.");
  return NetGameInfo_NetGameType_Name(static_cast<NetGameInfo_NetGameType>(enum_t_value));
}
bool NetGameInfo_NetGameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameInfo_NetGameType* value);
enum NetGameInfo_RaiseIntervalMode : int {
  NetGameInfo_RaiseIntervalMode_raiseOnHandNum = 1,
  NetGameInfo_RaiseIntervalMode_raiseOnMinutes = 2
};
bool NetGameInfo_RaiseIntervalMode_IsValid(int value);
constexpr NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN = NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
constexpr NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX = NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
constexpr int NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE = NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX + 1;

const std::string& NetGameInfo_RaiseIntervalMode_Name(NetGameInfo_RaiseIntervalMode value);
template<typename T>
inline const std::string& NetGameInfo_RaiseIntervalMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetGameInfo_RaiseIntervalMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetGameInfo_RaiseIntervalMode_Name.");
  return NetGameInfo_RaiseIntervalMode_Name(static_cast<NetGameInfo_RaiseIntervalMode>(enum_t_value));
}
bool NetGameInfo_RaiseIntervalMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameInfo_RaiseIntervalMode* value);
enum NetGameInfo_EndRaiseMode : int {
  NetGameInfo_EndRaiseMode_doubleBlinds = 1,
  NetGameInfo_EndRaiseMode_raiseByEndValue = 2,
  NetGameInfo_EndRaiseMode_keepLastBlind = 3
};
bool NetGameInfo_EndRaiseMode_IsValid(int value);
constexpr NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MIN = NetGameInfo_EndRaiseMode_doubleBlinds;
constexpr NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MAX = NetGameInfo_EndRaiseMode_keepLastBlind;
constexpr int NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE = NetGameInfo_EndRaiseMode_EndRaiseMode_MAX + 1;

const std::string& NetGameInfo_EndRaiseMode_Name(NetGameInfo_EndRaiseMode value);
template<typename T>
inline const std::string& NetGameInfo_EndRaiseMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetGameInfo_EndRaiseMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetGameInfo_EndRaiseMode_Name.");
  return NetGameInfo_EndRaiseMode_Name(static_cast<NetGameInfo_EndRaiseMode>(enum_t_value));
}
bool NetGameInfo_EndRaiseMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameInfo_EndRaiseMode* value);
enum AnnounceMessage_ServerType : int {
  AnnounceMessage_ServerType_serverTypeLAN = 0,
  AnnounceMessage_ServerType_serverTypeInternetNoAuth = 1,
  AnnounceMessage_ServerType_serverTypeInternetAuth = 2
};
bool AnnounceMessage_ServerType_IsValid(int value);
constexpr AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MIN = AnnounceMessage_ServerType_serverTypeLAN;
constexpr AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MAX = AnnounceMessage_ServerType_serverTypeInternetAuth;
constexpr int AnnounceMessage_ServerType_ServerType_ARRAYSIZE = AnnounceMessage_ServerType_ServerType_MAX + 1;

const std::string& AnnounceMessage_ServerType_Name(AnnounceMessage_ServerType value);
template<typename T>
inline const std::string& AnnounceMessage_ServerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnnounceMessage_ServerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnnounceMessage_ServerType_Name.");
  return AnnounceMessage_ServerType_Name(static_cast<AnnounceMessage_ServerType>(enum_t_value));
}
bool AnnounceMessage_ServerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnnounceMessage_ServerType* value);
enum InitMessage_LoginType : int {
  InitMessage_LoginType_guestLogin = 0,
  InitMessage_LoginType_authenticatedLogin = 1,
  InitMessage_LoginType_unauthenticatedLogin = 2
};
bool InitMessage_LoginType_IsValid(int value);
constexpr InitMessage_LoginType InitMessage_LoginType_LoginType_MIN = InitMessage_LoginType_guestLogin;
constexpr InitMessage_LoginType InitMessage_LoginType_LoginType_MAX = InitMessage_LoginType_unauthenticatedLogin;
constexpr int InitMessage_LoginType_LoginType_ARRAYSIZE = InitMessage_LoginType_LoginType_MAX + 1;

const std::string& InitMessage_LoginType_Name(InitMessage_LoginType value);
template<typename T>
inline const std::string& InitMessage_LoginType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InitMessage_LoginType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InitMessage_LoginType_Name.");
  return InitMessage_LoginType_Name(static_cast<InitMessage_LoginType>(enum_t_value));
}
bool InitMessage_LoginType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InitMessage_LoginType* value);
enum PlayerListMessage_PlayerListNotification : int {
  PlayerListMessage_PlayerListNotification_playerListNew = 0,
  PlayerListMessage_PlayerListNotification_playerListLeft = 1
};
bool PlayerListMessage_PlayerListNotification_IsValid(int value);
constexpr PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN = PlayerListMessage_PlayerListNotification_playerListNew;
constexpr PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX = PlayerListMessage_PlayerListNotification_playerListLeft;
constexpr int PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE = PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX + 1;

const std::string& PlayerListMessage_PlayerListNotification_Name(PlayerListMessage_PlayerListNotification value);
template<typename T>
inline const std::string& PlayerListMessage_PlayerListNotification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerListMessage_PlayerListNotification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerListMessage_PlayerListNotification_Name.");
  return PlayerListMessage_PlayerListNotification_Name(static_cast<PlayerListMessage_PlayerListNotification>(enum_t_value));
}
bool PlayerListMessage_PlayerListNotification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerListMessage_PlayerListNotification* value);
enum SubscriptionRequestMessage_SubscriptionAction : int {
  SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList = 1,
  SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList = 2
};
bool SubscriptionRequestMessage_SubscriptionAction_IsValid(int value);
constexpr SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN = SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
constexpr SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX = SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
constexpr int SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE = SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX + 1;

const std::string& SubscriptionRequestMessage_SubscriptionAction_Name(SubscriptionRequestMessage_SubscriptionAction value);
template<typename T>
inline const std::string& SubscriptionRequestMessage_SubscriptionAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscriptionRequestMessage_SubscriptionAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscriptionRequestMessage_SubscriptionAction_Name.");
  return SubscriptionRequestMessage_SubscriptionAction_Name(static_cast<SubscriptionRequestMessage_SubscriptionAction>(enum_t_value));
}
bool SubscriptionRequestMessage_SubscriptionAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionRequestMessage_SubscriptionAction* value);
enum JoinGameFailedMessage_JoinGameFailureReason : int {
  JoinGameFailedMessage_JoinGameFailureReason_invalidGame = 1,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsFull = 2,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning = 3,
  JoinGameFailedMessage_JoinGameFailureReason_invalidPassword = 4,
  JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest = 5,
  JoinGameFailedMessage_JoinGameFailureReason_notInvited = 6,
  JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse = 7,
  JoinGameFailedMessage_JoinGameFailureReason_badGameName = 8,
  JoinGameFailedMessage_JoinGameFailureReason_invalidSettings = 9,
  JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked = 10,
  JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed = 11,
  JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed = 12
};
bool JoinGameFailedMessage_JoinGameFailureReason_IsValid(int value);
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN = JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
constexpr JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX = JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed;
constexpr int JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE = JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX + 1;

const std::string& JoinGameFailedMessage_JoinGameFailureReason_Name(JoinGameFailedMessage_JoinGameFailureReason value);
template<typename T>
inline const std::string& JoinGameFailedMessage_JoinGameFailureReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JoinGameFailedMessage_JoinGameFailureReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JoinGameFailedMessage_JoinGameFailureReason_Name.");
  return JoinGameFailedMessage_JoinGameFailureReason_Name(static_cast<JoinGameFailedMessage_JoinGameFailureReason>(enum_t_value));
}
bool JoinGameFailedMessage_JoinGameFailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JoinGameFailedMessage_JoinGameFailureReason* value);
enum GamePlayerLeftMessage_GamePlayerLeftReason : int {
  GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest = 0,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked = 1,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftError = 2
};
bool GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(int value);
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN = GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
constexpr GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX = GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
constexpr int GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE = GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX + 1;

const std::string& GamePlayerLeftMessage_GamePlayerLeftReason_Name(GamePlayerLeftMessage_GamePlayerLeftReason value);
template<typename T>
inline const std::string& GamePlayerLeftMessage_GamePlayerLeftReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GamePlayerLeftMessage_GamePlayerLeftReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GamePlayerLeftMessage_GamePlayerLeftReason_Name.");
  return GamePlayerLeftMessage_GamePlayerLeftReason_Name(static_cast<GamePlayerLeftMessage_GamePlayerLeftReason>(enum_t_value));
}
bool GamePlayerLeftMessage_GamePlayerLeftReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GamePlayerLeftMessage_GamePlayerLeftReason* value);
enum RemovedFromGameMessage_RemovedFromGameReason : int {
  RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest = 0,
  RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame = 1,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsFull = 2,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning = 3,
  RemovedFromGameMessage_RemovedFromGameReason_gameTimeout = 4,
  RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed = 5,
  RemovedFromGameMessage_RemovedFromGameReason_gameClosed = 6
};
bool RemovedFromGameMessage_RemovedFromGameReason_IsValid(int value);
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN = RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
constexpr RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX = RemovedFromGameMessage_RemovedFromGameReason_gameClosed;
constexpr int RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE = RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX + 1;

const std::string& RemovedFromGameMessage_RemovedFromGameReason_Name(RemovedFromGameMessage_RemovedFromGameReason value);
template<typename T>
inline const std::string& RemovedFromGameMessage_RemovedFromGameReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RemovedFromGameMessage_RemovedFromGameReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RemovedFromGameMessage_RemovedFromGameReason_Name.");
  return RemovedFromGameMessage_RemovedFromGameReason_Name(static_cast<RemovedFromGameMessage_RemovedFromGameReason>(enum_t_value));
}
bool RemovedFromGameMessage_RemovedFromGameReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemovedFromGameMessage_RemovedFromGameReason* value);
enum RejectGameInvitationMessage_RejectGameInvReason : int {
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo = 0,
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy = 1
};
bool RejectGameInvitationMessage_RejectGameInvReason_IsValid(int value);
constexpr RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
constexpr RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
constexpr int RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE = RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX + 1;

const std::string& RejectGameInvitationMessage_RejectGameInvReason_Name(RejectGameInvitationMessage_RejectGameInvReason value);
template<typename T>
inline const std::string& RejectGameInvitationMessage_RejectGameInvReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RejectGameInvitationMessage_RejectGameInvReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RejectGameInvitationMessage_RejectGameInvReason_Name.");
  return RejectGameInvitationMessage_RejectGameInvReason_Name(static_cast<RejectGameInvitationMessage_RejectGameInvReason>(enum_t_value));
}
bool RejectGameInvitationMessage_RejectGameInvReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RejectGameInvitationMessage_RejectGameInvReason* value);
enum StartEventMessage_StartEventType : int {
  StartEventMessage_StartEventType_startEvent = 0,
  StartEventMessage_StartEventType_rejoinEvent = 1
};
bool StartEventMessage_StartEventType_IsValid(int value);
constexpr StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MIN = StartEventMessage_StartEventType_startEvent;
constexpr StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MAX = StartEventMessage_StartEventType_rejoinEvent;
constexpr int StartEventMessage_StartEventType_StartEventType_ARRAYSIZE = StartEventMessage_StartEventType_StartEventType_MAX + 1;

const std::string& StartEventMessage_StartEventType_Name(StartEventMessage_StartEventType value);
template<typename T>
inline const std::string& StartEventMessage_StartEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartEventMessage_StartEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartEventMessage_StartEventType_Name.");
  return StartEventMessage_StartEventType_Name(static_cast<StartEventMessage_StartEventType>(enum_t_value));
}
bool StartEventMessage_StartEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StartEventMessage_StartEventType* value);
enum YourActionRejectedMessage_RejectionReason : int {
  YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState = 1,
  YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn = 2,
  YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed = 3
};
bool YourActionRejectedMessage_RejectionReason_IsValid(int value);
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MIN = YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
constexpr YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MAX = YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
constexpr int YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE = YourActionRejectedMessage_RejectionReason_RejectionReason_MAX + 1;

const std::string& YourActionRejectedMessage_RejectionReason_Name(YourActionRejectedMessage_RejectionReason value);
template<typename T>
inline const std::string& YourActionRejectedMessage_RejectionReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, YourActionRejectedMessage_RejectionReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function YourActionRejectedMessage_RejectionReason_Name.");
  return YourActionRejectedMessage_RejectionReason_Name(static_cast<YourActionRejectedMessage_RejectionReason>(enum_t_value));
}
bool YourActionRejectedMessage_RejectionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, YourActionRejectedMessage_RejectionReason* value);
enum AskKickDeniedMessage_KickDeniedReason : int {
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState = 0,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible = 1,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater = 2,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress = 3,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId = 4
};
bool AskKickDeniedMessage_KickDeniedReason_IsValid(int value);
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
constexpr AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
constexpr int AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE = AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX + 1;

const std::string& AskKickDeniedMessage_KickDeniedReason_Name(AskKickDeniedMessage_KickDeniedReason value);
template<typename T>
inline const std::string& AskKickDeniedMessage_KickDeniedReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AskKickDeniedMessage_KickDeniedReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AskKickDeniedMessage_KickDeniedReason_Name.");
  return AskKickDeniedMessage_KickDeniedReason_Name(static_cast<AskKickDeniedMessage_KickDeniedReason>(enum_t_value));
}
bool AskKickDeniedMessage_KickDeniedReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AskKickDeniedMessage_KickDeniedReason* value);
enum VoteKickReplyMessage_VoteKickReplyType : int {
  VoteKickReplyMessage_VoteKickReplyType_voteKickAck = 0,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid = 1,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted = 2
};
bool VoteKickReplyMessage_VoteKickReplyType_IsValid(int value);
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN = VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
constexpr VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
constexpr int VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE = VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX + 1;

const std::string& VoteKickReplyMessage_VoteKickReplyType_Name(VoteKickReplyMessage_VoteKickReplyType value);
template<typename T>
inline const std::string& VoteKickReplyMessage_VoteKickReplyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VoteKickReplyMessage_VoteKickReplyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VoteKickReplyMessage_VoteKickReplyType_Name.");
  return VoteKickReplyMessage_VoteKickReplyType_Name(static_cast<VoteKickReplyMessage_VoteKickReplyType>(enum_t_value));
}
bool VoteKickReplyMessage_VoteKickReplyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VoteKickReplyMessage_VoteKickReplyType* value);
enum EndKickPetitionMessage_PetitionEndReason : int {
  EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes = 0,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers = 1,
  EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft = 2,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout = 3
};
bool EndKickPetitionMessage_PetitionEndReason_IsValid(int value);
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN = EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
constexpr EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX = EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
constexpr int EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE = EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX + 1;

const std::string& EndKickPetitionMessage_PetitionEndReason_Name(EndKickPetitionMessage_PetitionEndReason value);
template<typename T>
inline const std::string& EndKickPetitionMessage_PetitionEndReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EndKickPetitionMessage_PetitionEndReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EndKickPetitionMessage_PetitionEndReason_Name.");
  return EndKickPetitionMessage_PetitionEndReason_Name(static_cast<EndKickPetitionMessage_PetitionEndReason>(enum_t_value));
}
bool EndKickPetitionMessage_PetitionEndReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EndKickPetitionMessage_PetitionEndReason* value);
enum StatisticsMessage_StatisticsData_StatisticsType : int {
  StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers = 1
};
bool StatisticsMessage_StatisticsData_StatisticsType_IsValid(int value);
constexpr StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
constexpr StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
constexpr int StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE = StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX + 1;

const std::string& StatisticsMessage_StatisticsData_StatisticsType_Name(StatisticsMessage_StatisticsData_StatisticsType value);
template<typename T>
inline const std::string& StatisticsMessage_StatisticsData_StatisticsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatisticsMessage_StatisticsData_StatisticsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatisticsMessage_StatisticsData_StatisticsType_Name.");
  return StatisticsMessage_StatisticsData_StatisticsType_Name(static_cast<StatisticsMessage_StatisticsData_StatisticsType>(enum_t_value));
}
bool StatisticsMessage_StatisticsData_StatisticsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatisticsMessage_StatisticsData_StatisticsType* value);
enum ChatMessage_ChatType : int {
  ChatMessage_ChatType_chatTypeLobby = 0,
  ChatMessage_ChatType_chatTypeGame = 1,
  ChatMessage_ChatType_chatTypeBot = 2,
  ChatMessage_ChatType_chatTypeBroadcast = 3,
  ChatMessage_ChatType_chatTypePrivate = 4
};
bool ChatMessage_ChatType_IsValid(int value);
constexpr ChatMessage_ChatType ChatMessage_ChatType_ChatType_MIN = ChatMessage_ChatType_chatTypeLobby;
constexpr ChatMessage_ChatType ChatMessage_ChatType_ChatType_MAX = ChatMessage_ChatType_chatTypePrivate;
constexpr int ChatMessage_ChatType_ChatType_ARRAYSIZE = ChatMessage_ChatType_ChatType_MAX + 1;

const std::string& ChatMessage_ChatType_Name(ChatMessage_ChatType value);
template<typename T>
inline const std::string& ChatMessage_ChatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMessage_ChatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMessage_ChatType_Name.");
  return ChatMessage_ChatType_Name(static_cast<ChatMessage_ChatType>(enum_t_value));
}
bool ChatMessage_ChatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessage_ChatType* value);
enum TimeoutWarningMessage_TimeoutReason : int {
  TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived = 0,
  TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame = 1,
  TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold = 2
};
bool TimeoutWarningMessage_TimeoutReason_IsValid(int value);
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN = TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
constexpr TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX = TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
constexpr int TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE = TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX + 1;

const std::string& TimeoutWarningMessage_TimeoutReason_Name(TimeoutWarningMessage_TimeoutReason value);
template<typename T>
inline const std::string& TimeoutWarningMessage_TimeoutReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeoutWarningMessage_TimeoutReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeoutWarningMessage_TimeoutReason_Name.");
  return TimeoutWarningMessage_TimeoutReason_Name(static_cast<TimeoutWarningMessage_TimeoutReason>(enum_t_value));
}
bool TimeoutWarningMessage_TimeoutReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeoutWarningMessage_TimeoutReason* value);
enum ReportAvatarAckMessage_ReportAvatarResult : int {
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted = 0,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate = 1,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid = 2
};
bool ReportAvatarAckMessage_ReportAvatarResult_IsValid(int value);
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN = ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
constexpr ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX = ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
constexpr int ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE = ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX + 1;

const std::string& ReportAvatarAckMessage_ReportAvatarResult_Name(ReportAvatarAckMessage_ReportAvatarResult value);
template<typename T>
inline const std::string& ReportAvatarAckMessage_ReportAvatarResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReportAvatarAckMessage_ReportAvatarResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReportAvatarAckMessage_ReportAvatarResult_Name.");
  return ReportAvatarAckMessage_ReportAvatarResult_Name(static_cast<ReportAvatarAckMessage_ReportAvatarResult>(enum_t_value));
}
bool ReportAvatarAckMessage_ReportAvatarResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReportAvatarAckMessage_ReportAvatarResult* value);
enum ReportGameAckMessage_ReportGameResult : int {
  ReportGameAckMessage_ReportGameResult_gameReportAccepted = 0,
  ReportGameAckMessage_ReportGameResult_gameReportDuplicate = 1,
  ReportGameAckMessage_ReportGameResult_gameReportInvalid = 2
};
bool ReportGameAckMessage_ReportGameResult_IsValid(int value);
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN = ReportGameAckMessage_ReportGameResult_gameReportAccepted;
constexpr ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX = ReportGameAckMessage_ReportGameResult_gameReportInvalid;
constexpr int ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE = ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX + 1;

const std::string& ReportGameAckMessage_ReportGameResult_Name(ReportGameAckMessage_ReportGameResult value);
template<typename T>
inline const std::string& ReportGameAckMessage_ReportGameResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReportGameAckMessage_ReportGameResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReportGameAckMessage_ReportGameResult_Name.");
  return ReportGameAckMessage_ReportGameResult_Name(static_cast<ReportGameAckMessage_ReportGameResult>(enum_t_value));
}
bool ReportGameAckMessage_ReportGameResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReportGameAckMessage_ReportGameResult* value);
enum ErrorMessage_ErrorReason : int {
  ErrorMessage_ErrorReason_custReserved = 0,
  ErrorMessage_ErrorReason_initVersionNotSupported = 1,
  ErrorMessage_ErrorReason_initServerFull = 2,
  ErrorMessage_ErrorReason_initAuthFailure = 3,
  ErrorMessage_ErrorReason_initPlayerNameInUse = 4,
  ErrorMessage_ErrorReason_initInvalidPlayerName = 5,
  ErrorMessage_ErrorReason_initServerMaintenance = 6,
  ErrorMessage_ErrorReason_initBlocked = 7,
  ErrorMessage_ErrorReason_avatarTooLarge = 8,
  ErrorMessage_ErrorReason_invalidPacket = 9,
  ErrorMessage_ErrorReason_invalidState = 10,
  ErrorMessage_ErrorReason_kickedFromServer = 11,
  ErrorMessage_ErrorReason_bannedFromServer = 12,
  ErrorMessage_ErrorReason_blockedByServer = 13,
  ErrorMessage_ErrorReason_sessionTimeout = 14
};
bool ErrorMessage_ErrorReason_IsValid(int value);
constexpr ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MIN = ErrorMessage_ErrorReason_custReserved;
constexpr ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MAX = ErrorMessage_ErrorReason_sessionTimeout;
constexpr int ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE = ErrorMessage_ErrorReason_ErrorReason_MAX + 1;

const std::string& ErrorMessage_ErrorReason_Name(ErrorMessage_ErrorReason value);
template<typename T>
inline const std::string& ErrorMessage_ErrorReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorMessage_ErrorReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorMessage_ErrorReason_Name.");
  return ErrorMessage_ErrorReason_Name(static_cast<ErrorMessage_ErrorReason>(enum_t_value));
}
bool ErrorMessage_ErrorReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorMessage_ErrorReason* value);
enum AdminRemoveGameAckMessage_AdminRemoveGameResult : int {
  AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted = 0,
  AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid = 1
};
bool AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(int value);
constexpr AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MIN = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted;
constexpr AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid;
constexpr int AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_ARRAYSIZE = AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX + 1;

const std::string& AdminRemoveGameAckMessage_AdminRemoveGameResult_Name(AdminRemoveGameAckMessage_AdminRemoveGameResult value);
template<typename T>
inline const std::string& AdminRemoveGameAckMessage_AdminRemoveGameResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminRemoveGameAckMessage_AdminRemoveGameResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminRemoveGameAckMessage_AdminRemoveGameResult_Name.");
  return AdminRemoveGameAckMessage_AdminRemoveGameResult_Name(static_cast<AdminRemoveGameAckMessage_AdminRemoveGameResult>(enum_t_value));
}
bool AdminRemoveGameAckMessage_AdminRemoveGameResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminRemoveGameAckMessage_AdminRemoveGameResult* value);
enum AdminBanPlayerAckMessage_AdminBanPlayerResult : int {
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted = 0,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerPending = 1,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerNoDB = 2,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerDBError = 3,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid = 4
};
bool AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(int value);
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MIN = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted;
constexpr AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid;
constexpr int AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_ARRAYSIZE = AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX + 1;

const std::string& AdminBanPlayerAckMessage_AdminBanPlayerResult_Name(AdminBanPlayerAckMessage_AdminBanPlayerResult value);
template<typename T>
inline const std::string& AdminBanPlayerAckMessage_AdminBanPlayerResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminBanPlayerAckMessage_AdminBanPlayerResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminBanPlayerAckMessage_AdminBanPlayerResult_Name.");
  return AdminBanPlayerAckMessage_AdminBanPlayerResult_Name(static_cast<AdminBanPlayerAckMessage_AdminBanPlayerResult>(enum_t_value));
}
bool AdminBanPlayerAckMessage_AdminBanPlayerResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminBanPlayerAckMessage_AdminBanPlayerResult* value);
enum PokerTHMessage_PokerTHMessageType : int {
  PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage = 1,
  PokerTHMessage_PokerTHMessageType_Type_InitMessage = 2,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage = 3,
  PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage = 4,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage = 5,
  PokerTHMessage_PokerTHMessageType_Type_InitAckMessage = 6,
  PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage = 7,
  PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage = 8,
  PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage = 9,
  PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage = 10,
  PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage = 11,
  PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage = 12,
  PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage = 13,
  PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage = 14,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage = 15,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage = 16,
  PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage = 17,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage = 18,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage = 19,
  PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage = 20,
  PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage = 21,
  PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage = 22,
  PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage = 23,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage = 24,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage = 25,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage = 26,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage = 27,
  PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage = 28,
  PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage = 29,
  PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage = 30,
  PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage = 31,
  PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage = 32,
  PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage = 33,
  PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage = 34,
  PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage = 35,
  PokerTHMessage_PokerTHMessageType_Type_StartEventMessage = 36,
  PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage = 37,
  PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage = 38,
  PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage = 39,
  PokerTHMessage_PokerTHMessageType_Type_HandStartMessage = 40,
  PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage = 41,
  PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage = 42,
  PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage = 43,
  PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage = 44,
  PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage = 45,
  PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage = 46,
  PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage = 47,
  PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage = 48,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage = 49,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage = 50,
  PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage = 51,
  PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage = 52,
  PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage = 53,
  PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage = 54,
  PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage = 55,
  PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage = 56,
  PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage = 57,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage = 58,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage = 59,
  PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage = 60,
  PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage = 61,
  PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage = 62,
  PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage = 63,
  PokerTHMessage_PokerTHMessageType_Type_ChatMessage = 64,
  PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage = 65,
  PokerTHMessage_PokerTHMessageType_Type_DialogMessage = 66,
  PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage = 67,
  PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage = 68,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage = 69,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage = 70,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage = 71,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage = 72,
  PokerTHMessage_PokerTHMessageType_Type_ErrorMessage = 73,
  PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameMessage = 74,
  PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameAckMessage = 75,
  PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerMessage = 76,
  PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerAckMessage = 77,
  PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorJoinedMessage = 78,
  PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorLeftMessage = 79,
  PokerTHMessage_PokerTHMessageType_Type_GameSpectatorJoinedMessage = 80,
  PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage = 81
};
bool PokerTHMessage_PokerTHMessageType_IsValid(int value);
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN = PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
constexpr PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX = PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage;
constexpr int PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE = PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX + 1;

const std::string& PokerTHMessage_PokerTHMessageType_Name(PokerTHMessage_PokerTHMessageType value);
template<typename T>
inline const std::string& PokerTHMessage_PokerTHMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PokerTHMessage_PokerTHMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PokerTHMessage_PokerTHMessageType_Name.");
  return PokerTHMessage_PokerTHMessageType_Name(static_cast<PokerTHMessage_PokerTHMessageType>(enum_t_value));
}
bool PokerTHMessage_PokerTHMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PokerTHMessage_PokerTHMessageType* value);
enum NetGameMode : int {
  netGameCreated = 1,
  netGameStarted = 2,
  netGameClosed = 3
};
bool NetGameMode_IsValid(int value);
constexpr NetGameMode NetGameMode_MIN = netGameCreated;
constexpr NetGameMode NetGameMode_MAX = netGameClosed;
constexpr int NetGameMode_ARRAYSIZE = NetGameMode_MAX + 1;

const std::string& NetGameMode_Name(NetGameMode value);
template<typename T>
inline const std::string& NetGameMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetGameMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetGameMode_Name.");
  return NetGameMode_Name(static_cast<NetGameMode>(enum_t_value));
}
bool NetGameMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameMode* value);
enum NetGameState : int {
  netStatePreflop = 0,
  netStateFlop = 1,
  netStateTurn = 2,
  netStateRiver = 3,
  netStatePreflopSmallBlind = 4,
  netStatePreflopBigBlind = 5
};
bool NetGameState_IsValid(int value);
constexpr NetGameState NetGameState_MIN = netStatePreflop;
constexpr NetGameState NetGameState_MAX = netStatePreflopBigBlind;
constexpr int NetGameState_ARRAYSIZE = NetGameState_MAX + 1;

const std::string& NetGameState_Name(NetGameState value);
template<typename T>
inline const std::string& NetGameState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetGameState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetGameState_Name.");
  return NetGameState_Name(static_cast<NetGameState>(enum_t_value));
}
bool NetGameState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetGameState* value);
enum NetPlayerAction : int {
  netActionNone = 0,
  netActionFold = 1,
  netActionCheck = 2,
  netActionCall = 3,
  netActionBet = 4,
  netActionRaise = 5,
  netActionAllIn = 6
};
bool NetPlayerAction_IsValid(int value);
constexpr NetPlayerAction NetPlayerAction_MIN = netActionNone;
constexpr NetPlayerAction NetPlayerAction_MAX = netActionAllIn;
constexpr int NetPlayerAction_ARRAYSIZE = NetPlayerAction_MAX + 1;

const std::string& NetPlayerAction_Name(NetPlayerAction value);
template<typename T>
inline const std::string& NetPlayerAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetPlayerAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetPlayerAction_Name.");
  return NetPlayerAction_Name(static_cast<NetPlayerAction>(enum_t_value));
}
bool NetPlayerAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetPlayerAction* value);
enum NetPlayerState : int {
  netPlayerStateNormal = 0,
  netPlayerStateSessionInactive = 1,
  netPlayerStateNoMoney = 2
};
bool NetPlayerState_IsValid(int value);
constexpr NetPlayerState NetPlayerState_MIN = netPlayerStateNormal;
constexpr NetPlayerState NetPlayerState_MAX = netPlayerStateNoMoney;
constexpr int NetPlayerState_ARRAYSIZE = NetPlayerState_MAX + 1;

const std::string& NetPlayerState_Name(NetPlayerState value);
template<typename T>
inline const std::string& NetPlayerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetPlayerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetPlayerState_Name.");
  return NetPlayerState_Name(static_cast<NetPlayerState>(enum_t_value));
}
bool NetPlayerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetPlayerState* value);
enum NetPlayerInfoRights : int {
  netPlayerRightsGuest = 1,
  netPlayerRightsNormal = 2,
  netPlayerRightsAdmin = 3
};
bool NetPlayerInfoRights_IsValid(int value);
constexpr NetPlayerInfoRights NetPlayerInfoRights_MIN = netPlayerRightsGuest;
constexpr NetPlayerInfoRights NetPlayerInfoRights_MAX = netPlayerRightsAdmin;
constexpr int NetPlayerInfoRights_ARRAYSIZE = NetPlayerInfoRights_MAX + 1;

const std::string& NetPlayerInfoRights_Name(NetPlayerInfoRights value);
template<typename T>
inline const std::string& NetPlayerInfoRights_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetPlayerInfoRights>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetPlayerInfoRights_Name.");
  return NetPlayerInfoRights_Name(static_cast<NetPlayerInfoRights>(enum_t_value));
}
bool NetPlayerInfoRights_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetPlayerInfoRights* value);
enum NetAvatarType : int {
  netAvatarImagePng = 1,
  netAvatarImageJpg = 2,
  netAvatarImageGif = 3
};
bool NetAvatarType_IsValid(int value);
constexpr NetAvatarType NetAvatarType_MIN = netAvatarImagePng;
constexpr NetAvatarType NetAvatarType_MAX = netAvatarImageGif;
constexpr int NetAvatarType_ARRAYSIZE = NetAvatarType_MAX + 1;

const std::string& NetAvatarType_Name(NetAvatarType value);
template<typename T>
inline const std::string& NetAvatarType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetAvatarType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetAvatarType_Name.");
  return NetAvatarType_Name(static_cast<NetAvatarType>(enum_t_value));
}
bool NetAvatarType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetAvatarType* value);
// ===================================================================

class NetGameInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:NetGameInfo) */ {
 public:
  inline NetGameInfo() : NetGameInfo(nullptr) {}
  ~NetGameInfo() override;
  explicit constexpr NetGameInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetGameInfo(const NetGameInfo& from);
  NetGameInfo(NetGameInfo&& from) noexcept
    : NetGameInfo() {
    *this = ::std::move(from);
  }

  inline NetGameInfo& operator=(const NetGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetGameInfo& operator=(NetGameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetGameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetGameInfo* internal_default_instance() {
    return reinterpret_cast<const NetGameInfo*>(
               &_NetGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetGameInfo& a, NetGameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NetGameInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetGameInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetGameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetGameInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetGameInfo& from);
  void MergeFrom(const NetGameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetGameInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NetGameInfo";
  }
  protected:
  explicit NetGameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetGameInfo_NetGameType NetGameType;
  static constexpr NetGameType normalGame =
    NetGameInfo_NetGameType_normalGame;
  static constexpr NetGameType registeredOnlyGame =
    NetGameInfo_NetGameType_registeredOnlyGame;
  static constexpr NetGameType inviteOnlyGame =
    NetGameInfo_NetGameType_inviteOnlyGame;
  static constexpr NetGameType rankingGame =
    NetGameInfo_NetGameType_rankingGame;
  static inline bool NetGameType_IsValid(int value) {
    return NetGameInfo_NetGameType_IsValid(value);
  }
  static constexpr NetGameType NetGameType_MIN =
    NetGameInfo_NetGameType_NetGameType_MIN;
  static constexpr NetGameType NetGameType_MAX =
    NetGameInfo_NetGameType_NetGameType_MAX;
  static constexpr int NetGameType_ARRAYSIZE =
    NetGameInfo_NetGameType_NetGameType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& NetGameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NetGameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NetGameType_Name.");
    return NetGameInfo_NetGameType_Name(enum_t_value);
  }
  static inline bool NetGameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NetGameType* value) {
    return NetGameInfo_NetGameType_Parse(name, value);
  }

  typedef NetGameInfo_RaiseIntervalMode RaiseIntervalMode;
  static constexpr RaiseIntervalMode raiseOnHandNum =
    NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
  static constexpr RaiseIntervalMode raiseOnMinutes =
    NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
  static inline bool RaiseIntervalMode_IsValid(int value) {
    return NetGameInfo_RaiseIntervalMode_IsValid(value);
  }
  static constexpr RaiseIntervalMode RaiseIntervalMode_MIN =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN;
  static constexpr RaiseIntervalMode RaiseIntervalMode_MAX =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX;
  static constexpr int RaiseIntervalMode_ARRAYSIZE =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RaiseIntervalMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RaiseIntervalMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RaiseIntervalMode_Name.");
    return NetGameInfo_RaiseIntervalMode_Name(enum_t_value);
  }
  static inline bool RaiseIntervalMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RaiseIntervalMode* value) {
    return NetGameInfo_RaiseIntervalMode_Parse(name, value);
  }

  typedef NetGameInfo_EndRaiseMode EndRaiseMode;
  static constexpr EndRaiseMode doubleBlinds =
    NetGameInfo_EndRaiseMode_doubleBlinds;
  static constexpr EndRaiseMode raiseByEndValue =
    NetGameInfo_EndRaiseMode_raiseByEndValue;
  static constexpr EndRaiseMode keepLastBlind =
    NetGameInfo_EndRaiseMode_keepLastBlind;
  static inline bool EndRaiseMode_IsValid(int value) {
    return NetGameInfo_EndRaiseMode_IsValid(value);
  }
  static constexpr EndRaiseMode EndRaiseMode_MIN =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MIN;
  static constexpr EndRaiseMode EndRaiseMode_MAX =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MAX;
  static constexpr int EndRaiseMode_ARRAYSIZE =
    NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EndRaiseMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EndRaiseMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EndRaiseMode_Name.");
    return NetGameInfo_EndRaiseMode_Name(enum_t_value);
  }
  static inline bool EndRaiseMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EndRaiseMode* value) {
    return NetGameInfo_EndRaiseMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kManualBlindsFieldNumber = 14,
    kGameNameFieldNumber = 1,
    kMaxNumPlayersFieldNumber = 3,
    kRaiseEveryHandsFieldNumber = 5,
    kRaiseEveryMinutesFieldNumber = 6,
    kEndRaiseSmallBlindValueFieldNumber = 8,
    kProposedGuiSpeedFieldNumber = 9,
    kDelayBetweenHandsFieldNumber = 10,
    kPlayerActionTimeoutFieldNumber = 11,
    kFirstSmallBlindFieldNumber = 12,
    kStartMoneyFieldNumber = 13,
    kNetGameTypeFieldNumber = 2,
    kRaiseIntervalModeFieldNumber = 4,
    kEndRaiseModeFieldNumber = 7,
    kAllowSpectatorsFieldNumber = 15,
  };
  // repeated uint32 manualBlinds = 14 [packed = true];
  int manualblinds_size() const;
  private:
  int _internal_manualblinds_size() const;
  public:
  void clear_manualblinds();
  private:
  uint32_t _internal_manualblinds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_manualblinds() const;
  void _internal_add_manualblinds(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_manualblinds();
  public:
  uint32_t manualblinds(int index) const;
  void set_manualblinds(int index, uint32_t value);
  void add_manualblinds(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      manualblinds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_manualblinds();

  // required string gameName = 1;
  bool has_gamename() const;
  private:
  bool _internal_has_gamename() const;
  public:
  void clear_gamename();
  const std::string& gamename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamename();
  PROTOBUF_NODISCARD std::string* release_gamename();
  void set_allocated_gamename(std::string* gamename);
  private:
  const std::string& _internal_gamename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamename(const std::string& value);
  std::string* _internal_mutable_gamename();
  public:

  // required uint32 maxNumPlayers = 3;
  bool has_maxnumplayers() const;
  private:
  bool _internal_has_maxnumplayers() const;
  public:
  void clear_maxnumplayers();
  uint32_t maxnumplayers() const;
  void set_maxnumplayers(uint32_t value);
  private:
  uint32_t _internal_maxnumplayers() const;
  void _internal_set_maxnumplayers(uint32_t value);
  public:

  // optional uint32 raiseEveryHands = 5;
  bool has_raiseeveryhands() const;
  private:
  bool _internal_has_raiseeveryhands() const;
  public:
  void clear_raiseeveryhands();
  uint32_t raiseeveryhands() const;
  void set_raiseeveryhands(uint32_t value);
  private:
  uint32_t _internal_raiseeveryhands() const;
  void _internal_set_raiseeveryhands(uint32_t value);
  public:

  // optional uint32 raiseEveryMinutes = 6;
  bool has_raiseeveryminutes() const;
  private:
  bool _internal_has_raiseeveryminutes() const;
  public:
  void clear_raiseeveryminutes();
  uint32_t raiseeveryminutes() const;
  void set_raiseeveryminutes(uint32_t value);
  private:
  uint32_t _internal_raiseeveryminutes() const;
  void _internal_set_raiseeveryminutes(uint32_t value);
  public:

  // optional uint32 endRaiseSmallBlindValue = 8;
  bool has_endraisesmallblindvalue() const;
  private:
  bool _internal_has_endraisesmallblindvalue() const;
  public:
  void clear_endraisesmallblindvalue();
  uint32_t endraisesmallblindvalue() const;
  void set_endraisesmallblindvalue(uint32_t value);
  private:
  uint32_t _internal_endraisesmallblindvalue() const;
  void _internal_set_endraisesmallblindvalue(uint32_t value);
  public:

  // required uint32 proposedGuiSpeed = 9;
  bool has_proposedguispeed() const;
  private:
  bool _internal_has_proposedguispeed() const;
  public:
  void clear_proposedguispeed();
  uint32_t proposedguispeed() const;
  void set_proposedguispeed(uint32_t value);
  private:
  uint32_t _internal_proposedguispeed() const;
  void _internal_set_proposedguispeed(uint32_t value);
  public:

  // required uint32 delayBetweenHands = 10;
  bool has_delaybetweenhands() const;
  private:
  bool _internal_has_delaybetweenhands() const;
  public:
  void clear_delaybetweenhands();
  uint32_t delaybetweenhands() const;
  void set_delaybetweenhands(uint32_t value);
  private:
  uint32_t _internal_delaybetweenhands() const;
  void _internal_set_delaybetweenhands(uint32_t value);
  public:

  // required uint32 playerActionTimeout = 11;
  bool has_playeractiontimeout() const;
  private:
  bool _internal_has_playeractiontimeout() const;
  public:
  void clear_playeractiontimeout();
  uint32_t playeractiontimeout() const;
  void set_playeractiontimeout(uint32_t value);
  private:
  uint32_t _internal_playeractiontimeout() const;
  void _internal_set_playeractiontimeout(uint32_t value);
  public:

  // required uint32 firstSmallBlind = 12;
  bool has_firstsmallblind() const;
  private:
  bool _internal_has_firstsmallblind() const;
  public:
  void clear_firstsmallblind();
  uint32_t firstsmallblind() const;
  void set_firstsmallblind(uint32_t value);
  private:
  uint32_t _internal_firstsmallblind() const;
  void _internal_set_firstsmallblind(uint32_t value);
  public:

  // required uint32 startMoney = 13;
  bool has_startmoney() const;
  private:
  bool _internal_has_startmoney() const;
  public:
  void clear_startmoney();
  uint32_t startmoney() const;
  void set_startmoney(uint32_t value);
  private:
  uint32_t _internal_startmoney() const;
  void _internal_set_startmoney(uint32_t value);
  public:

  // required .NetGameInfo.NetGameType netGameType = 2;
  bool has_netgametype() const;
  private:
  bool _internal_has_netgametype() const;
  public:
  void clear_netgametype();
  ::NetGameInfo_NetGameType netgametype() const;
  void set_netgametype(::NetGameInfo_NetGameType value);
  private:
  ::NetGameInfo_NetGameType _internal_netgametype() const;
  void _internal_set_netgametype(::NetGameInfo_NetGameType value);
  public:

  // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
  bool has_raiseintervalmode() const;
  private:
  bool _internal_has_raiseintervalmode() const;
  public:
  void clear_raiseintervalmode();
  ::NetGameInfo_RaiseIntervalMode raiseintervalmode() const;
  void set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value);
  private:
  ::NetGameInfo_RaiseIntervalMode _internal_raiseintervalmode() const;
  void _internal_set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value);
  public:

  // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
  bool has_endraisemode() const;
  private:
  bool _internal_has_endraisemode() const;
  public:
  void clear_endraisemode();
  ::NetGameInfo_EndRaiseMode endraisemode() const;
  void set_endraisemode(::NetGameInfo_EndRaiseMode value);
  private:
  ::NetGameInfo_EndRaiseMode _internal_endraisemode() const;
  void _internal_set_endraisemode(::NetGameInfo_EndRaiseMode value);
  public:

  // optional bool allowSpectators = 15 [default = true];
  bool has_allowspectators() const;
  private:
  bool _internal_has_allowspectators() const;
  public:
  void clear_allowspectators();
  bool allowspectators() const;
  void set_allowspectators(bool value);
  private:
  bool _internal_allowspectators() const;
  void _internal_set_allowspectators(bool value);
  public:

  // @@protoc_insertion_point(class_scope:NetGameInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > manualblinds_;
  mutable std::atomic<int> _manualblinds_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamename_;
  uint32_t maxnumplayers_;
  uint32_t raiseeveryhands_;
  uint32_t raiseeveryminutes_;
  uint32_t endraisesmallblindvalue_;
  uint32_t proposedguispeed_;
  uint32_t delaybetweenhands_;
  uint32_t playeractiontimeout_;
  uint32_t firstsmallblind_;
  uint32_t startmoney_;
  int netgametype_;
  int raiseintervalmode_;
  int endraisemode_;
  bool allowspectators_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerResult) */ {
 public:
  inline PlayerResult() : PlayerResult(nullptr) {}
  ~PlayerResult() override;
  explicit constexpr PlayerResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerResult(const PlayerResult& from);
  PlayerResult(PlayerResult&& from) noexcept
    : PlayerResult() {
    *this = ::std::move(from);
  }

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerResult& operator=(PlayerResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerResult* internal_default_instance() {
    return reinterpret_cast<const PlayerResult*>(
               &_PlayerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PlayerResult& a, PlayerResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerResult";
  }
  protected:
  explicit PlayerResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBestHandPositionFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
    kResultCard1FieldNumber = 2,
    kResultCard2FieldNumber = 3,
    kMoneyWonFieldNumber = 5,
    kPlayerMoneyFieldNumber = 6,
    kCardsValueFieldNumber = 7,
  };
  // repeated uint32 bestHandPosition = 4 [packed = true];
  int besthandposition_size() const;
  private:
  int _internal_besthandposition_size() const;
  public:
  void clear_besthandposition();
  private:
  uint32_t _internal_besthandposition(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_besthandposition() const;
  void _internal_add_besthandposition(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_besthandposition();
  public:
  uint32_t besthandposition(int index) const;
  void set_besthandposition(int index, uint32_t value);
  void add_besthandposition(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      besthandposition() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_besthandposition();

  // required uint32 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required uint32 resultCard1 = 2;
  bool has_resultcard1() const;
  private:
  bool _internal_has_resultcard1() const;
  public:
  void clear_resultcard1();
  uint32_t resultcard1() const;
  void set_resultcard1(uint32_t value);
  private:
  uint32_t _internal_resultcard1() const;
  void _internal_set_resultcard1(uint32_t value);
  public:

  // required uint32 resultCard2 = 3;
  bool has_resultcard2() const;
  private:
  bool _internal_has_resultcard2() const;
  public:
  void clear_resultcard2();
  uint32_t resultcard2() const;
  void set_resultcard2(uint32_t value);
  private:
  uint32_t _internal_resultcard2() const;
  void _internal_set_resultcard2(uint32_t value);
  public:

  // required uint32 moneyWon = 5;
  bool has_moneywon() const;
  private:
  bool _internal_has_moneywon() const;
  public:
  void clear_moneywon();
  uint32_t moneywon() const;
  void set_moneywon(uint32_t value);
  private:
  uint32_t _internal_moneywon() const;
  void _internal_set_moneywon(uint32_t value);
  public:

  // required uint32 playerMoney = 6;
  bool has_playermoney() const;
  private:
  bool _internal_has_playermoney() const;
  public:
  void clear_playermoney();
  uint32_t playermoney() const;
  void set_playermoney(uint32_t value);
  private:
  uint32_t _internal_playermoney() const;
  void _internal_set_playermoney(uint32_t value);
  public:

  // optional uint32 cardsValue = 7;
  bool has_cardsvalue() const;
  private:
  bool _internal_has_cardsvalue() const;
  public:
  void clear_cardsvalue();
  uint32_t cardsvalue() const;
  void set_cardsvalue(uint32_t value);
  private:
  uint32_t _internal_cardsvalue() const;
  void _internal_set_cardsvalue(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > besthandposition_;
  mutable std::atomic<int> _besthandposition_cached_byte_size_;
  uint32_t playerid_;
  uint32_t resultcard1_;
  uint32_t resultcard2_;
  uint32_t moneywon_;
  uint32_t playermoney_;
  uint32_t cardsvalue_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AnnounceMessage_Version final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AnnounceMessage.Version) */ {
 public:
  inline AnnounceMessage_Version() : AnnounceMessage_Version(nullptr) {}
  ~AnnounceMessage_Version() override;
  explicit constexpr AnnounceMessage_Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnounceMessage_Version(const AnnounceMessage_Version& from);
  AnnounceMessage_Version(AnnounceMessage_Version&& from) noexcept
    : AnnounceMessage_Version() {
    *this = ::std::move(from);
  }

  inline AnnounceMessage_Version& operator=(const AnnounceMessage_Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnounceMessage_Version& operator=(AnnounceMessage_Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AnnounceMessage_Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnounceMessage_Version* internal_default_instance() {
    return reinterpret_cast<const AnnounceMessage_Version*>(
               &_AnnounceMessage_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AnnounceMessage_Version& a, AnnounceMessage_Version& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnounceMessage_Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnounceMessage_Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnounceMessage_Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnounceMessage_Version>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AnnounceMessage_Version& from);
  void MergeFrom(const AnnounceMessage_Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AnnounceMessage_Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnnounceMessage.Version";
  }
  protected:
  explicit AnnounceMessage_Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorVersionFieldNumber = 1,
    kMinorVersionFieldNumber = 2,
  };
  // required uint32 majorVersion = 1;
  bool has_majorversion() const;
  private:
  bool _internal_has_majorversion() const;
  public:
  void clear_majorversion();
  uint32_t majorversion() const;
  void set_majorversion(uint32_t value);
  private:
  uint32_t _internal_majorversion() const;
  void _internal_set_majorversion(uint32_t value);
  public:

  // required uint32 minorVersion = 2;
  bool has_minorversion() const;
  private:
  bool _internal_has_minorversion() const;
  public:
  void clear_minorversion();
  uint32_t minorversion() const;
  void set_minorversion(uint32_t value);
  private:
  uint32_t _internal_minorversion() const;
  void _internal_set_minorversion(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AnnounceMessage.Version)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t majorversion_;
  uint32_t minorversion_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AnnounceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AnnounceMessage) */ {
 public:
  inline AnnounceMessage() : AnnounceMessage(nullptr) {}
  ~AnnounceMessage() override;
  explicit constexpr AnnounceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnounceMessage(const AnnounceMessage& from);
  AnnounceMessage(AnnounceMessage&& from) noexcept
    : AnnounceMessage() {
    *this = ::std::move(from);
  }

  inline AnnounceMessage& operator=(const AnnounceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnounceMessage& operator=(AnnounceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AnnounceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnounceMessage* internal_default_instance() {
    return reinterpret_cast<const AnnounceMessage*>(
               &_AnnounceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AnnounceMessage& a, AnnounceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnounceMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnounceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnounceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnounceMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AnnounceMessage& from);
  void MergeFrom(const AnnounceMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AnnounceMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnnounceMessage";
  }
  protected:
  explicit AnnounceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AnnounceMessage_Version Version;

  typedef AnnounceMessage_ServerType ServerType;
  static constexpr ServerType serverTypeLAN =
    AnnounceMessage_ServerType_serverTypeLAN;
  static constexpr ServerType serverTypeInternetNoAuth =
    AnnounceMessage_ServerType_serverTypeInternetNoAuth;
  static constexpr ServerType serverTypeInternetAuth =
    AnnounceMessage_ServerType_serverTypeInternetAuth;
  static inline bool ServerType_IsValid(int value) {
    return AnnounceMessage_ServerType_IsValid(value);
  }
  static constexpr ServerType ServerType_MIN =
    AnnounceMessage_ServerType_ServerType_MIN;
  static constexpr ServerType ServerType_MAX =
    AnnounceMessage_ServerType_ServerType_MAX;
  static constexpr int ServerType_ARRAYSIZE =
    AnnounceMessage_ServerType_ServerType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ServerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServerType_Name.");
    return AnnounceMessage_ServerType_Name(enum_t_value);
  }
  static inline bool ServerType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServerType* value) {
    return AnnounceMessage_ServerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolVersionFieldNumber = 1,
    kLatestGameVersionFieldNumber = 2,
    kLatestBetaRevisionFieldNumber = 3,
    kServerTypeFieldNumber = 4,
    kNumPlayersOnServerFieldNumber = 5,
  };
  // required .AnnounceMessage.Version protocolVersion = 1;
  bool has_protocolversion() const;
  private:
  bool _internal_has_protocolversion() const;
  public:
  void clear_protocolversion();
  const ::AnnounceMessage_Version& protocolversion() const;
  PROTOBUF_NODISCARD ::AnnounceMessage_Version* release_protocolversion();
  ::AnnounceMessage_Version* mutable_protocolversion();
  void set_allocated_protocolversion(::AnnounceMessage_Version* protocolversion);
  private:
  const ::AnnounceMessage_Version& _internal_protocolversion() const;
  ::AnnounceMessage_Version* _internal_mutable_protocolversion();
  public:
  void unsafe_arena_set_allocated_protocolversion(
      ::AnnounceMessage_Version* protocolversion);
  ::AnnounceMessage_Version* unsafe_arena_release_protocolversion();

  // required .AnnounceMessage.Version latestGameVersion = 2;
  bool has_latestgameversion() const;
  private:
  bool _internal_has_latestgameversion() const;
  public:
  void clear_latestgameversion();
  const ::AnnounceMessage_Version& latestgameversion() const;
  PROTOBUF_NODISCARD ::AnnounceMessage_Version* release_latestgameversion();
  ::AnnounceMessage_Version* mutable_latestgameversion();
  void set_allocated_latestgameversion(::AnnounceMessage_Version* latestgameversion);
  private:
  const ::AnnounceMessage_Version& _internal_latestgameversion() const;
  ::AnnounceMessage_Version* _internal_mutable_latestgameversion();
  public:
  void unsafe_arena_set_allocated_latestgameversion(
      ::AnnounceMessage_Version* latestgameversion);
  ::AnnounceMessage_Version* unsafe_arena_release_latestgameversion();

  // required uint32 latestBetaRevision = 3;
  bool has_latestbetarevision() const;
  private:
  bool _internal_has_latestbetarevision() const;
  public:
  void clear_latestbetarevision();
  uint32_t latestbetarevision() const;
  void set_latestbetarevision(uint32_t value);
  private:
  uint32_t _internal_latestbetarevision() const;
  void _internal_set_latestbetarevision(uint32_t value);
  public:

  // required .AnnounceMessage.ServerType serverType = 4;
  bool has_servertype() const;
  private:
  bool _internal_has_servertype() const;
  public:
  void clear_servertype();
  ::AnnounceMessage_ServerType servertype() const;
  void set_servertype(::AnnounceMessage_ServerType value);
  private:
  ::AnnounceMessage_ServerType _internal_servertype() const;
  void _internal_set_servertype(::AnnounceMessage_ServerType value);
  public:

  // required uint32 numPlayersOnServer = 5;
  bool has_numplayersonserver() const;
  private:
  bool _internal_has_numplayersonserver() const;
  public:
  void clear_numplayersonserver();
  uint32_t numplayersonserver() const;
  void set_numplayersonserver(uint32_t value);
  private:
  uint32_t _internal_numplayersonserver() const;
  void _internal_set_numplayersonserver(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AnnounceMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::AnnounceMessage_Version* protocolversion_;
  ::AnnounceMessage_Version* latestgameversion_;
  uint32_t latestbetarevision_;
  int servertype_;
  uint32_t numplayersonserver_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:InitMessage) */ {
 public:
  inline InitMessage() : InitMessage(nullptr) {}
  ~InitMessage() override;
  explicit constexpr InitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitMessage(const InitMessage& from);
  InitMessage(InitMessage&& from) noexcept
    : InitMessage() {
    *this = ::std::move(from);
  }

  inline InitMessage& operator=(const InitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitMessage& operator=(InitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitMessage* internal_default_instance() {
    return reinterpret_cast<const InitMessage*>(
               &_InitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InitMessage& a, InitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InitMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InitMessage& from);
  void MergeFrom(const InitMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InitMessage";
  }
  protected:
  explicit InitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InitMessage_LoginType LoginType;
  static constexpr LoginType guestLogin =
    InitMessage_LoginType_guestLogin;
  static constexpr LoginType authenticatedLogin =
    InitMessage_LoginType_authenticatedLogin;
  static constexpr LoginType unauthenticatedLogin =
    InitMessage_LoginType_unauthenticatedLogin;
  static inline bool LoginType_IsValid(int value) {
    return InitMessage_LoginType_IsValid(value);
  }
  static constexpr LoginType LoginType_MIN =
    InitMessage_LoginType_LoginType_MIN;
  static constexpr LoginType LoginType_MAX =
    InitMessage_LoginType_LoginType_MAX;
  static constexpr int LoginType_ARRAYSIZE =
    InitMessage_LoginType_LoginType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LoginType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LoginType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LoginType_Name.");
    return InitMessage_LoginType_Name(enum_t_value);
  }
  static inline bool LoginType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LoginType* value) {
    return InitMessage_LoginType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMyLastSessionIdFieldNumber = 3,
    kAuthServerPasswordFieldNumber = 4,
    kNickNameFieldNumber = 6,
    kClientUserDataFieldNumber = 7,
    kAvatarHashFieldNumber = 8,
    kRequestedVersionFieldNumber = 1,
    kBuildIdFieldNumber = 2,
    kLoginFieldNumber = 5,
  };
  // optional bytes myLastSessionId = 3;
  bool has_mylastsessionid() const;
  private:
  bool _internal_has_mylastsessionid() const;
  public:
  void clear_mylastsessionid();
  const std::string& mylastsessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mylastsessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mylastsessionid();
  PROTOBUF_NODISCARD std::string* release_mylastsessionid();
  void set_allocated_mylastsessionid(std::string* mylastsessionid);
  private:
  const std::string& _internal_mylastsessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mylastsessionid(const std::string& value);
  std::string* _internal_mutable_mylastsessionid();
  public:

  // optional string authServerPassword = 4;
  bool has_authserverpassword() const;
  private:
  bool _internal_has_authserverpassword() const;
  public:
  void clear_authserverpassword();
  const std::string& authserverpassword() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authserverpassword(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authserverpassword();
  PROTOBUF_NODISCARD std::string* release_authserverpassword();
  void set_allocated_authserverpassword(std::string* authserverpassword);
  private:
  const std::string& _internal_authserverpassword() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authserverpassword(const std::string& value);
  std::string* _internal_mutable_authserverpassword();
  public:

  // optional string nickName = 6;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // optional bytes clientUserData = 7;
  bool has_clientuserdata() const;
  private:
  bool _internal_has_clientuserdata() const;
  public:
  void clear_clientuserdata();
  const std::string& clientuserdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientuserdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientuserdata();
  PROTOBUF_NODISCARD std::string* release_clientuserdata();
  void set_allocated_clientuserdata(std::string* clientuserdata);
  private:
  const std::string& _internal_clientuserdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuserdata(const std::string& value);
  std::string* _internal_mutable_clientuserdata();
  public:

  // optional bytes avatarHash = 8;
  bool has_avatarhash() const;
  private:
  bool _internal_has_avatarhash() const;
  public:
  void clear_avatarhash();
  const std::string& avatarhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatarhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatarhash();
  PROTOBUF_NODISCARD std::string* release_avatarhash();
  void set_allocated_avatarhash(std::string* avatarhash);
  private:
  const std::string& _internal_avatarhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatarhash(const std::string& value);
  std::string* _internal_mutable_avatarhash();
  public:

  // required .AnnounceMessage.Version requestedVersion = 1;
  bool has_requestedversion() const;
  private:
  bool _internal_has_requestedversion() const;
  public:
  void clear_requestedversion();
  const ::AnnounceMessage_Version& requestedversion() const;
  PROTOBUF_NODISCARD ::AnnounceMessage_Version* release_requestedversion();
  ::AnnounceMessage_Version* mutable_requestedversion();
  void set_allocated_requestedversion(::AnnounceMessage_Version* requestedversion);
  private:
  const ::AnnounceMessage_Version& _internal_requestedversion() const;
  ::AnnounceMessage_Version* _internal_mutable_requestedversion();
  public:
  void unsafe_arena_set_allocated_requestedversion(
      ::AnnounceMessage_Version* requestedversion);
  ::AnnounceMessage_Version* unsafe_arena_release_requestedversion();

  // required uint32 buildId = 2;
  bool has_buildid() const;
  private:
  bool _internal_has_buildid() const;
  public:
  void clear_buildid();
  uint32_t buildid() const;
  void set_buildid(uint32_t value);
  private:
  uint32_t _internal_buildid() const;
  void _internal_set_buildid(uint32_t value);
  public:

  // required .InitMessage.LoginType login = 5;
  bool has_login() const;
  private:
  bool _internal_has_login() const;
  public:
  void clear_login();
  ::InitMessage_LoginType login() const;
  void set_login(::InitMessage_LoginType value);
  private:
  ::InitMessage_LoginType _internal_login() const;
  void _internal_set_login(::InitMessage_LoginType value);
  public:

  // @@protoc_insertion_point(class_scope:InitMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mylastsessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authserverpassword_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientuserdata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatarhash_;
  ::AnnounceMessage_Version* requestedversion_;
  uint32_t buildid_;
  int login_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AuthServerChallengeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AuthServerChallengeMessage) */ {
 public:
  inline AuthServerChallengeMessage() : AuthServerChallengeMessage(nullptr) {}
  ~AuthServerChallengeMessage() override;
  explicit constexpr AuthServerChallengeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthServerChallengeMessage(const AuthServerChallengeMessage& from);
  AuthServerChallengeMessage(AuthServerChallengeMessage&& from) noexcept
    : AuthServerChallengeMessage() {
    *this = ::std::move(from);
  }

  inline AuthServerChallengeMessage& operator=(const AuthServerChallengeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthServerChallengeMessage& operator=(AuthServerChallengeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthServerChallengeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthServerChallengeMessage* internal_default_instance() {
    return reinterpret_cast<const AuthServerChallengeMessage*>(
               &_AuthServerChallengeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AuthServerChallengeMessage& a, AuthServerChallengeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthServerChallengeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthServerChallengeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthServerChallengeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthServerChallengeMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthServerChallengeMessage& from);
  void MergeFrom(const AuthServerChallengeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthServerChallengeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AuthServerChallengeMessage";
  }
  protected:
  explicit AuthServerChallengeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerChallengeFieldNumber = 1,
  };
  // required bytes serverChallenge = 1;
  bool has_serverchallenge() const;
  private:
  bool _internal_has_serverchallenge() const;
  public:
  void clear_serverchallenge();
  const std::string& serverchallenge() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverchallenge(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverchallenge();
  PROTOBUF_NODISCARD std::string* release_serverchallenge();
  void set_allocated_serverchallenge(std::string* serverchallenge);
  private:
  const std::string& _internal_serverchallenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverchallenge(const std::string& value);
  std::string* _internal_mutable_serverchallenge();
  public:

  // @@protoc_insertion_point(class_scope:AuthServerChallengeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverchallenge_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AuthClientResponseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AuthClientResponseMessage) */ {
 public:
  inline AuthClientResponseMessage() : AuthClientResponseMessage(nullptr) {}
  ~AuthClientResponseMessage() override;
  explicit constexpr AuthClientResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthClientResponseMessage(const AuthClientResponseMessage& from);
  AuthClientResponseMessage(AuthClientResponseMessage&& from) noexcept
    : AuthClientResponseMessage() {
    *this = ::std::move(from);
  }

  inline AuthClientResponseMessage& operator=(const AuthClientResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthClientResponseMessage& operator=(AuthClientResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthClientResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthClientResponseMessage* internal_default_instance() {
    return reinterpret_cast<const AuthClientResponseMessage*>(
               &_AuthClientResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AuthClientResponseMessage& a, AuthClientResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthClientResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthClientResponseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthClientResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthClientResponseMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthClientResponseMessage& from);
  void MergeFrom(const AuthClientResponseMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthClientResponseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AuthClientResponseMessage";
  }
  protected:
  explicit AuthClientResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientResponseFieldNumber = 1,
  };
  // required bytes clientResponse = 1;
  bool has_clientresponse() const;
  private:
  bool _internal_has_clientresponse() const;
  public:
  void clear_clientresponse();
  const std::string& clientresponse() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientresponse(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientresponse();
  PROTOBUF_NODISCARD std::string* release_clientresponse();
  void set_allocated_clientresponse(std::string* clientresponse);
  private:
  const std::string& _internal_clientresponse() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientresponse(const std::string& value);
  std::string* _internal_mutable_clientresponse();
  public:

  // @@protoc_insertion_point(class_scope:AuthClientResponseMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientresponse_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AuthServerVerificationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AuthServerVerificationMessage) */ {
 public:
  inline AuthServerVerificationMessage() : AuthServerVerificationMessage(nullptr) {}
  ~AuthServerVerificationMessage() override;
  explicit constexpr AuthServerVerificationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthServerVerificationMessage(const AuthServerVerificationMessage& from);
  AuthServerVerificationMessage(AuthServerVerificationMessage&& from) noexcept
    : AuthServerVerificationMessage() {
    *this = ::std::move(from);
  }

  inline AuthServerVerificationMessage& operator=(const AuthServerVerificationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthServerVerificationMessage& operator=(AuthServerVerificationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthServerVerificationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthServerVerificationMessage* internal_default_instance() {
    return reinterpret_cast<const AuthServerVerificationMessage*>(
               &_AuthServerVerificationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AuthServerVerificationMessage& a, AuthServerVerificationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthServerVerificationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthServerVerificationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthServerVerificationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthServerVerificationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthServerVerificationMessage& from);
  void MergeFrom(const AuthServerVerificationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthServerVerificationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AuthServerVerificationMessage";
  }
  protected:
  explicit AuthServerVerificationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerVerificationFieldNumber = 1,
  };
  // required bytes serverVerification = 1;
  bool has_serververification() const;
  private:
  bool _internal_has_serververification() const;
  public:
  void clear_serververification();
  const std::string& serververification() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serververification(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serververification();
  PROTOBUF_NODISCARD std::string* release_serververification();
  void set_allocated_serververification(std::string* serververification);
  private:
  const std::string& _internal_serververification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serververification(const std::string& value);
  std::string* _internal_mutable_serververification();
  public:

  // @@protoc_insertion_point(class_scope:AuthServerVerificationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serververification_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InitAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:InitAckMessage) */ {
 public:
  inline InitAckMessage() : InitAckMessage(nullptr) {}
  ~InitAckMessage() override;
  explicit constexpr InitAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitAckMessage(const InitAckMessage& from);
  InitAckMessage(InitAckMessage&& from) noexcept
    : InitAckMessage() {
    *this = ::std::move(from);
  }

  inline InitAckMessage& operator=(const InitAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitAckMessage& operator=(InitAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InitAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitAckMessage* internal_default_instance() {
    return reinterpret_cast<const InitAckMessage*>(
               &_InitAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InitAckMessage& a, InitAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InitAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InitAckMessage& from);
  void MergeFrom(const InitAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InitAckMessage";
  }
  protected:
  explicit InitAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYourSessionIdFieldNumber = 1,
    kYourAvatarHashFieldNumber = 3,
    kYourPlayerIdFieldNumber = 2,
    kRejoinGameIdFieldNumber = 4,
  };
  // required bytes yourSessionId = 1;
  bool has_yoursessionid() const;
  private:
  bool _internal_has_yoursessionid() const;
  public:
  void clear_yoursessionid();
  const std::string& yoursessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_yoursessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_yoursessionid();
  PROTOBUF_NODISCARD std::string* release_yoursessionid();
  void set_allocated_yoursessionid(std::string* yoursessionid);
  private:
  const std::string& _internal_yoursessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_yoursessionid(const std::string& value);
  std::string* _internal_mutable_yoursessionid();
  public:

  // optional bytes yourAvatarHash = 3;
  bool has_youravatarhash() const;
  private:
  bool _internal_has_youravatarhash() const;
  public:
  void clear_youravatarhash();
  const std::string& youravatarhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_youravatarhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_youravatarhash();
  PROTOBUF_NODISCARD std::string* release_youravatarhash();
  void set_allocated_youravatarhash(std::string* youravatarhash);
  private:
  const std::string& _internal_youravatarhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_youravatarhash(const std::string& value);
  std::string* _internal_mutable_youravatarhash();
  public:

  // required uint32 yourPlayerId = 2;
  bool has_yourplayerid() const;
  private:
  bool _internal_has_yourplayerid() const;
  public:
  void clear_yourplayerid();
  uint32_t yourplayerid() const;
  void set_yourplayerid(uint32_t value);
  private:
  uint32_t _internal_yourplayerid() const;
  void _internal_set_yourplayerid(uint32_t value);
  public:

  // optional uint32 rejoinGameId = 4;
  bool has_rejoingameid() const;
  private:
  bool _internal_has_rejoingameid() const;
  public:
  void clear_rejoingameid();
  uint32_t rejoingameid() const;
  void set_rejoingameid(uint32_t value);
  private:
  uint32_t _internal_rejoingameid() const;
  void _internal_set_rejoingameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InitAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr yoursessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr youravatarhash_;
  uint32_t yourplayerid_;
  uint32_t rejoingameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AvatarRequestMessage) */ {
 public:
  inline AvatarRequestMessage() : AvatarRequestMessage(nullptr) {}
  ~AvatarRequestMessage() override;
  explicit constexpr AvatarRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarRequestMessage(const AvatarRequestMessage& from);
  AvatarRequestMessage(AvatarRequestMessage&& from) noexcept
    : AvatarRequestMessage() {
    *this = ::std::move(from);
  }

  inline AvatarRequestMessage& operator=(const AvatarRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarRequestMessage& operator=(AvatarRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvatarRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarRequestMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarRequestMessage*>(
               &_AvatarRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AvatarRequestMessage& a, AvatarRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvatarRequestMessage& from);
  void MergeFrom(const AvatarRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AvatarRequestMessage";
  }
  protected:
  explicit AvatarRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvatarHashFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // required bytes avatarHash = 2;
  bool has_avatarhash() const;
  private:
  bool _internal_has_avatarhash() const;
  public:
  void clear_avatarhash();
  const std::string& avatarhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatarhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatarhash();
  PROTOBUF_NODISCARD std::string* release_avatarhash();
  void set_allocated_avatarhash(std::string* avatarhash);
  private:
  const std::string& _internal_avatarhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatarhash(const std::string& value);
  std::string* _internal_mutable_avatarhash();
  public:

  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AvatarRequestMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatarhash_;
  uint32_t requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarHeaderMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AvatarHeaderMessage) */ {
 public:
  inline AvatarHeaderMessage() : AvatarHeaderMessage(nullptr) {}
  ~AvatarHeaderMessage() override;
  explicit constexpr AvatarHeaderMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarHeaderMessage(const AvatarHeaderMessage& from);
  AvatarHeaderMessage(AvatarHeaderMessage&& from) noexcept
    : AvatarHeaderMessage() {
    *this = ::std::move(from);
  }

  inline AvatarHeaderMessage& operator=(const AvatarHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarHeaderMessage& operator=(AvatarHeaderMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvatarHeaderMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarHeaderMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarHeaderMessage*>(
               &_AvatarHeaderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AvatarHeaderMessage& a, AvatarHeaderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarHeaderMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarHeaderMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarHeaderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarHeaderMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvatarHeaderMessage& from);
  void MergeFrom(const AvatarHeaderMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarHeaderMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AvatarHeaderMessage";
  }
  protected:
  explicit AvatarHeaderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kAvatarSizeFieldNumber = 3,
    kAvatarTypeFieldNumber = 2,
  };
  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // required uint32 avatarSize = 3;
  bool has_avatarsize() const;
  private:
  bool _internal_has_avatarsize() const;
  public:
  void clear_avatarsize();
  uint32_t avatarsize() const;
  void set_avatarsize(uint32_t value);
  private:
  uint32_t _internal_avatarsize() const;
  void _internal_set_avatarsize(uint32_t value);
  public:

  // required .NetAvatarType avatarType = 2;
  bool has_avatartype() const;
  private:
  bool _internal_has_avatartype() const;
  public:
  void clear_avatartype();
  ::NetAvatarType avatartype() const;
  void set_avatartype(::NetAvatarType value);
  private:
  ::NetAvatarType _internal_avatartype() const;
  void _internal_set_avatartype(::NetAvatarType value);
  public:

  // @@protoc_insertion_point(class_scope:AvatarHeaderMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t requestid_;
  uint32_t avatarsize_;
  int avatartype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarDataMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AvatarDataMessage) */ {
 public:
  inline AvatarDataMessage() : AvatarDataMessage(nullptr) {}
  ~AvatarDataMessage() override;
  explicit constexpr AvatarDataMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarDataMessage(const AvatarDataMessage& from);
  AvatarDataMessage(AvatarDataMessage&& from) noexcept
    : AvatarDataMessage() {
    *this = ::std::move(from);
  }

  inline AvatarDataMessage& operator=(const AvatarDataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarDataMessage& operator=(AvatarDataMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvatarDataMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarDataMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarDataMessage*>(
               &_AvatarDataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AvatarDataMessage& a, AvatarDataMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarDataMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarDataMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarDataMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarDataMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvatarDataMessage& from);
  void MergeFrom(const AvatarDataMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarDataMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AvatarDataMessage";
  }
  protected:
  explicit AvatarDataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvatarBlockFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // required bytes avatarBlock = 2;
  bool has_avatarblock() const;
  private:
  bool _internal_has_avatarblock() const;
  public:
  void clear_avatarblock();
  const std::string& avatarblock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatarblock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatarblock();
  PROTOBUF_NODISCARD std::string* release_avatarblock();
  void set_allocated_avatarblock(std::string* avatarblock);
  private:
  const std::string& _internal_avatarblock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatarblock(const std::string& value);
  std::string* _internal_mutable_avatarblock();
  public:

  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AvatarDataMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatarblock_;
  uint32_t requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarEndMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AvatarEndMessage) */ {
 public:
  inline AvatarEndMessage() : AvatarEndMessage(nullptr) {}
  ~AvatarEndMessage() override;
  explicit constexpr AvatarEndMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarEndMessage(const AvatarEndMessage& from);
  AvatarEndMessage(AvatarEndMessage&& from) noexcept
    : AvatarEndMessage() {
    *this = ::std::move(from);
  }

  inline AvatarEndMessage& operator=(const AvatarEndMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarEndMessage& operator=(AvatarEndMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvatarEndMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarEndMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarEndMessage*>(
               &_AvatarEndMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AvatarEndMessage& a, AvatarEndMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarEndMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarEndMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarEndMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarEndMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvatarEndMessage& from);
  void MergeFrom(const AvatarEndMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarEndMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AvatarEndMessage";
  }
  protected:
  explicit AvatarEndMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AvatarEndMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class UnknownAvatarMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:UnknownAvatarMessage) */ {
 public:
  inline UnknownAvatarMessage() : UnknownAvatarMessage(nullptr) {}
  ~UnknownAvatarMessage() override;
  explicit constexpr UnknownAvatarMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnknownAvatarMessage(const UnknownAvatarMessage& from);
  UnknownAvatarMessage(UnknownAvatarMessage&& from) noexcept
    : UnknownAvatarMessage() {
    *this = ::std::move(from);
  }

  inline UnknownAvatarMessage& operator=(const UnknownAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnknownAvatarMessage& operator=(UnknownAvatarMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnknownAvatarMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnknownAvatarMessage* internal_default_instance() {
    return reinterpret_cast<const UnknownAvatarMessage*>(
               &_UnknownAvatarMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnknownAvatarMessage& a, UnknownAvatarMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UnknownAvatarMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnknownAvatarMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnknownAvatarMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnknownAvatarMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnknownAvatarMessage& from);
  void MergeFrom(const UnknownAvatarMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnknownAvatarMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UnknownAvatarMessage";
  }
  protected:
  explicit UnknownAvatarMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UnknownAvatarMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerListMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerListMessage) */ {
 public:
  inline PlayerListMessage() : PlayerListMessage(nullptr) {}
  ~PlayerListMessage() override;
  explicit constexpr PlayerListMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerListMessage(const PlayerListMessage& from);
  PlayerListMessage(PlayerListMessage&& from) noexcept
    : PlayerListMessage() {
    *this = ::std::move(from);
  }

  inline PlayerListMessage& operator=(const PlayerListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerListMessage& operator=(PlayerListMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerListMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerListMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerListMessage*>(
               &_PlayerListMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlayerListMessage& a, PlayerListMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerListMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerListMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerListMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerListMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerListMessage& from);
  void MergeFrom(const PlayerListMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerListMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerListMessage";
  }
  protected:
  explicit PlayerListMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerListMessage_PlayerListNotification PlayerListNotification;
  static constexpr PlayerListNotification playerListNew =
    PlayerListMessage_PlayerListNotification_playerListNew;
  static constexpr PlayerListNotification playerListLeft =
    PlayerListMessage_PlayerListNotification_playerListLeft;
  static inline bool PlayerListNotification_IsValid(int value) {
    return PlayerListMessage_PlayerListNotification_IsValid(value);
  }
  static constexpr PlayerListNotification PlayerListNotification_MIN =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN;
  static constexpr PlayerListNotification PlayerListNotification_MAX =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX;
  static constexpr int PlayerListNotification_ARRAYSIZE =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PlayerListNotification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlayerListNotification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlayerListNotification_Name.");
    return PlayerListMessage_PlayerListNotification_Name(enum_t_value);
  }
  static inline bool PlayerListNotification_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlayerListNotification* value) {
    return PlayerListMessage_PlayerListNotification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPlayerListNotificationFieldNumber = 2,
  };
  // required uint32 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
  bool has_playerlistnotification() const;
  private:
  bool _internal_has_playerlistnotification() const;
  public:
  void clear_playerlistnotification();
  ::PlayerListMessage_PlayerListNotification playerlistnotification() const;
  void set_playerlistnotification(::PlayerListMessage_PlayerListNotification value);
  private:
  ::PlayerListMessage_PlayerListNotification _internal_playerlistnotification() const;
  void _internal_set_playerlistnotification(::PlayerListMessage_PlayerListNotification value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerListMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t playerid_;
  int playerlistnotification_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListNewMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListNewMessage) */ {
 public:
  inline GameListNewMessage() : GameListNewMessage(nullptr) {}
  ~GameListNewMessage() override;
  explicit constexpr GameListNewMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListNewMessage(const GameListNewMessage& from);
  GameListNewMessage(GameListNewMessage&& from) noexcept
    : GameListNewMessage() {
    *this = ::std::move(from);
  }

  inline GameListNewMessage& operator=(const GameListNewMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListNewMessage& operator=(GameListNewMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListNewMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListNewMessage* internal_default_instance() {
    return reinterpret_cast<const GameListNewMessage*>(
               &_GameListNewMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameListNewMessage& a, GameListNewMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListNewMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListNewMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListNewMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListNewMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListNewMessage& from);
  void MergeFrom(const GameListNewMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListNewMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListNewMessage";
  }
  protected:
  explicit GameListNewMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdsFieldNumber = 4,
    kSpectatorIdsFieldNumber = 7,
    kGameInfoFieldNumber = 6,
    kGameIdFieldNumber = 1,
    kIsPrivateFieldNumber = 3,
    kAdminPlayerIdFieldNumber = 5,
    kGameModeFieldNumber = 2,
  };
  // repeated uint32 playerIds = 4 [packed = true];
  int playerids_size() const;
  private:
  int _internal_playerids_size() const;
  public:
  void clear_playerids();
  private:
  uint32_t _internal_playerids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_playerids() const;
  void _internal_add_playerids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_playerids();
  public:
  uint32_t playerids(int index) const;
  void set_playerids(int index, uint32_t value);
  void add_playerids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      playerids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_playerids();

  // repeated uint32 spectatorIds = 7 [packed = true];
  int spectatorids_size() const;
  private:
  int _internal_spectatorids_size() const;
  public:
  void clear_spectatorids();
  private:
  uint32_t _internal_spectatorids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_spectatorids() const;
  void _internal_add_spectatorids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_spectatorids();
  public:
  uint32_t spectatorids(int index) const;
  void set_spectatorids(int index, uint32_t value);
  void add_spectatorids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      spectatorids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_spectatorids();

  // required .NetGameInfo gameInfo = 6;
  bool has_gameinfo() const;
  private:
  bool _internal_has_gameinfo() const;
  public:
  void clear_gameinfo();
  const ::NetGameInfo& gameinfo() const;
  PROTOBUF_NODISCARD ::NetGameInfo* release_gameinfo();
  ::NetGameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::NetGameInfo* gameinfo);
  private:
  const ::NetGameInfo& _internal_gameinfo() const;
  ::NetGameInfo* _internal_mutable_gameinfo();
  public:
  void unsafe_arena_set_allocated_gameinfo(
      ::NetGameInfo* gameinfo);
  ::NetGameInfo* unsafe_arena_release_gameinfo();

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required bool isPrivate = 3;
  bool has_isprivate() const;
  private:
  bool _internal_has_isprivate() const;
  public:
  void clear_isprivate();
  bool isprivate() const;
  void set_isprivate(bool value);
  private:
  bool _internal_isprivate() const;
  void _internal_set_isprivate(bool value);
  public:

  // required uint32 adminPlayerId = 5;
  bool has_adminplayerid() const;
  private:
  bool _internal_has_adminplayerid() const;
  public:
  void clear_adminplayerid();
  uint32_t adminplayerid() const;
  void set_adminplayerid(uint32_t value);
  private:
  uint32_t _internal_adminplayerid() const;
  void _internal_set_adminplayerid(uint32_t value);
  public:

  // required .NetGameMode gameMode = 2;
  bool has_gamemode() const;
  private:
  bool _internal_has_gamemode() const;
  public:
  void clear_gamemode();
  ::NetGameMode gamemode() const;
  void set_gamemode(::NetGameMode value);
  private:
  ::NetGameMode _internal_gamemode() const;
  void _internal_set_gamemode(::NetGameMode value);
  public:

  // @@protoc_insertion_point(class_scope:GameListNewMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > playerids_;
  mutable std::atomic<int> _playerids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > spectatorids_;
  mutable std::atomic<int> _spectatorids_cached_byte_size_;
  ::NetGameInfo* gameinfo_;
  uint32_t gameid_;
  bool isprivate_;
  uint32_t adminplayerid_;
  int gamemode_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListUpdateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListUpdateMessage) */ {
 public:
  inline GameListUpdateMessage() : GameListUpdateMessage(nullptr) {}
  ~GameListUpdateMessage() override;
  explicit constexpr GameListUpdateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListUpdateMessage(const GameListUpdateMessage& from);
  GameListUpdateMessage(GameListUpdateMessage&& from) noexcept
    : GameListUpdateMessage() {
    *this = ::std::move(from);
  }

  inline GameListUpdateMessage& operator=(const GameListUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListUpdateMessage& operator=(GameListUpdateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListUpdateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const GameListUpdateMessage*>(
               &_GameListUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GameListUpdateMessage& a, GameListUpdateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListUpdateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListUpdateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListUpdateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListUpdateMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListUpdateMessage& from);
  void MergeFrom(const GameListUpdateMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListUpdateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListUpdateMessage";
  }
  protected:
  explicit GameListUpdateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kGameModeFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required .NetGameMode gameMode = 2;
  bool has_gamemode() const;
  private:
  bool _internal_has_gamemode() const;
  public:
  void clear_gamemode();
  ::NetGameMode gamemode() const;
  void set_gamemode(::NetGameMode value);
  private:
  ::NetGameMode _internal_gamemode() const;
  void _internal_set_gamemode(::NetGameMode value);
  public:

  // @@protoc_insertion_point(class_scope:GameListUpdateMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  int gamemode_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListPlayerJoinedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListPlayerJoinedMessage) */ {
 public:
  inline GameListPlayerJoinedMessage() : GameListPlayerJoinedMessage(nullptr) {}
  ~GameListPlayerJoinedMessage() override;
  explicit constexpr GameListPlayerJoinedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListPlayerJoinedMessage(const GameListPlayerJoinedMessage& from);
  GameListPlayerJoinedMessage(GameListPlayerJoinedMessage&& from) noexcept
    : GameListPlayerJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GameListPlayerJoinedMessage& operator=(const GameListPlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListPlayerJoinedMessage& operator=(GameListPlayerJoinedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListPlayerJoinedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListPlayerJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GameListPlayerJoinedMessage*>(
               &_GameListPlayerJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GameListPlayerJoinedMessage& a, GameListPlayerJoinedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListPlayerJoinedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListPlayerJoinedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListPlayerJoinedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListPlayerJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListPlayerJoinedMessage& from);
  void MergeFrom(const GameListPlayerJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListPlayerJoinedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListPlayerJoinedMessage";
  }
  protected:
  explicit GameListPlayerJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameListPlayerJoinedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListPlayerLeftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListPlayerLeftMessage) */ {
 public:
  inline GameListPlayerLeftMessage() : GameListPlayerLeftMessage(nullptr) {}
  ~GameListPlayerLeftMessage() override;
  explicit constexpr GameListPlayerLeftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListPlayerLeftMessage(const GameListPlayerLeftMessage& from);
  GameListPlayerLeftMessage(GameListPlayerLeftMessage&& from) noexcept
    : GameListPlayerLeftMessage() {
    *this = ::std::move(from);
  }

  inline GameListPlayerLeftMessage& operator=(const GameListPlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListPlayerLeftMessage& operator=(GameListPlayerLeftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListPlayerLeftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListPlayerLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GameListPlayerLeftMessage*>(
               &_GameListPlayerLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GameListPlayerLeftMessage& a, GameListPlayerLeftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListPlayerLeftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListPlayerLeftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListPlayerLeftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListPlayerLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListPlayerLeftMessage& from);
  void MergeFrom(const GameListPlayerLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListPlayerLeftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListPlayerLeftMessage";
  }
  protected:
  explicit GameListPlayerLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameListPlayerLeftMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListSpectatorJoinedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListSpectatorJoinedMessage) */ {
 public:
  inline GameListSpectatorJoinedMessage() : GameListSpectatorJoinedMessage(nullptr) {}
  ~GameListSpectatorJoinedMessage() override;
  explicit constexpr GameListSpectatorJoinedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListSpectatorJoinedMessage(const GameListSpectatorJoinedMessage& from);
  GameListSpectatorJoinedMessage(GameListSpectatorJoinedMessage&& from) noexcept
    : GameListSpectatorJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GameListSpectatorJoinedMessage& operator=(const GameListSpectatorJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListSpectatorJoinedMessage& operator=(GameListSpectatorJoinedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListSpectatorJoinedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListSpectatorJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GameListSpectatorJoinedMessage*>(
               &_GameListSpectatorJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GameListSpectatorJoinedMessage& a, GameListSpectatorJoinedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListSpectatorJoinedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListSpectatorJoinedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListSpectatorJoinedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListSpectatorJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListSpectatorJoinedMessage& from);
  void MergeFrom(const GameListSpectatorJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListSpectatorJoinedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListSpectatorJoinedMessage";
  }
  protected:
  explicit GameListSpectatorJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameListSpectatorJoinedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListSpectatorLeftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListSpectatorLeftMessage) */ {
 public:
  inline GameListSpectatorLeftMessage() : GameListSpectatorLeftMessage(nullptr) {}
  ~GameListSpectatorLeftMessage() override;
  explicit constexpr GameListSpectatorLeftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListSpectatorLeftMessage(const GameListSpectatorLeftMessage& from);
  GameListSpectatorLeftMessage(GameListSpectatorLeftMessage&& from) noexcept
    : GameListSpectatorLeftMessage() {
    *this = ::std::move(from);
  }

  inline GameListSpectatorLeftMessage& operator=(const GameListSpectatorLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListSpectatorLeftMessage& operator=(GameListSpectatorLeftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListSpectatorLeftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListSpectatorLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GameListSpectatorLeftMessage*>(
               &_GameListSpectatorLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GameListSpectatorLeftMessage& a, GameListSpectatorLeftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListSpectatorLeftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListSpectatorLeftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListSpectatorLeftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListSpectatorLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListSpectatorLeftMessage& from);
  void MergeFrom(const GameListSpectatorLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListSpectatorLeftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListSpectatorLeftMessage";
  }
  protected:
  explicit GameListSpectatorLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameListSpectatorLeftMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListAdminChangedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameListAdminChangedMessage) */ {
 public:
  inline GameListAdminChangedMessage() : GameListAdminChangedMessage(nullptr) {}
  ~GameListAdminChangedMessage() override;
  explicit constexpr GameListAdminChangedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListAdminChangedMessage(const GameListAdminChangedMessage& from);
  GameListAdminChangedMessage(GameListAdminChangedMessage&& from) noexcept
    : GameListAdminChangedMessage() {
    *this = ::std::move(from);
  }

  inline GameListAdminChangedMessage& operator=(const GameListAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListAdminChangedMessage& operator=(GameListAdminChangedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameListAdminChangedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListAdminChangedMessage* internal_default_instance() {
    return reinterpret_cast<const GameListAdminChangedMessage*>(
               &_GameListAdminChangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GameListAdminChangedMessage& a, GameListAdminChangedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListAdminChangedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListAdminChangedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListAdminChangedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListAdminChangedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameListAdminChangedMessage& from);
  void MergeFrom(const GameListAdminChangedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListAdminChangedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListAdminChangedMessage";
  }
  protected:
  explicit GameListAdminChangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kNewAdminPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 newAdminPlayerId = 2;
  bool has_newadminplayerid() const;
  private:
  bool _internal_has_newadminplayerid() const;
  public:
  void clear_newadminplayerid();
  uint32_t newadminplayerid() const;
  void set_newadminplayerid(uint32_t value);
  private:
  uint32_t _internal_newadminplayerid() const;
  void _internal_set_newadminplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameListAdminChangedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t newadminplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoRequestMessage) */ {
 public:
  inline PlayerInfoRequestMessage() : PlayerInfoRequestMessage(nullptr) {}
  ~PlayerInfoRequestMessage() override;
  explicit constexpr PlayerInfoRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfoRequestMessage(const PlayerInfoRequestMessage& from);
  PlayerInfoRequestMessage(PlayerInfoRequestMessage&& from) noexcept
    : PlayerInfoRequestMessage() {
    *this = ::std::move(from);
  }

  inline PlayerInfoRequestMessage& operator=(const PlayerInfoRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoRequestMessage& operator=(PlayerInfoRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerInfoRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoRequestMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoRequestMessage*>(
               &_PlayerInfoRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlayerInfoRequestMessage& a, PlayerInfoRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerInfoRequestMessage& from);
  void MergeFrom(const PlayerInfoRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfoRequestMessage";
  }
  protected:
  explicit PlayerInfoRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // repeated uint32 playerId = 1 [packed = true];
  int playerid_size() const;
  private:
  int _internal_playerid_size() const;
  public:
  void clear_playerid();
  private:
  uint32_t _internal_playerid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_playerid() const;
  void _internal_add_playerid(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_playerid();
  public:
  uint32_t playerid(int index) const;
  void set_playerid(int index, uint32_t value);
  void add_playerid(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      playerid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_playerid();

  // @@protoc_insertion_point(class_scope:PlayerInfoRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > playerid_;
  mutable std::atomic<int> _playerid_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData_AvatarData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoReplyMessage.PlayerInfoData.AvatarData) */ {
 public:
  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData() : PlayerInfoReplyMessage_PlayerInfoData_AvatarData(nullptr) {}
  ~PlayerInfoReplyMessage_PlayerInfoData_AvatarData() override;
  explicit constexpr PlayerInfoReplyMessage_PlayerInfoData_AvatarData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfoReplyMessage_PlayerInfoData_AvatarData(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData(PlayerInfoReplyMessage_PlayerInfoData_AvatarData&& from) noexcept
    : PlayerInfoReplyMessage_PlayerInfoData_AvatarData() {
    *this = ::std::move(from);
  }

  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData& operator=(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData& operator=(PlayerInfoReplyMessage_PlayerInfoData_AvatarData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoReplyMessage_PlayerInfoData_AvatarData* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoReplyMessage_PlayerInfoData_AvatarData*>(
               &_PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData& a, PlayerInfoReplyMessage_PlayerInfoData_AvatarData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoReplyMessage_PlayerInfoData_AvatarData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfoReplyMessage.PlayerInfoData.AvatarData";
  }
  protected:
  explicit PlayerInfoReplyMessage_PlayerInfoData_AvatarData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvatarHashFieldNumber = 2,
    kAvatarTypeFieldNumber = 1,
  };
  // required bytes avatarHash = 2;
  bool has_avatarhash() const;
  private:
  bool _internal_has_avatarhash() const;
  public:
  void clear_avatarhash();
  const std::string& avatarhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatarhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatarhash();
  PROTOBUF_NODISCARD std::string* release_avatarhash();
  void set_allocated_avatarhash(std::string* avatarhash);
  private:
  const std::string& _internal_avatarhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatarhash(const std::string& value);
  std::string* _internal_mutable_avatarhash();
  public:

  // required .NetAvatarType avatarType = 1;
  bool has_avatartype() const;
  private:
  bool _internal_has_avatartype() const;
  public:
  void clear_avatartype();
  ::NetAvatarType avatartype() const;
  void set_avatartype(::NetAvatarType value);
  private:
  ::NetAvatarType _internal_avatartype() const;
  void _internal_set_avatartype(::NetAvatarType value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatarhash_;
  int avatartype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoReplyMessage.PlayerInfoData) */ {
 public:
  inline PlayerInfoReplyMessage_PlayerInfoData() : PlayerInfoReplyMessage_PlayerInfoData(nullptr) {}
  ~PlayerInfoReplyMessage_PlayerInfoData() override;
  explicit constexpr PlayerInfoReplyMessage_PlayerInfoData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfoReplyMessage_PlayerInfoData(const PlayerInfoReplyMessage_PlayerInfoData& from);
  PlayerInfoReplyMessage_PlayerInfoData(PlayerInfoReplyMessage_PlayerInfoData&& from) noexcept
    : PlayerInfoReplyMessage_PlayerInfoData() {
    *this = ::std::move(from);
  }

  inline PlayerInfoReplyMessage_PlayerInfoData& operator=(const PlayerInfoReplyMessage_PlayerInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoReplyMessage_PlayerInfoData& operator=(PlayerInfoReplyMessage_PlayerInfoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerInfoReplyMessage_PlayerInfoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoReplyMessage_PlayerInfoData* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoReplyMessage_PlayerInfoData*>(
               &_PlayerInfoReplyMessage_PlayerInfoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PlayerInfoReplyMessage_PlayerInfoData& a, PlayerInfoReplyMessage_PlayerInfoData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoReplyMessage_PlayerInfoData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoReplyMessage_PlayerInfoData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoReplyMessage_PlayerInfoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage_PlayerInfoData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoReplyMessage_PlayerInfoData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfoReplyMessage.PlayerInfoData";
  }
  protected:
  explicit PlayerInfoReplyMessage_PlayerInfoData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerInfoReplyMessage_PlayerInfoData_AvatarData AvatarData;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
    kCountryCodeFieldNumber = 4,
    kAvatarDataFieldNumber = 5,
    kIsHumanFieldNumber = 2,
    kPlayerRightsFieldNumber = 3,
  };
  // required string playerName = 1;
  bool has_playername() const;
  private:
  bool _internal_has_playername() const;
  public:
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // optional string countryCode = 4;
  bool has_countrycode() const;
  private:
  bool _internal_has_countrycode() const;
  public:
  void clear_countrycode();
  const std::string& countrycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_countrycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_countrycode();
  PROTOBUF_NODISCARD std::string* release_countrycode();
  void set_allocated_countrycode(std::string* countrycode);
  private:
  const std::string& _internal_countrycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_countrycode(const std::string& value);
  std::string* _internal_mutable_countrycode();
  public:

  // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
  bool has_avatardata() const;
  private:
  bool _internal_has_avatardata() const;
  public:
  void clear_avatardata();
  const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& avatardata() const;
  PROTOBUF_NODISCARD ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* release_avatardata();
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* mutable_avatardata();
  void set_allocated_avatardata(::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata);
  private:
  const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& _internal_avatardata() const;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* _internal_mutable_avatardata();
  public:
  void unsafe_arena_set_allocated_avatardata(
      ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata);
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* unsafe_arena_release_avatardata();

  // required bool isHuman = 2;
  bool has_ishuman() const;
  private:
  bool _internal_has_ishuman() const;
  public:
  void clear_ishuman();
  bool ishuman() const;
  void set_ishuman(bool value);
  private:
  bool _internal_ishuman() const;
  void _internal_set_ishuman(bool value);
  public:

  // required .NetPlayerInfoRights playerRights = 3;
  bool has_playerrights() const;
  private:
  bool _internal_has_playerrights() const;
  public:
  void clear_playerrights();
  ::NetPlayerInfoRights playerrights() const;
  void set_playerrights(::NetPlayerInfoRights value);
  private:
  ::NetPlayerInfoRights _internal_playerrights() const;
  void _internal_set_playerrights(::NetPlayerInfoRights value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr countrycode_;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata_;
  bool ishuman_;
  int playerrights_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoReplyMessage) */ {
 public:
  inline PlayerInfoReplyMessage() : PlayerInfoReplyMessage(nullptr) {}
  ~PlayerInfoReplyMessage() override;
  explicit constexpr PlayerInfoReplyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfoReplyMessage(const PlayerInfoReplyMessage& from);
  PlayerInfoReplyMessage(PlayerInfoReplyMessage&& from) noexcept
    : PlayerInfoReplyMessage() {
    *this = ::std::move(from);
  }

  inline PlayerInfoReplyMessage& operator=(const PlayerInfoReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoReplyMessage& operator=(PlayerInfoReplyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerInfoReplyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoReplyMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoReplyMessage*>(
               &_PlayerInfoReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PlayerInfoReplyMessage& a, PlayerInfoReplyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoReplyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoReplyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoReplyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerInfoReplyMessage& from);
  void MergeFrom(const PlayerInfoReplyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoReplyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfoReplyMessage";
  }
  protected:
  explicit PlayerInfoReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerInfoReplyMessage_PlayerInfoData PlayerInfoData;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoDataFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
  bool has_playerinfodata() const;
  private:
  bool _internal_has_playerinfodata() const;
  public:
  void clear_playerinfodata();
  const ::PlayerInfoReplyMessage_PlayerInfoData& playerinfodata() const;
  PROTOBUF_NODISCARD ::PlayerInfoReplyMessage_PlayerInfoData* release_playerinfodata();
  ::PlayerInfoReplyMessage_PlayerInfoData* mutable_playerinfodata();
  void set_allocated_playerinfodata(::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata);
  private:
  const ::PlayerInfoReplyMessage_PlayerInfoData& _internal_playerinfodata() const;
  ::PlayerInfoReplyMessage_PlayerInfoData* _internal_mutable_playerinfodata();
  public:
  void unsafe_arena_set_allocated_playerinfodata(
      ::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata);
  ::PlayerInfoReplyMessage_PlayerInfoData* unsafe_arena_release_playerinfodata();

  // required uint32 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SubscriptionRequestMessage) */ {
 public:
  inline SubscriptionRequestMessage() : SubscriptionRequestMessage(nullptr) {}
  ~SubscriptionRequestMessage() override;
  explicit constexpr SubscriptionRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionRequestMessage(const SubscriptionRequestMessage& from);
  SubscriptionRequestMessage(SubscriptionRequestMessage&& from) noexcept
    : SubscriptionRequestMessage() {
    *this = ::std::move(from);
  }

  inline SubscriptionRequestMessage& operator=(const SubscriptionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionRequestMessage& operator=(SubscriptionRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SubscriptionRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionRequestMessage* internal_default_instance() {
    return reinterpret_cast<const SubscriptionRequestMessage*>(
               &_SubscriptionRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SubscriptionRequestMessage& a, SubscriptionRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SubscriptionRequestMessage& from);
  void MergeFrom(const SubscriptionRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscriptionRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubscriptionRequestMessage";
  }
  protected:
  explicit SubscriptionRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SubscriptionRequestMessage_SubscriptionAction SubscriptionAction;
  static constexpr SubscriptionAction unsubscribeGameList =
    SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
  static constexpr SubscriptionAction resubscribeGameList =
    SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
  static inline bool SubscriptionAction_IsValid(int value) {
    return SubscriptionRequestMessage_SubscriptionAction_IsValid(value);
  }
  static constexpr SubscriptionAction SubscriptionAction_MIN =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN;
  static constexpr SubscriptionAction SubscriptionAction_MAX =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX;
  static constexpr int SubscriptionAction_ARRAYSIZE =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SubscriptionAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubscriptionAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubscriptionAction_Name.");
    return SubscriptionRequestMessage_SubscriptionAction_Name(enum_t_value);
  }
  static inline bool SubscriptionAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubscriptionAction* value) {
    return SubscriptionRequestMessage_SubscriptionAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionActionFieldNumber = 1,
  };
  // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
  bool has_subscriptionaction() const;
  private:
  bool _internal_has_subscriptionaction() const;
  public:
  void clear_subscriptionaction();
  ::SubscriptionRequestMessage_SubscriptionAction subscriptionaction() const;
  void set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value);
  private:
  ::SubscriptionRequestMessage_SubscriptionAction _internal_subscriptionaction() const;
  void _internal_set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value);
  public:

  // @@protoc_insertion_point(class_scope:SubscriptionRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int subscriptionaction_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinExistingGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:JoinExistingGameMessage) */ {
 public:
  inline JoinExistingGameMessage() : JoinExistingGameMessage(nullptr) {}
  ~JoinExistingGameMessage() override;
  explicit constexpr JoinExistingGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinExistingGameMessage(const JoinExistingGameMessage& from);
  JoinExistingGameMessage(JoinExistingGameMessage&& from) noexcept
    : JoinExistingGameMessage() {
    *this = ::std::move(from);
  }

  inline JoinExistingGameMessage& operator=(const JoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinExistingGameMessage& operator=(JoinExistingGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JoinExistingGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinExistingGameMessage* internal_default_instance() {
    return reinterpret_cast<const JoinExistingGameMessage*>(
               &_JoinExistingGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(JoinExistingGameMessage& a, JoinExistingGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinExistingGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinExistingGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinExistingGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinExistingGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JoinExistingGameMessage& from);
  void MergeFrom(const JoinExistingGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinExistingGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JoinExistingGameMessage";
  }
  protected:
  explicit JoinExistingGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kGameIdFieldNumber = 1,
    kAutoLeaveFieldNumber = 3,
    kSpectateOnlyFieldNumber = 4,
  };
  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // optional bool autoLeave = 3 [default = false];
  bool has_autoleave() const;
  private:
  bool _internal_has_autoleave() const;
  public:
  void clear_autoleave();
  bool autoleave() const;
  void set_autoleave(bool value);
  private:
  bool _internal_autoleave() const;
  void _internal_set_autoleave(bool value);
  public:

  // optional bool spectateOnly = 4 [default = false];
  bool has_spectateonly() const;
  private:
  bool _internal_has_spectateonly() const;
  public:
  void clear_spectateonly();
  bool spectateonly() const;
  void set_spectateonly(bool value);
  private:
  bool _internal_spectateonly() const;
  void _internal_set_spectateonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:JoinExistingGameMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  uint32_t gameid_;
  bool autoleave_;
  bool spectateonly_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinNewGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:JoinNewGameMessage) */ {
 public:
  inline JoinNewGameMessage() : JoinNewGameMessage(nullptr) {}
  ~JoinNewGameMessage() override;
  explicit constexpr JoinNewGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinNewGameMessage(const JoinNewGameMessage& from);
  JoinNewGameMessage(JoinNewGameMessage&& from) noexcept
    : JoinNewGameMessage() {
    *this = ::std::move(from);
  }

  inline JoinNewGameMessage& operator=(const JoinNewGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinNewGameMessage& operator=(JoinNewGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JoinNewGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinNewGameMessage* internal_default_instance() {
    return reinterpret_cast<const JoinNewGameMessage*>(
               &_JoinNewGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(JoinNewGameMessage& a, JoinNewGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinNewGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinNewGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinNewGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinNewGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JoinNewGameMessage& from);
  void MergeFrom(const JoinNewGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinNewGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JoinNewGameMessage";
  }
  protected:
  explicit JoinNewGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kGameInfoFieldNumber = 1,
    kAutoLeaveFieldNumber = 3,
  };
  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // required .NetGameInfo gameInfo = 1;
  bool has_gameinfo() const;
  private:
  bool _internal_has_gameinfo() const;
  public:
  void clear_gameinfo();
  const ::NetGameInfo& gameinfo() const;
  PROTOBUF_NODISCARD ::NetGameInfo* release_gameinfo();
  ::NetGameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::NetGameInfo* gameinfo);
  private:
  const ::NetGameInfo& _internal_gameinfo() const;
  ::NetGameInfo* _internal_mutable_gameinfo();
  public:
  void unsafe_arena_set_allocated_gameinfo(
      ::NetGameInfo* gameinfo);
  ::NetGameInfo* unsafe_arena_release_gameinfo();

  // optional bool autoLeave = 3;
  bool has_autoleave() const;
  private:
  bool _internal_has_autoleave() const;
  public:
  void clear_autoleave();
  bool autoleave() const;
  void set_autoleave(bool value);
  private:
  bool _internal_autoleave() const;
  void _internal_set_autoleave(bool value);
  public:

  // @@protoc_insertion_point(class_scope:JoinNewGameMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::NetGameInfo* gameinfo_;
  bool autoleave_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RejoinExistingGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:RejoinExistingGameMessage) */ {
 public:
  inline RejoinExistingGameMessage() : RejoinExistingGameMessage(nullptr) {}
  ~RejoinExistingGameMessage() override;
  explicit constexpr RejoinExistingGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RejoinExistingGameMessage(const RejoinExistingGameMessage& from);
  RejoinExistingGameMessage(RejoinExistingGameMessage&& from) noexcept
    : RejoinExistingGameMessage() {
    *this = ::std::move(from);
  }

  inline RejoinExistingGameMessage& operator=(const RejoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RejoinExistingGameMessage& operator=(RejoinExistingGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RejoinExistingGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RejoinExistingGameMessage* internal_default_instance() {
    return reinterpret_cast<const RejoinExistingGameMessage*>(
               &_RejoinExistingGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RejoinExistingGameMessage& a, RejoinExistingGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RejoinExistingGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RejoinExistingGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RejoinExistingGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RejoinExistingGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RejoinExistingGameMessage& from);
  void MergeFrom(const RejoinExistingGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RejoinExistingGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RejoinExistingGameMessage";
  }
  protected:
  explicit RejoinExistingGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kAutoLeaveFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // optional bool autoLeave = 2;
  bool has_autoleave() const;
  private:
  bool _internal_has_autoleave() const;
  public:
  void clear_autoleave();
  bool autoleave() const;
  void set_autoleave(bool value);
  private:
  bool _internal_autoleave() const;
  void _internal_set_autoleave(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RejoinExistingGameMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  bool autoleave_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinGameAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:JoinGameAckMessage) */ {
 public:
  inline JoinGameAckMessage() : JoinGameAckMessage(nullptr) {}
  ~JoinGameAckMessage() override;
  explicit constexpr JoinGameAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGameAckMessage(const JoinGameAckMessage& from);
  JoinGameAckMessage(JoinGameAckMessage&& from) noexcept
    : JoinGameAckMessage() {
    *this = ::std::move(from);
  }

  inline JoinGameAckMessage& operator=(const JoinGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGameAckMessage& operator=(JoinGameAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JoinGameAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGameAckMessage* internal_default_instance() {
    return reinterpret_cast<const JoinGameAckMessage*>(
               &_JoinGameAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(JoinGameAckMessage& a, JoinGameAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGameAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGameAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGameAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGameAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JoinGameAckMessage& from);
  void MergeFrom(const JoinGameAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinGameAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JoinGameAckMessage";
  }
  protected:
  explicit JoinGameAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameInfoFieldNumber = 3,
    kGameIdFieldNumber = 1,
    kAreYouGameAdminFieldNumber = 2,
    kSpectateOnlyFieldNumber = 4,
  };
  // required .NetGameInfo gameInfo = 3;
  bool has_gameinfo() const;
  private:
  bool _internal_has_gameinfo() const;
  public:
  void clear_gameinfo();
  const ::NetGameInfo& gameinfo() const;
  PROTOBUF_NODISCARD ::NetGameInfo* release_gameinfo();
  ::NetGameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::NetGameInfo* gameinfo);
  private:
  const ::NetGameInfo& _internal_gameinfo() const;
  ::NetGameInfo* _internal_mutable_gameinfo();
  public:
  void unsafe_arena_set_allocated_gameinfo(
      ::NetGameInfo* gameinfo);
  ::NetGameInfo* unsafe_arena_release_gameinfo();

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required bool areYouGameAdmin = 2;
  bool has_areyougameadmin() const;
  private:
  bool _internal_has_areyougameadmin() const;
  public:
  void clear_areyougameadmin();
  bool areyougameadmin() const;
  void set_areyougameadmin(bool value);
  private:
  bool _internal_areyougameadmin() const;
  void _internal_set_areyougameadmin(bool value);
  public:

  // optional bool spectateOnly = 4;
  bool has_spectateonly() const;
  private:
  bool _internal_has_spectateonly() const;
  public:
  void clear_spectateonly();
  bool spectateonly() const;
  void set_spectateonly(bool value);
  private:
  bool _internal_spectateonly() const;
  void _internal_set_spectateonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:JoinGameAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::NetGameInfo* gameinfo_;
  uint32_t gameid_;
  bool areyougameadmin_;
  bool spectateonly_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinGameFailedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:JoinGameFailedMessage) */ {
 public:
  inline JoinGameFailedMessage() : JoinGameFailedMessage(nullptr) {}
  ~JoinGameFailedMessage() override;
  explicit constexpr JoinGameFailedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGameFailedMessage(const JoinGameFailedMessage& from);
  JoinGameFailedMessage(JoinGameFailedMessage&& from) noexcept
    : JoinGameFailedMessage() {
    *this = ::std::move(from);
  }

  inline JoinGameFailedMessage& operator=(const JoinGameFailedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGameFailedMessage& operator=(JoinGameFailedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JoinGameFailedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGameFailedMessage* internal_default_instance() {
    return reinterpret_cast<const JoinGameFailedMessage*>(
               &_JoinGameFailedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(JoinGameFailedMessage& a, JoinGameFailedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGameFailedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGameFailedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGameFailedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGameFailedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JoinGameFailedMessage& from);
  void MergeFrom(const JoinGameFailedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinGameFailedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JoinGameFailedMessage";
  }
  protected:
  explicit JoinGameFailedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef JoinGameFailedMessage_JoinGameFailureReason JoinGameFailureReason;
  static constexpr JoinGameFailureReason invalidGame =
    JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
  static constexpr JoinGameFailureReason gameIsFull =
    JoinGameFailedMessage_JoinGameFailureReason_gameIsFull;
  static constexpr JoinGameFailureReason gameIsRunning =
    JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning;
  static constexpr JoinGameFailureReason invalidPassword =
    JoinGameFailedMessage_JoinGameFailureReason_invalidPassword;
  static constexpr JoinGameFailureReason notAllowedAsGuest =
    JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest;
  static constexpr JoinGameFailureReason notInvited =
    JoinGameFailedMessage_JoinGameFailureReason_notInvited;
  static constexpr JoinGameFailureReason gameNameInUse =
    JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse;
  static constexpr JoinGameFailureReason badGameName =
    JoinGameFailedMessage_JoinGameFailureReason_badGameName;
  static constexpr JoinGameFailureReason invalidSettings =
    JoinGameFailedMessage_JoinGameFailureReason_invalidSettings;
  static constexpr JoinGameFailureReason ipAddressBlocked =
    JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked;
  static constexpr JoinGameFailureReason rejoinFailed =
    JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed;
  static constexpr JoinGameFailureReason noSpectatorsAllowed =
    JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed;
  static inline bool JoinGameFailureReason_IsValid(int value) {
    return JoinGameFailedMessage_JoinGameFailureReason_IsValid(value);
  }
  static constexpr JoinGameFailureReason JoinGameFailureReason_MIN =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN;
  static constexpr JoinGameFailureReason JoinGameFailureReason_MAX =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX;
  static constexpr int JoinGameFailureReason_ARRAYSIZE =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& JoinGameFailureReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, JoinGameFailureReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function JoinGameFailureReason_Name.");
    return JoinGameFailedMessage_JoinGameFailureReason_Name(enum_t_value);
  }
  static inline bool JoinGameFailureReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      JoinGameFailureReason* value) {
    return JoinGameFailedMessage_JoinGameFailureReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kJoinGameFailureReasonFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
  bool has_joingamefailurereason() const;
  private:
  bool _internal_has_joingamefailurereason() const;
  public:
  void clear_joingamefailurereason();
  ::JoinGameFailedMessage_JoinGameFailureReason joingamefailurereason() const;
  void set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value);
  private:
  ::JoinGameFailedMessage_JoinGameFailureReason _internal_joingamefailurereason() const;
  void _internal_set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value);
  public:

  // @@protoc_insertion_point(class_scope:JoinGameFailedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  int joingamefailurereason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GamePlayerJoinedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GamePlayerJoinedMessage) */ {
 public:
  inline GamePlayerJoinedMessage() : GamePlayerJoinedMessage(nullptr) {}
  ~GamePlayerJoinedMessage() override;
  explicit constexpr GamePlayerJoinedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GamePlayerJoinedMessage(const GamePlayerJoinedMessage& from);
  GamePlayerJoinedMessage(GamePlayerJoinedMessage&& from) noexcept
    : GamePlayerJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GamePlayerJoinedMessage& operator=(const GamePlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamePlayerJoinedMessage& operator=(GamePlayerJoinedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GamePlayerJoinedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GamePlayerJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GamePlayerJoinedMessage*>(
               &_GamePlayerJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GamePlayerJoinedMessage& a, GamePlayerJoinedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GamePlayerJoinedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamePlayerJoinedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GamePlayerJoinedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GamePlayerJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GamePlayerJoinedMessage& from);
  void MergeFrom(const GamePlayerJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GamePlayerJoinedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GamePlayerJoinedMessage";
  }
  protected:
  explicit GamePlayerJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kIsGameAdminFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required bool isGameAdmin = 3;
  bool has_isgameadmin() const;
  private:
  bool _internal_has_isgameadmin() const;
  public:
  void clear_isgameadmin();
  bool isgameadmin() const;
  void set_isgameadmin(bool value);
  private:
  bool _internal_isgameadmin() const;
  void _internal_set_isgameadmin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GamePlayerJoinedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  bool isgameadmin_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GamePlayerLeftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GamePlayerLeftMessage) */ {
 public:
  inline GamePlayerLeftMessage() : GamePlayerLeftMessage(nullptr) {}
  ~GamePlayerLeftMessage() override;
  explicit constexpr GamePlayerLeftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GamePlayerLeftMessage(const GamePlayerLeftMessage& from);
  GamePlayerLeftMessage(GamePlayerLeftMessage&& from) noexcept
    : GamePlayerLeftMessage() {
    *this = ::std::move(from);
  }

  inline GamePlayerLeftMessage& operator=(const GamePlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamePlayerLeftMessage& operator=(GamePlayerLeftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GamePlayerLeftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GamePlayerLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GamePlayerLeftMessage*>(
               &_GamePlayerLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GamePlayerLeftMessage& a, GamePlayerLeftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GamePlayerLeftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamePlayerLeftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GamePlayerLeftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GamePlayerLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GamePlayerLeftMessage& from);
  void MergeFrom(const GamePlayerLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GamePlayerLeftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GamePlayerLeftMessage";
  }
  protected:
  explicit GamePlayerLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftReason;
  static constexpr GamePlayerLeftReason leftOnRequest =
    GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
  static constexpr GamePlayerLeftReason leftKicked =
    GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked;
  static constexpr GamePlayerLeftReason leftError =
    GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
  static inline bool GamePlayerLeftReason_IsValid(int value) {
    return GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value);
  }
  static constexpr GamePlayerLeftReason GamePlayerLeftReason_MIN =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN;
  static constexpr GamePlayerLeftReason GamePlayerLeftReason_MAX =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX;
  static constexpr int GamePlayerLeftReason_ARRAYSIZE =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& GamePlayerLeftReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GamePlayerLeftReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GamePlayerLeftReason_Name.");
    return GamePlayerLeftMessage_GamePlayerLeftReason_Name(enum_t_value);
  }
  static inline bool GamePlayerLeftReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GamePlayerLeftReason* value) {
    return GamePlayerLeftMessage_GamePlayerLeftReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kGamePlayerLeftReasonFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
  bool has_gameplayerleftreason() const;
  private:
  bool _internal_has_gameplayerleftreason() const;
  public:
  void clear_gameplayerleftreason();
  ::GamePlayerLeftMessage_GamePlayerLeftReason gameplayerleftreason() const;
  void set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);
  private:
  ::GamePlayerLeftMessage_GamePlayerLeftReason _internal_gameplayerleftreason() const;
  void _internal_set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);
  public:

  // @@protoc_insertion_point(class_scope:GamePlayerLeftMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  int gameplayerleftreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameSpectatorJoinedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameSpectatorJoinedMessage) */ {
 public:
  inline GameSpectatorJoinedMessage() : GameSpectatorJoinedMessage(nullptr) {}
  ~GameSpectatorJoinedMessage() override;
  explicit constexpr GameSpectatorJoinedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSpectatorJoinedMessage(const GameSpectatorJoinedMessage& from);
  GameSpectatorJoinedMessage(GameSpectatorJoinedMessage&& from) noexcept
    : GameSpectatorJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GameSpectatorJoinedMessage& operator=(const GameSpectatorJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSpectatorJoinedMessage& operator=(GameSpectatorJoinedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameSpectatorJoinedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSpectatorJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GameSpectatorJoinedMessage*>(
               &_GameSpectatorJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GameSpectatorJoinedMessage& a, GameSpectatorJoinedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSpectatorJoinedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSpectatorJoinedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSpectatorJoinedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSpectatorJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameSpectatorJoinedMessage& from);
  void MergeFrom(const GameSpectatorJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSpectatorJoinedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameSpectatorJoinedMessage";
  }
  protected:
  explicit GameSpectatorJoinedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameSpectatorJoinedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameSpectatorLeftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameSpectatorLeftMessage) */ {
 public:
  inline GameSpectatorLeftMessage() : GameSpectatorLeftMessage(nullptr) {}
  ~GameSpectatorLeftMessage() override;
  explicit constexpr GameSpectatorLeftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSpectatorLeftMessage(const GameSpectatorLeftMessage& from);
  GameSpectatorLeftMessage(GameSpectatorLeftMessage&& from) noexcept
    : GameSpectatorLeftMessage() {
    *this = ::std::move(from);
  }

  inline GameSpectatorLeftMessage& operator=(const GameSpectatorLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSpectatorLeftMessage& operator=(GameSpectatorLeftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameSpectatorLeftMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSpectatorLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GameSpectatorLeftMessage*>(
               &_GameSpectatorLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GameSpectatorLeftMessage& a, GameSpectatorLeftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSpectatorLeftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSpectatorLeftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSpectatorLeftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSpectatorLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameSpectatorLeftMessage& from);
  void MergeFrom(const GameSpectatorLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSpectatorLeftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameSpectatorLeftMessage";
  }
  protected:
  explicit GameSpectatorLeftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kGameSpectatorLeftReasonFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
  bool has_gamespectatorleftreason() const;
  private:
  bool _internal_has_gamespectatorleftreason() const;
  public:
  void clear_gamespectatorleftreason();
  ::GamePlayerLeftMessage_GamePlayerLeftReason gamespectatorleftreason() const;
  void set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);
  private:
  ::GamePlayerLeftMessage_GamePlayerLeftReason _internal_gamespectatorleftreason() const;
  void _internal_set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);
  public:

  // @@protoc_insertion_point(class_scope:GameSpectatorLeftMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  int gamespectatorleftreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameAdminChangedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameAdminChangedMessage) */ {
 public:
  inline GameAdminChangedMessage() : GameAdminChangedMessage(nullptr) {}
  ~GameAdminChangedMessage() override;
  explicit constexpr GameAdminChangedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameAdminChangedMessage(const GameAdminChangedMessage& from);
  GameAdminChangedMessage(GameAdminChangedMessage&& from) noexcept
    : GameAdminChangedMessage() {
    *this = ::std::move(from);
  }

  inline GameAdminChangedMessage& operator=(const GameAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameAdminChangedMessage& operator=(GameAdminChangedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameAdminChangedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameAdminChangedMessage* internal_default_instance() {
    return reinterpret_cast<const GameAdminChangedMessage*>(
               &_GameAdminChangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GameAdminChangedMessage& a, GameAdminChangedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameAdminChangedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameAdminChangedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameAdminChangedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameAdminChangedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameAdminChangedMessage& from);
  void MergeFrom(const GameAdminChangedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameAdminChangedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameAdminChangedMessage";
  }
  protected:
  explicit GameAdminChangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kNewAdminPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 newAdminPlayerId = 2;
  bool has_newadminplayerid() const;
  private:
  bool _internal_has_newadminplayerid() const;
  public:
  void clear_newadminplayerid();
  uint32_t newadminplayerid() const;
  void set_newadminplayerid(uint32_t value);
  private:
  uint32_t _internal_newadminplayerid() const;
  void _internal_set_newadminplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameAdminChangedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t newadminplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RemovedFromGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:RemovedFromGameMessage) */ {
 public:
  inline RemovedFromGameMessage() : RemovedFromGameMessage(nullptr) {}
  ~RemovedFromGameMessage() override;
  explicit constexpr RemovedFromGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemovedFromGameMessage(const RemovedFromGameMessage& from);
  RemovedFromGameMessage(RemovedFromGameMessage&& from) noexcept
    : RemovedFromGameMessage() {
    *this = ::std::move(from);
  }

  inline RemovedFromGameMessage& operator=(const RemovedFromGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemovedFromGameMessage& operator=(RemovedFromGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemovedFromGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemovedFromGameMessage* internal_default_instance() {
    return reinterpret_cast<const RemovedFromGameMessage*>(
               &_RemovedFromGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(RemovedFromGameMessage& a, RemovedFromGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RemovedFromGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemovedFromGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemovedFromGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemovedFromGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemovedFromGameMessage& from);
  void MergeFrom(const RemovedFromGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemovedFromGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemovedFromGameMessage";
  }
  protected:
  explicit RemovedFromGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameReason;
  static constexpr RemovedFromGameReason removedOnRequest =
    RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
  static constexpr RemovedFromGameReason kickedFromGame =
    RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame;
  static constexpr RemovedFromGameReason gameIsFull =
    RemovedFromGameMessage_RemovedFromGameReason_gameIsFull;
  static constexpr RemovedFromGameReason gameIsRunning =
    RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning;
  static constexpr RemovedFromGameReason gameTimeout =
    RemovedFromGameMessage_RemovedFromGameReason_gameTimeout;
  static constexpr RemovedFromGameReason removedStartFailed =
    RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed;
  static constexpr RemovedFromGameReason gameClosed =
    RemovedFromGameMessage_RemovedFromGameReason_gameClosed;
  static inline bool RemovedFromGameReason_IsValid(int value) {
    return RemovedFromGameMessage_RemovedFromGameReason_IsValid(value);
  }
  static constexpr RemovedFromGameReason RemovedFromGameReason_MIN =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN;
  static constexpr RemovedFromGameReason RemovedFromGameReason_MAX =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX;
  static constexpr int RemovedFromGameReason_ARRAYSIZE =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RemovedFromGameReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RemovedFromGameReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RemovedFromGameReason_Name.");
    return RemovedFromGameMessage_RemovedFromGameReason_Name(enum_t_value);
  }
  static inline bool RemovedFromGameReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RemovedFromGameReason* value) {
    return RemovedFromGameMessage_RemovedFromGameReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kRemovedFromGameReasonFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
  bool has_removedfromgamereason() const;
  private:
  bool _internal_has_removedfromgamereason() const;
  public:
  void clear_removedfromgamereason();
  ::RemovedFromGameMessage_RemovedFromGameReason removedfromgamereason() const;
  void set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value);
  private:
  ::RemovedFromGameMessage_RemovedFromGameReason _internal_removedfromgamereason() const;
  void _internal_set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value);
  public:

  // @@protoc_insertion_point(class_scope:RemovedFromGameMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  int removedfromgamereason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class KickPlayerRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:KickPlayerRequestMessage) */ {
 public:
  inline KickPlayerRequestMessage() : KickPlayerRequestMessage(nullptr) {}
  ~KickPlayerRequestMessage() override;
  explicit constexpr KickPlayerRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPlayerRequestMessage(const KickPlayerRequestMessage& from);
  KickPlayerRequestMessage(KickPlayerRequestMessage&& from) noexcept
    : KickPlayerRequestMessage() {
    *this = ::std::move(from);
  }

  inline KickPlayerRequestMessage& operator=(const KickPlayerRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPlayerRequestMessage& operator=(KickPlayerRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KickPlayerRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPlayerRequestMessage* internal_default_instance() {
    return reinterpret_cast<const KickPlayerRequestMessage*>(
               &_KickPlayerRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(KickPlayerRequestMessage& a, KickPlayerRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPlayerRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPlayerRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPlayerRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPlayerRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KickPlayerRequestMessage& from);
  void MergeFrom(const KickPlayerRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickPlayerRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KickPlayerRequestMessage";
  }
  protected:
  explicit KickPlayerRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KickPlayerRequestMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class LeaveGameRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:LeaveGameRequestMessage) */ {
 public:
  inline LeaveGameRequestMessage() : LeaveGameRequestMessage(nullptr) {}
  ~LeaveGameRequestMessage() override;
  explicit constexpr LeaveGameRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveGameRequestMessage(const LeaveGameRequestMessage& from);
  LeaveGameRequestMessage(LeaveGameRequestMessage&& from) noexcept
    : LeaveGameRequestMessage() {
    *this = ::std::move(from);
  }

  inline LeaveGameRequestMessage& operator=(const LeaveGameRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveGameRequestMessage& operator=(LeaveGameRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LeaveGameRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveGameRequestMessage* internal_default_instance() {
    return reinterpret_cast<const LeaveGameRequestMessage*>(
               &_LeaveGameRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(LeaveGameRequestMessage& a, LeaveGameRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveGameRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveGameRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveGameRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveGameRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LeaveGameRequestMessage& from);
  void MergeFrom(const LeaveGameRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaveGameRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LeaveGameRequestMessage";
  }
  protected:
  explicit LeaveGameRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LeaveGameRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InvitePlayerToGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:InvitePlayerToGameMessage) */ {
 public:
  inline InvitePlayerToGameMessage() : InvitePlayerToGameMessage(nullptr) {}
  ~InvitePlayerToGameMessage() override;
  explicit constexpr InvitePlayerToGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvitePlayerToGameMessage(const InvitePlayerToGameMessage& from);
  InvitePlayerToGameMessage(InvitePlayerToGameMessage&& from) noexcept
    : InvitePlayerToGameMessage() {
    *this = ::std::move(from);
  }

  inline InvitePlayerToGameMessage& operator=(const InvitePlayerToGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvitePlayerToGameMessage& operator=(InvitePlayerToGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InvitePlayerToGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvitePlayerToGameMessage* internal_default_instance() {
    return reinterpret_cast<const InvitePlayerToGameMessage*>(
               &_InvitePlayerToGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(InvitePlayerToGameMessage& a, InvitePlayerToGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InvitePlayerToGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvitePlayerToGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvitePlayerToGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvitePlayerToGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InvitePlayerToGameMessage& from);
  void MergeFrom(const InvitePlayerToGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvitePlayerToGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InvitePlayerToGameMessage";
  }
  protected:
  explicit InvitePlayerToGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InvitePlayerToGameMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InviteNotifyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:InviteNotifyMessage) */ {
 public:
  inline InviteNotifyMessage() : InviteNotifyMessage(nullptr) {}
  ~InviteNotifyMessage() override;
  explicit constexpr InviteNotifyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InviteNotifyMessage(const InviteNotifyMessage& from);
  InviteNotifyMessage(InviteNotifyMessage&& from) noexcept
    : InviteNotifyMessage() {
    *this = ::std::move(from);
  }

  inline InviteNotifyMessage& operator=(const InviteNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InviteNotifyMessage& operator=(InviteNotifyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InviteNotifyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InviteNotifyMessage* internal_default_instance() {
    return reinterpret_cast<const InviteNotifyMessage*>(
               &_InviteNotifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(InviteNotifyMessage& a, InviteNotifyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InviteNotifyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InviteNotifyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InviteNotifyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InviteNotifyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InviteNotifyMessage& from);
  void MergeFrom(const InviteNotifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InviteNotifyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InviteNotifyMessage";
  }
  protected:
  explicit InviteNotifyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdWhoFieldNumber = 2,
    kPlayerIdByWhomFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerIdWho = 2;
  bool has_playeridwho() const;
  private:
  bool _internal_has_playeridwho() const;
  public:
  void clear_playeridwho();
  uint32_t playeridwho() const;
  void set_playeridwho(uint32_t value);
  private:
  uint32_t _internal_playeridwho() const;
  void _internal_set_playeridwho(uint32_t value);
  public:

  // required uint32 playerIdByWhom = 3;
  bool has_playeridbywhom() const;
  private:
  bool _internal_has_playeridbywhom() const;
  public:
  void clear_playeridbywhom();
  uint32_t playeridbywhom() const;
  void set_playeridbywhom(uint32_t value);
  private:
  uint32_t _internal_playeridbywhom() const;
  void _internal_set_playeridbywhom(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InviteNotifyMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playeridwho_;
  uint32_t playeridbywhom_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RejectGameInvitationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:RejectGameInvitationMessage) */ {
 public:
  inline RejectGameInvitationMessage() : RejectGameInvitationMessage(nullptr) {}
  ~RejectGameInvitationMessage() override;
  explicit constexpr RejectGameInvitationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RejectGameInvitationMessage(const RejectGameInvitationMessage& from);
  RejectGameInvitationMessage(RejectGameInvitationMessage&& from) noexcept
    : RejectGameInvitationMessage() {
    *this = ::std::move(from);
  }

  inline RejectGameInvitationMessage& operator=(const RejectGameInvitationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RejectGameInvitationMessage& operator=(RejectGameInvitationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RejectGameInvitationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RejectGameInvitationMessage* internal_default_instance() {
    return reinterpret_cast<const RejectGameInvitationMessage*>(
               &_RejectGameInvitationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(RejectGameInvitationMessage& a, RejectGameInvitationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RejectGameInvitationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RejectGameInvitationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RejectGameInvitationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RejectGameInvitationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RejectGameInvitationMessage& from);
  void MergeFrom(const RejectGameInvitationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RejectGameInvitationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RejectGameInvitationMessage";
  }
  protected:
  explicit RejectGameInvitationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RejectGameInvitationMessage_RejectGameInvReason RejectGameInvReason;
  static constexpr RejectGameInvReason rejectReasonNo =
    RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
  static constexpr RejectGameInvReason rejectReasonBusy =
    RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
  static inline bool RejectGameInvReason_IsValid(int value) {
    return RejectGameInvitationMessage_RejectGameInvReason_IsValid(value);
  }
  static constexpr RejectGameInvReason RejectGameInvReason_MIN =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN;
  static constexpr RejectGameInvReason RejectGameInvReason_MAX =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX;
  static constexpr int RejectGameInvReason_ARRAYSIZE =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RejectGameInvReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RejectGameInvReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RejectGameInvReason_Name.");
    return RejectGameInvitationMessage_RejectGameInvReason_Name(enum_t_value);
  }
  static inline bool RejectGameInvReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RejectGameInvReason* value) {
    return RejectGameInvitationMessage_RejectGameInvReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kMyRejectReasonFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
  bool has_myrejectreason() const;
  private:
  bool _internal_has_myrejectreason() const;
  public:
  void clear_myrejectreason();
  ::RejectGameInvitationMessage_RejectGameInvReason myrejectreason() const;
  void set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);
  private:
  ::RejectGameInvitationMessage_RejectGameInvReason _internal_myrejectreason() const;
  void _internal_set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);
  public:

  // @@protoc_insertion_point(class_scope:RejectGameInvitationMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  int myrejectreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RejectInvNotifyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:RejectInvNotifyMessage) */ {
 public:
  inline RejectInvNotifyMessage() : RejectInvNotifyMessage(nullptr) {}
  ~RejectInvNotifyMessage() override;
  explicit constexpr RejectInvNotifyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RejectInvNotifyMessage(const RejectInvNotifyMessage& from);
  RejectInvNotifyMessage(RejectInvNotifyMessage&& from) noexcept
    : RejectInvNotifyMessage() {
    *this = ::std::move(from);
  }

  inline RejectInvNotifyMessage& operator=(const RejectInvNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RejectInvNotifyMessage& operator=(RejectInvNotifyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RejectInvNotifyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RejectInvNotifyMessage* internal_default_instance() {
    return reinterpret_cast<const RejectInvNotifyMessage*>(
               &_RejectInvNotifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(RejectInvNotifyMessage& a, RejectInvNotifyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RejectInvNotifyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RejectInvNotifyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RejectInvNotifyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RejectInvNotifyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RejectInvNotifyMessage& from);
  void MergeFrom(const RejectInvNotifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RejectInvNotifyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RejectInvNotifyMessage";
  }
  protected:
  explicit RejectInvNotifyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kPlayerRejectReasonFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
  bool has_playerrejectreason() const;
  private:
  bool _internal_has_playerrejectreason() const;
  public:
  void clear_playerrejectreason();
  ::RejectGameInvitationMessage_RejectGameInvReason playerrejectreason() const;
  void set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);
  private:
  ::RejectGameInvitationMessage_RejectGameInvReason _internal_playerrejectreason() const;
  void _internal_set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);
  public:

  // @@protoc_insertion_point(class_scope:RejectInvNotifyMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  int playerrejectreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StartEventMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:StartEventMessage) */ {
 public:
  inline StartEventMessage() : StartEventMessage(nullptr) {}
  ~StartEventMessage() override;
  explicit constexpr StartEventMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartEventMessage(const StartEventMessage& from);
  StartEventMessage(StartEventMessage&& from) noexcept
    : StartEventMessage() {
    *this = ::std::move(from);
  }

  inline StartEventMessage& operator=(const StartEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartEventMessage& operator=(StartEventMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StartEventMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartEventMessage* internal_default_instance() {
    return reinterpret_cast<const StartEventMessage*>(
               &_StartEventMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(StartEventMessage& a, StartEventMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartEventMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartEventMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartEventMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartEventMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StartEventMessage& from);
  void MergeFrom(const StartEventMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartEventMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartEventMessage";
  }
  protected:
  explicit StartEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartEventMessage_StartEventType StartEventType;
  static constexpr StartEventType startEvent =
    StartEventMessage_StartEventType_startEvent;
  static constexpr StartEventType rejoinEvent =
    StartEventMessage_StartEventType_rejoinEvent;
  static inline bool StartEventType_IsValid(int value) {
    return StartEventMessage_StartEventType_IsValid(value);
  }
  static constexpr StartEventType StartEventType_MIN =
    StartEventMessage_StartEventType_StartEventType_MIN;
  static constexpr StartEventType StartEventType_MAX =
    StartEventMessage_StartEventType_StartEventType_MAX;
  static constexpr int StartEventType_ARRAYSIZE =
    StartEventMessage_StartEventType_StartEventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StartEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StartEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StartEventType_Name.");
    return StartEventMessage_StartEventType_Name(enum_t_value);
  }
  static inline bool StartEventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StartEventType* value) {
    return StartEventMessage_StartEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kStartEventTypeFieldNumber = 2,
    kFillWithComputerPlayersFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required .StartEventMessage.StartEventType startEventType = 2;
  bool has_starteventtype() const;
  private:
  bool _internal_has_starteventtype() const;
  public:
  void clear_starteventtype();
  ::StartEventMessage_StartEventType starteventtype() const;
  void set_starteventtype(::StartEventMessage_StartEventType value);
  private:
  ::StartEventMessage_StartEventType _internal_starteventtype() const;
  void _internal_set_starteventtype(::StartEventMessage_StartEventType value);
  public:

  // optional bool fillWithComputerPlayers = 3;
  bool has_fillwithcomputerplayers() const;
  private:
  bool _internal_has_fillwithcomputerplayers() const;
  public:
  void clear_fillwithcomputerplayers();
  bool fillwithcomputerplayers() const;
  void set_fillwithcomputerplayers(bool value);
  private:
  bool _internal_fillwithcomputerplayers() const;
  void _internal_set_fillwithcomputerplayers(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StartEventMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  int starteventtype_;
  bool fillwithcomputerplayers_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StartEventAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:StartEventAckMessage) */ {
 public:
  inline StartEventAckMessage() : StartEventAckMessage(nullptr) {}
  ~StartEventAckMessage() override;
  explicit constexpr StartEventAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartEventAckMessage(const StartEventAckMessage& from);
  StartEventAckMessage(StartEventAckMessage&& from) noexcept
    : StartEventAckMessage() {
    *this = ::std::move(from);
  }

  inline StartEventAckMessage& operator=(const StartEventAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartEventAckMessage& operator=(StartEventAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StartEventAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartEventAckMessage* internal_default_instance() {
    return reinterpret_cast<const StartEventAckMessage*>(
               &_StartEventAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(StartEventAckMessage& a, StartEventAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartEventAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartEventAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartEventAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartEventAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StartEventAckMessage& from);
  void MergeFrom(const StartEventAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartEventAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartEventAckMessage";
  }
  protected:
  explicit StartEventAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StartEventAckMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameStartInitialMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameStartInitialMessage) */ {
 public:
  inline GameStartInitialMessage() : GameStartInitialMessage(nullptr) {}
  ~GameStartInitialMessage() override;
  explicit constexpr GameStartInitialMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStartInitialMessage(const GameStartInitialMessage& from);
  GameStartInitialMessage(GameStartInitialMessage&& from) noexcept
    : GameStartInitialMessage() {
    *this = ::std::move(from);
  }

  inline GameStartInitialMessage& operator=(const GameStartInitialMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStartInitialMessage& operator=(GameStartInitialMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameStartInitialMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStartInitialMessage* internal_default_instance() {
    return reinterpret_cast<const GameStartInitialMessage*>(
               &_GameStartInitialMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(GameStartInitialMessage& a, GameStartInitialMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStartInitialMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStartInitialMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStartInitialMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStartInitialMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameStartInitialMessage& from);
  void MergeFrom(const GameStartInitialMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameStartInitialMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameStartInitialMessage";
  }
  protected:
  explicit GameStartInitialMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerSeatsFieldNumber = 3,
    kGameIdFieldNumber = 1,
    kStartDealerPlayerIdFieldNumber = 2,
  };
  // repeated uint32 playerSeats = 3 [packed = true];
  int playerseats_size() const;
  private:
  int _internal_playerseats_size() const;
  public:
  void clear_playerseats();
  private:
  uint32_t _internal_playerseats(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_playerseats() const;
  void _internal_add_playerseats(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_playerseats();
  public:
  uint32_t playerseats(int index) const;
  void set_playerseats(int index, uint32_t value);
  void add_playerseats(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      playerseats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_playerseats();

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 startDealerPlayerId = 2;
  bool has_startdealerplayerid() const;
  private:
  bool _internal_has_startdealerplayerid() const;
  public:
  void clear_startdealerplayerid();
  uint32_t startdealerplayerid() const;
  void set_startdealerplayerid(uint32_t value);
  private:
  uint32_t _internal_startdealerplayerid() const;
  void _internal_set_startdealerplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameStartInitialMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > playerseats_;
  mutable std::atomic<int> _playerseats_cached_byte_size_;
  uint32_t gameid_;
  uint32_t startdealerplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage_RejoinPlayerData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameStartRejoinMessage.RejoinPlayerData) */ {
 public:
  inline GameStartRejoinMessage_RejoinPlayerData() : GameStartRejoinMessage_RejoinPlayerData(nullptr) {}
  ~GameStartRejoinMessage_RejoinPlayerData() override;
  explicit constexpr GameStartRejoinMessage_RejoinPlayerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStartRejoinMessage_RejoinPlayerData(const GameStartRejoinMessage_RejoinPlayerData& from);
  GameStartRejoinMessage_RejoinPlayerData(GameStartRejoinMessage_RejoinPlayerData&& from) noexcept
    : GameStartRejoinMessage_RejoinPlayerData() {
    *this = ::std::move(from);
  }

  inline GameStartRejoinMessage_RejoinPlayerData& operator=(const GameStartRejoinMessage_RejoinPlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStartRejoinMessage_RejoinPlayerData& operator=(GameStartRejoinMessage_RejoinPlayerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameStartRejoinMessage_RejoinPlayerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStartRejoinMessage_RejoinPlayerData* internal_default_instance() {
    return reinterpret_cast<const GameStartRejoinMessage_RejoinPlayerData*>(
               &_GameStartRejoinMessage_RejoinPlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(GameStartRejoinMessage_RejoinPlayerData& a, GameStartRejoinMessage_RejoinPlayerData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStartRejoinMessage_RejoinPlayerData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStartRejoinMessage_RejoinPlayerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStartRejoinMessage_RejoinPlayerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStartRejoinMessage_RejoinPlayerData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  void MergeFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameStartRejoinMessage_RejoinPlayerData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameStartRejoinMessage.RejoinPlayerData";
  }
  protected:
  explicit GameStartRejoinMessage_RejoinPlayerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPlayerMoneyFieldNumber = 2,
  };
  // required uint32 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required uint32 playerMoney = 2;
  bool has_playermoney() const;
  private:
  bool _internal_has_playermoney() const;
  public:
  void clear_playermoney();
  uint32_t playermoney() const;
  void set_playermoney(uint32_t value);
  private:
  uint32_t _internal_playermoney() const;
  void _internal_set_playermoney(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage.RejoinPlayerData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t playerid_;
  uint32_t playermoney_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GameStartRejoinMessage) */ {
 public:
  inline GameStartRejoinMessage() : GameStartRejoinMessage(nullptr) {}
  ~GameStartRejoinMessage() override;
  explicit constexpr GameStartRejoinMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStartRejoinMessage(const GameStartRejoinMessage& from);
  GameStartRejoinMessage(GameStartRejoinMessage&& from) noexcept
    : GameStartRejoinMessage() {
    *this = ::std::move(from);
  }

  inline GameStartRejoinMessage& operator=(const GameStartRejoinMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStartRejoinMessage& operator=(GameStartRejoinMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GameStartRejoinMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStartRejoinMessage* internal_default_instance() {
    return reinterpret_cast<const GameStartRejoinMessage*>(
               &_GameStartRejoinMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GameStartRejoinMessage& a, GameStartRejoinMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStartRejoinMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStartRejoinMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStartRejoinMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStartRejoinMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GameStartRejoinMessage& from);
  void MergeFrom(const GameStartRejoinMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameStartRejoinMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameStartRejoinMessage";
  }
  protected:
  explicit GameStartRejoinMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GameStartRejoinMessage_RejoinPlayerData RejoinPlayerData;

  // accessors -------------------------------------------------------

  enum : int {
    kRejoinPlayerDataFieldNumber = 4,
    kGameIdFieldNumber = 1,
    kStartDealerPlayerIdFieldNumber = 2,
    kHandNumFieldNumber = 3,
  };
  // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
  int rejoinplayerdata_size() const;
  private:
  int _internal_rejoinplayerdata_size() const;
  public:
  void clear_rejoinplayerdata();
  ::GameStartRejoinMessage_RejoinPlayerData* mutable_rejoinplayerdata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
      mutable_rejoinplayerdata();
  private:
  const ::GameStartRejoinMessage_RejoinPlayerData& _internal_rejoinplayerdata(int index) const;
  ::GameStartRejoinMessage_RejoinPlayerData* _internal_add_rejoinplayerdata();
  public:
  const ::GameStartRejoinMessage_RejoinPlayerData& rejoinplayerdata(int index) const;
  ::GameStartRejoinMessage_RejoinPlayerData* add_rejoinplayerdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
      rejoinplayerdata() const;

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 startDealerPlayerId = 2;
  bool has_startdealerplayerid() const;
  private:
  bool _internal_has_startdealerplayerid() const;
  public:
  void clear_startdealerplayerid();
  uint32_t startdealerplayerid() const;
  void set_startdealerplayerid(uint32_t value);
  private:
  uint32_t _internal_startdealerplayerid() const;
  void _internal_set_startdealerplayerid(uint32_t value);
  public:

  // required uint32 handNum = 3;
  bool has_handnum() const;
  private:
  bool _internal_has_handnum() const;
  public:
  void clear_handnum();
  uint32_t handnum() const;
  void set_handnum(uint32_t value);
  private:
  uint32_t _internal_handnum() const;
  void _internal_set_handnum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData > rejoinplayerdata_;
  uint32_t gameid_;
  uint32_t startdealerplayerid_;
  uint32_t handnum_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class HandStartMessage_PlainCards final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:HandStartMessage.PlainCards) */ {
 public:
  inline HandStartMessage_PlainCards() : HandStartMessage_PlainCards(nullptr) {}
  ~HandStartMessage_PlainCards() override;
  explicit constexpr HandStartMessage_PlainCards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandStartMessage_PlainCards(const HandStartMessage_PlainCards& from);
  HandStartMessage_PlainCards(HandStartMessage_PlainCards&& from) noexcept
    : HandStartMessage_PlainCards() {
    *this = ::std::move(from);
  }

  inline HandStartMessage_PlainCards& operator=(const HandStartMessage_PlainCards& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandStartMessage_PlainCards& operator=(HandStartMessage_PlainCards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HandStartMessage_PlainCards& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandStartMessage_PlainCards* internal_default_instance() {
    return reinterpret_cast<const HandStartMessage_PlainCards*>(
               &_HandStartMessage_PlainCards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(HandStartMessage_PlainCards& a, HandStartMessage_PlainCards& b) {
    a.Swap(&b);
  }
  inline void Swap(HandStartMessage_PlainCards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandStartMessage_PlainCards* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandStartMessage_PlainCards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandStartMessage_PlainCards>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HandStartMessage_PlainCards& from);
  void MergeFrom(const HandStartMessage_PlainCards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HandStartMessage_PlainCards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HandStartMessage.PlainCards";
  }
  protected:
  explicit HandStartMessage_PlainCards(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlainCard1FieldNumber = 1,
    kPlainCard2FieldNumber = 2,
  };
  // required uint32 plainCard1 = 1;
  bool has_plaincard1() const;
  private:
  bool _internal_has_plaincard1() const;
  public:
  void clear_plaincard1();
  uint32_t plaincard1() const;
  void set_plaincard1(uint32_t value);
  private:
  uint32_t _internal_plaincard1() const;
  void _internal_set_plaincard1(uint32_t value);
  public:

  // required uint32 plainCard2 = 2;
  bool has_plaincard2() const;
  private:
  bool _internal_has_plaincard2() const;
  public:
  void clear_plaincard2();
  uint32_t plaincard2() const;
  void set_plaincard2(uint32_t value);
  private:
  uint32_t _internal_plaincard2() const;
  void _internal_set_plaincard2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HandStartMessage.PlainCards)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t plaincard1_;
  uint32_t plaincard2_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class HandStartMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:HandStartMessage) */ {
 public:
  inline HandStartMessage() : HandStartMessage(nullptr) {}
  ~HandStartMessage() override;
  explicit constexpr HandStartMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandStartMessage(const HandStartMessage& from);
  HandStartMessage(HandStartMessage&& from) noexcept
    : HandStartMessage() {
    *this = ::std::move(from);
  }

  inline HandStartMessage& operator=(const HandStartMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandStartMessage& operator=(HandStartMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HandStartMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandStartMessage* internal_default_instance() {
    return reinterpret_cast<const HandStartMessage*>(
               &_HandStartMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(HandStartMessage& a, HandStartMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HandStartMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandStartMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandStartMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandStartMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HandStartMessage& from);
  void MergeFrom(const HandStartMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HandStartMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HandStartMessage";
  }
  protected:
  explicit HandStartMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef HandStartMessage_PlainCards PlainCards;

  // accessors -------------------------------------------------------

  enum : int {
    kSeatStatesFieldNumber = 5,
    kEncryptedCardsFieldNumber = 3,
    kPlainCardsFieldNumber = 2,
    kGameIdFieldNumber = 1,
    kSmallBlindFieldNumber = 4,
    kDealerPlayerIdFieldNumber = 6,
  };
  // repeated .NetPlayerState seatStates = 5;
  int seatstates_size() const;
  private:
  int _internal_seatstates_size() const;
  public:
  void clear_seatstates();
  private:
  ::NetPlayerState _internal_seatstates(int index) const;
  void _internal_add_seatstates(::NetPlayerState value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_seatstates();
  public:
  ::NetPlayerState seatstates(int index) const;
  void set_seatstates(int index, ::NetPlayerState value);
  void add_seatstates(::NetPlayerState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& seatstates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_seatstates();

  // optional bytes encryptedCards = 3;
  bool has_encryptedcards() const;
  private:
  bool _internal_has_encryptedcards() const;
  public:
  void clear_encryptedcards();
  const std::string& encryptedcards() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryptedcards(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryptedcards();
  PROTOBUF_NODISCARD std::string* release_encryptedcards();
  void set_allocated_encryptedcards(std::string* encryptedcards);
  private:
  const std::string& _internal_encryptedcards() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryptedcards(const std::string& value);
  std::string* _internal_mutable_encryptedcards();
  public:

  // optional .HandStartMessage.PlainCards plainCards = 2;
  bool has_plaincards() const;
  private:
  bool _internal_has_plaincards() const;
  public:
  void clear_plaincards();
  const ::HandStartMessage_PlainCards& plaincards() const;
  PROTOBUF_NODISCARD ::HandStartMessage_PlainCards* release_plaincards();
  ::HandStartMessage_PlainCards* mutable_plaincards();
  void set_allocated_plaincards(::HandStartMessage_PlainCards* plaincards);
  private:
  const ::HandStartMessage_PlainCards& _internal_plaincards() const;
  ::HandStartMessage_PlainCards* _internal_mutable_plaincards();
  public:
  void unsafe_arena_set_allocated_plaincards(
      ::HandStartMessage_PlainCards* plaincards);
  ::HandStartMessage_PlainCards* unsafe_arena_release_plaincards();

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 smallBlind = 4;
  bool has_smallblind() const;
  private:
  bool _internal_has_smallblind() const;
  public:
  void clear_smallblind();
  uint32_t smallblind() const;
  void set_smallblind(uint32_t value);
  private:
  uint32_t _internal_smallblind() const;
  void _internal_set_smallblind(uint32_t value);
  public:

  // optional uint32 dealerPlayerId = 6;
  bool has_dealerplayerid() const;
  private:
  bool _internal_has_dealerplayerid() const;
  public:
  void clear_dealerplayerid();
  uint32_t dealerplayerid() const;
  void set_dealerplayerid(uint32_t value);
  private:
  uint32_t _internal_dealerplayerid() const;
  void _internal_set_dealerplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HandStartMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> seatstates_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryptedcards_;
  ::HandStartMessage_PlainCards* plaincards_;
  uint32_t gameid_;
  uint32_t smallblind_;
  uint32_t dealerplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayersTurnMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayersTurnMessage) */ {
 public:
  inline PlayersTurnMessage() : PlayersTurnMessage(nullptr) {}
  ~PlayersTurnMessage() override;
  explicit constexpr PlayersTurnMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayersTurnMessage(const PlayersTurnMessage& from);
  PlayersTurnMessage(PlayersTurnMessage&& from) noexcept
    : PlayersTurnMessage() {
    *this = ::std::move(from);
  }

  inline PlayersTurnMessage& operator=(const PlayersTurnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayersTurnMessage& operator=(PlayersTurnMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayersTurnMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayersTurnMessage* internal_default_instance() {
    return reinterpret_cast<const PlayersTurnMessage*>(
               &_PlayersTurnMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(PlayersTurnMessage& a, PlayersTurnMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayersTurnMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayersTurnMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayersTurnMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayersTurnMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayersTurnMessage& from);
  void MergeFrom(const PlayersTurnMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayersTurnMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayersTurnMessage";
  }
  protected:
  explicit PlayersTurnMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kGameStateFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .NetGameState gameState = 3;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);
  private:
  ::NetGameState _internal_gamestate() const;
  void _internal_set_gamestate(::NetGameState value);
  public:

  // @@protoc_insertion_point(class_scope:PlayersTurnMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  int gamestate_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class MyActionRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MyActionRequestMessage) */ {
 public:
  inline MyActionRequestMessage() : MyActionRequestMessage(nullptr) {}
  ~MyActionRequestMessage() override;
  explicit constexpr MyActionRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MyActionRequestMessage(const MyActionRequestMessage& from);
  MyActionRequestMessage(MyActionRequestMessage&& from) noexcept
    : MyActionRequestMessage() {
    *this = ::std::move(from);
  }

  inline MyActionRequestMessage& operator=(const MyActionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyActionRequestMessage& operator=(MyActionRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MyActionRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyActionRequestMessage* internal_default_instance() {
    return reinterpret_cast<const MyActionRequestMessage*>(
               &_MyActionRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(MyActionRequestMessage& a, MyActionRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MyActionRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyActionRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyActionRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MyActionRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MyActionRequestMessage& from);
  void MergeFrom(const MyActionRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MyActionRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyActionRequestMessage";
  }
  protected:
  explicit MyActionRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kHandNumFieldNumber = 2,
    kGameStateFieldNumber = 3,
    kMyActionFieldNumber = 4,
    kMyRelativeBetFieldNumber = 5,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 handNum = 2;
  bool has_handnum() const;
  private:
  bool _internal_has_handnum() const;
  public:
  void clear_handnum();
  uint32_t handnum() const;
  void set_handnum(uint32_t value);
  private:
  uint32_t _internal_handnum() const;
  void _internal_set_handnum(uint32_t value);
  public:

  // required .NetGameState gameState = 3;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);
  private:
  ::NetGameState _internal_gamestate() const;
  void _internal_set_gamestate(::NetGameState value);
  public:

  // required .NetPlayerAction myAction = 4;
  bool has_myaction() const;
  private:
  bool _internal_has_myaction() const;
  public:
  void clear_myaction();
  ::NetPlayerAction myaction() const;
  void set_myaction(::NetPlayerAction value);
  private:
  ::NetPlayerAction _internal_myaction() const;
  void _internal_set_myaction(::NetPlayerAction value);
  public:

  // required uint32 myRelativeBet = 5;
  bool has_myrelativebet() const;
  private:
  bool _internal_has_myrelativebet() const;
  public:
  void clear_myrelativebet();
  uint32_t myrelativebet() const;
  void set_myrelativebet(uint32_t value);
  private:
  uint32_t _internal_myrelativebet() const;
  void _internal_set_myrelativebet(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MyActionRequestMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t handnum_;
  int gamestate_;
  int myaction_;
  uint32_t myrelativebet_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class YourActionRejectedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:YourActionRejectedMessage) */ {
 public:
  inline YourActionRejectedMessage() : YourActionRejectedMessage(nullptr) {}
  ~YourActionRejectedMessage() override;
  explicit constexpr YourActionRejectedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  YourActionRejectedMessage(const YourActionRejectedMessage& from);
  YourActionRejectedMessage(YourActionRejectedMessage&& from) noexcept
    : YourActionRejectedMessage() {
    *this = ::std::move(from);
  }

  inline YourActionRejectedMessage& operator=(const YourActionRejectedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline YourActionRejectedMessage& operator=(YourActionRejectedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const YourActionRejectedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const YourActionRejectedMessage* internal_default_instance() {
    return reinterpret_cast<const YourActionRejectedMessage*>(
               &_YourActionRejectedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(YourActionRejectedMessage& a, YourActionRejectedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(YourActionRejectedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YourActionRejectedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  YourActionRejectedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<YourActionRejectedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const YourActionRejectedMessage& from);
  void MergeFrom(const YourActionRejectedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YourActionRejectedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "YourActionRejectedMessage";
  }
  protected:
  explicit YourActionRejectedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef YourActionRejectedMessage_RejectionReason RejectionReason;
  static constexpr RejectionReason rejectedInvalidGameState =
    YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
  static constexpr RejectionReason rejectedNotYourTurn =
    YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn;
  static constexpr RejectionReason rejectedActionNotAllowed =
    YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
  static inline bool RejectionReason_IsValid(int value) {
    return YourActionRejectedMessage_RejectionReason_IsValid(value);
  }
  static constexpr RejectionReason RejectionReason_MIN =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MIN;
  static constexpr RejectionReason RejectionReason_MAX =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MAX;
  static constexpr int RejectionReason_ARRAYSIZE =
    YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RejectionReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RejectionReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RejectionReason_Name.");
    return YourActionRejectedMessage_RejectionReason_Name(enum_t_value);
  }
  static inline bool RejectionReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RejectionReason* value) {
    return YourActionRejectedMessage_RejectionReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kGameStateFieldNumber = 2,
    kYourActionFieldNumber = 3,
    kYourRelativeBetFieldNumber = 4,
    kRejectionReasonFieldNumber = 5,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required .NetGameState gameState = 2;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);
  private:
  ::NetGameState _internal_gamestate() const;
  void _internal_set_gamestate(::NetGameState value);
  public:

  // required .NetPlayerAction yourAction = 3;
  bool has_youraction() const;
  private:
  bool _internal_has_youraction() const;
  public:
  void clear_youraction();
  ::NetPlayerAction youraction() const;
  void set_youraction(::NetPlayerAction value);
  private:
  ::NetPlayerAction _internal_youraction() const;
  void _internal_set_youraction(::NetPlayerAction value);
  public:

  // required uint32 yourRelativeBet = 4;
  bool has_yourrelativebet() const;
  private:
  bool _internal_has_yourrelativebet() const;
  public:
  void clear_yourrelativebet();
  uint32_t yourrelativebet() const;
  void set_yourrelativebet(uint32_t value);
  private:
  uint32_t _internal_yourrelativebet() const;
  void _internal_set_yourrelativebet(uint32_t value);
  public:

  // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
  bool has_rejectionreason() const;
  private:
  bool _internal_has_rejectionreason() const;
  public:
  void clear_rejectionreason();
  ::YourActionRejectedMessage_RejectionReason rejectionreason() const;
  void set_rejectionreason(::YourActionRejectedMessage_RejectionReason value);
  private:
  ::YourActionRejectedMessage_RejectionReason _internal_rejectionreason() const;
  void _internal_set_rejectionreason(::YourActionRejectedMessage_RejectionReason value);
  public:

  // @@protoc_insertion_point(class_scope:YourActionRejectedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  int gamestate_;
  int youraction_;
  uint32_t yourrelativebet_;
  int rejectionreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayersActionDoneMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayersActionDoneMessage) */ {
 public:
  inline PlayersActionDoneMessage() : PlayersActionDoneMessage(nullptr) {}
  ~PlayersActionDoneMessage() override;
  explicit constexpr PlayersActionDoneMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayersActionDoneMessage(const PlayersActionDoneMessage& from);
  PlayersActionDoneMessage(PlayersActionDoneMessage&& from) noexcept
    : PlayersActionDoneMessage() {
    *this = ::std::move(from);
  }

  inline PlayersActionDoneMessage& operator=(const PlayersActionDoneMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayersActionDoneMessage& operator=(PlayersActionDoneMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayersActionDoneMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayersActionDoneMessage* internal_default_instance() {
    return reinterpret_cast<const PlayersActionDoneMessage*>(
               &_PlayersActionDoneMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(PlayersActionDoneMessage& a, PlayersActionDoneMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayersActionDoneMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayersActionDoneMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayersActionDoneMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayersActionDoneMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayersActionDoneMessage& from);
  void MergeFrom(const PlayersActionDoneMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayersActionDoneMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayersActionDoneMessage";
  }
  protected:
  explicit PlayersActionDoneMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kGameStateFieldNumber = 3,
    kPlayerActionFieldNumber = 4,
    kTotalPlayerBetFieldNumber = 5,
    kPlayerMoneyFieldNumber = 6,
    kHighestSetFieldNumber = 7,
    kMinimumRaiseFieldNumber = 8,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .NetGameState gameState = 3;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);
  private:
  ::NetGameState _internal_gamestate() const;
  void _internal_set_gamestate(::NetGameState value);
  public:

  // required .NetPlayerAction playerAction = 4;
  bool has_playeraction() const;
  private:
  bool _internal_has_playeraction() const;
  public:
  void clear_playeraction();
  ::NetPlayerAction playeraction() const;
  void set_playeraction(::NetPlayerAction value);
  private:
  ::NetPlayerAction _internal_playeraction() const;
  void _internal_set_playeraction(::NetPlayerAction value);
  public:

  // required uint32 totalPlayerBet = 5;
  bool has_totalplayerbet() const;
  private:
  bool _internal_has_totalplayerbet() const;
  public:
  void clear_totalplayerbet();
  uint32_t totalplayerbet() const;
  void set_totalplayerbet(uint32_t value);
  private:
  uint32_t _internal_totalplayerbet() const;
  void _internal_set_totalplayerbet(uint32_t value);
  public:

  // required uint32 playerMoney = 6;
  bool has_playermoney() const;
  private:
  bool _internal_has_playermoney() const;
  public:
  void clear_playermoney();
  uint32_t playermoney() const;
  void set_playermoney(uint32_t value);
  private:
  uint32_t _internal_playermoney() const;
  void _internal_set_playermoney(uint32_t value);
  public:

  // required uint32 highestSet = 7;
  bool has_highestset() const;
  private:
  bool _internal_has_highestset() const;
  public:
  void clear_highestset();
  uint32_t highestset() const;
  void set_highestset(uint32_t value);
  private:
  uint32_t _internal_highestset() const;
  void _internal_set_highestset(uint32_t value);
  public:

  // required uint32 minimumRaise = 8;
  bool has_minimumraise() const;
  private:
  bool _internal_has_minimumraise() const;
  public:
  void clear_minimumraise();
  uint32_t minimumraise() const;
  void set_minimumraise(uint32_t value);
  private:
  uint32_t _internal_minimumraise() const;
  void _internal_set_minimumraise(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayersActionDoneMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  int gamestate_;
  int playeraction_;
  uint32_t totalplayerbet_;
  uint32_t playermoney_;
  uint32_t highestset_;
  uint32_t minimumraise_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DealFlopCardsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DealFlopCardsMessage) */ {
 public:
  inline DealFlopCardsMessage() : DealFlopCardsMessage(nullptr) {}
  ~DealFlopCardsMessage() override;
  explicit constexpr DealFlopCardsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DealFlopCardsMessage(const DealFlopCardsMessage& from);
  DealFlopCardsMessage(DealFlopCardsMessage&& from) noexcept
    : DealFlopCardsMessage() {
    *this = ::std::move(from);
  }

  inline DealFlopCardsMessage& operator=(const DealFlopCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DealFlopCardsMessage& operator=(DealFlopCardsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DealFlopCardsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DealFlopCardsMessage* internal_default_instance() {
    return reinterpret_cast<const DealFlopCardsMessage*>(
               &_DealFlopCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DealFlopCardsMessage& a, DealFlopCardsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DealFlopCardsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DealFlopCardsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DealFlopCardsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DealFlopCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DealFlopCardsMessage& from);
  void MergeFrom(const DealFlopCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DealFlopCardsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DealFlopCardsMessage";
  }
  protected:
  explicit DealFlopCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kFlopCard1FieldNumber = 2,
    kFlopCard2FieldNumber = 3,
    kFlopCard3FieldNumber = 4,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 flopCard1 = 2;
  bool has_flopcard1() const;
  private:
  bool _internal_has_flopcard1() const;
  public:
  void clear_flopcard1();
  uint32_t flopcard1() const;
  void set_flopcard1(uint32_t value);
  private:
  uint32_t _internal_flopcard1() const;
  void _internal_set_flopcard1(uint32_t value);
  public:

  // required uint32 flopCard2 = 3;
  bool has_flopcard2() const;
  private:
  bool _internal_has_flopcard2() const;
  public:
  void clear_flopcard2();
  uint32_t flopcard2() const;
  void set_flopcard2(uint32_t value);
  private:
  uint32_t _internal_flopcard2() const;
  void _internal_set_flopcard2(uint32_t value);
  public:

  // required uint32 flopCard3 = 4;
  bool has_flopcard3() const;
  private:
  bool _internal_has_flopcard3() const;
  public:
  void clear_flopcard3();
  uint32_t flopcard3() const;
  void set_flopcard3(uint32_t value);
  private:
  uint32_t _internal_flopcard3() const;
  void _internal_set_flopcard3(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DealFlopCardsMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t flopcard1_;
  uint32_t flopcard2_;
  uint32_t flopcard3_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DealTurnCardMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DealTurnCardMessage) */ {
 public:
  inline DealTurnCardMessage() : DealTurnCardMessage(nullptr) {}
  ~DealTurnCardMessage() override;
  explicit constexpr DealTurnCardMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DealTurnCardMessage(const DealTurnCardMessage& from);
  DealTurnCardMessage(DealTurnCardMessage&& from) noexcept
    : DealTurnCardMessage() {
    *this = ::std::move(from);
  }

  inline DealTurnCardMessage& operator=(const DealTurnCardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DealTurnCardMessage& operator=(DealTurnCardMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DealTurnCardMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DealTurnCardMessage* internal_default_instance() {
    return reinterpret_cast<const DealTurnCardMessage*>(
               &_DealTurnCardMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(DealTurnCardMessage& a, DealTurnCardMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DealTurnCardMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DealTurnCardMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DealTurnCardMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DealTurnCardMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DealTurnCardMessage& from);
  void MergeFrom(const DealTurnCardMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DealTurnCardMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DealTurnCardMessage";
  }
  protected:
  explicit DealTurnCardMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kTurnCardFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 turnCard = 2;
  bool has_turncard() const;
  private:
  bool _internal_has_turncard() const;
  public:
  void clear_turncard();
  uint32_t turncard() const;
  void set_turncard(uint32_t value);
  private:
  uint32_t _internal_turncard() const;
  void _internal_set_turncard(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DealTurnCardMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t turncard_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DealRiverCardMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DealRiverCardMessage) */ {
 public:
  inline DealRiverCardMessage() : DealRiverCardMessage(nullptr) {}
  ~DealRiverCardMessage() override;
  explicit constexpr DealRiverCardMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DealRiverCardMessage(const DealRiverCardMessage& from);
  DealRiverCardMessage(DealRiverCardMessage&& from) noexcept
    : DealRiverCardMessage() {
    *this = ::std::move(from);
  }

  inline DealRiverCardMessage& operator=(const DealRiverCardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DealRiverCardMessage& operator=(DealRiverCardMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DealRiverCardMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DealRiverCardMessage* internal_default_instance() {
    return reinterpret_cast<const DealRiverCardMessage*>(
               &_DealRiverCardMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(DealRiverCardMessage& a, DealRiverCardMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DealRiverCardMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DealRiverCardMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DealRiverCardMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DealRiverCardMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DealRiverCardMessage& from);
  void MergeFrom(const DealRiverCardMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DealRiverCardMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DealRiverCardMessage";
  }
  protected:
  explicit DealRiverCardMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kRiverCardFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 riverCard = 2;
  bool has_rivercard() const;
  private:
  bool _internal_has_rivercard() const;
  public:
  void clear_rivercard();
  uint32_t rivercard() const;
  void set_rivercard(uint32_t value);
  private:
  uint32_t _internal_rivercard() const;
  void _internal_set_rivercard(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DealRiverCardMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t rivercard_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage_PlayerAllIn final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AllInShowCardsMessage.PlayerAllIn) */ {
 public:
  inline AllInShowCardsMessage_PlayerAllIn() : AllInShowCardsMessage_PlayerAllIn(nullptr) {}
  ~AllInShowCardsMessage_PlayerAllIn() override;
  explicit constexpr AllInShowCardsMessage_PlayerAllIn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllInShowCardsMessage_PlayerAllIn(const AllInShowCardsMessage_PlayerAllIn& from);
  AllInShowCardsMessage_PlayerAllIn(AllInShowCardsMessage_PlayerAllIn&& from) noexcept
    : AllInShowCardsMessage_PlayerAllIn() {
    *this = ::std::move(from);
  }

  inline AllInShowCardsMessage_PlayerAllIn& operator=(const AllInShowCardsMessage_PlayerAllIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllInShowCardsMessage_PlayerAllIn& operator=(AllInShowCardsMessage_PlayerAllIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllInShowCardsMessage_PlayerAllIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllInShowCardsMessage_PlayerAllIn* internal_default_instance() {
    return reinterpret_cast<const AllInShowCardsMessage_PlayerAllIn*>(
               &_AllInShowCardsMessage_PlayerAllIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(AllInShowCardsMessage_PlayerAllIn& a, AllInShowCardsMessage_PlayerAllIn& b) {
    a.Swap(&b);
  }
  inline void Swap(AllInShowCardsMessage_PlayerAllIn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllInShowCardsMessage_PlayerAllIn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllInShowCardsMessage_PlayerAllIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllInShowCardsMessage_PlayerAllIn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  void MergeFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllInShowCardsMessage_PlayerAllIn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AllInShowCardsMessage.PlayerAllIn";
  }
  protected:
  explicit AllInShowCardsMessage_PlayerAllIn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kAllInCard1FieldNumber = 2,
    kAllInCard2FieldNumber = 3,
  };
  // required uint32 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required uint32 allInCard1 = 2;
  bool has_allincard1() const;
  private:
  bool _internal_has_allincard1() const;
  public:
  void clear_allincard1();
  uint32_t allincard1() const;
  void set_allincard1(uint32_t value);
  private:
  uint32_t _internal_allincard1() const;
  void _internal_set_allincard1(uint32_t value);
  public:

  // required uint32 allInCard2 = 3;
  bool has_allincard2() const;
  private:
  bool _internal_has_allincard2() const;
  public:
  void clear_allincard2();
  uint32_t allincard2() const;
  void set_allincard2(uint32_t value);
  private:
  uint32_t _internal_allincard2() const;
  void _internal_set_allincard2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage.PlayerAllIn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t playerid_;
  uint32_t allincard1_;
  uint32_t allincard2_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AllInShowCardsMessage) */ {
 public:
  inline AllInShowCardsMessage() : AllInShowCardsMessage(nullptr) {}
  ~AllInShowCardsMessage() override;
  explicit constexpr AllInShowCardsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllInShowCardsMessage(const AllInShowCardsMessage& from);
  AllInShowCardsMessage(AllInShowCardsMessage&& from) noexcept
    : AllInShowCardsMessage() {
    *this = ::std::move(from);
  }

  inline AllInShowCardsMessage& operator=(const AllInShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllInShowCardsMessage& operator=(AllInShowCardsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllInShowCardsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllInShowCardsMessage* internal_default_instance() {
    return reinterpret_cast<const AllInShowCardsMessage*>(
               &_AllInShowCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(AllInShowCardsMessage& a, AllInShowCardsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AllInShowCardsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllInShowCardsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllInShowCardsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllInShowCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllInShowCardsMessage& from);
  void MergeFrom(const AllInShowCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllInShowCardsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AllInShowCardsMessage";
  }
  protected:
  explicit AllInShowCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AllInShowCardsMessage_PlayerAllIn PlayerAllIn;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersAllInFieldNumber = 2,
    kGameIdFieldNumber = 1,
  };
  // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
  int playersallin_size() const;
  private:
  int _internal_playersallin_size() const;
  public:
  void clear_playersallin();
  ::AllInShowCardsMessage_PlayerAllIn* mutable_playersallin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
      mutable_playersallin();
  private:
  const ::AllInShowCardsMessage_PlayerAllIn& _internal_playersallin(int index) const;
  ::AllInShowCardsMessage_PlayerAllIn* _internal_add_playersallin();
  public:
  const ::AllInShowCardsMessage_PlayerAllIn& playersallin(int index) const;
  ::AllInShowCardsMessage_PlayerAllIn* add_playersallin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
      playersallin() const;

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn > playersallin_;
  uint32_t gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndOfHandShowCardsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:EndOfHandShowCardsMessage) */ {
 public:
  inline EndOfHandShowCardsMessage() : EndOfHandShowCardsMessage(nullptr) {}
  ~EndOfHandShowCardsMessage() override;
  explicit constexpr EndOfHandShowCardsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndOfHandShowCardsMessage(const EndOfHandShowCardsMessage& from);
  EndOfHandShowCardsMessage(EndOfHandShowCardsMessage&& from) noexcept
    : EndOfHandShowCardsMessage() {
    *this = ::std::move(from);
  }

  inline EndOfHandShowCardsMessage& operator=(const EndOfHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndOfHandShowCardsMessage& operator=(EndOfHandShowCardsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EndOfHandShowCardsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndOfHandShowCardsMessage* internal_default_instance() {
    return reinterpret_cast<const EndOfHandShowCardsMessage*>(
               &_EndOfHandShowCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(EndOfHandShowCardsMessage& a, EndOfHandShowCardsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EndOfHandShowCardsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndOfHandShowCardsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndOfHandShowCardsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndOfHandShowCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EndOfHandShowCardsMessage& from);
  void MergeFrom(const EndOfHandShowCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndOfHandShowCardsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EndOfHandShowCardsMessage";
  }
  protected:
  explicit EndOfHandShowCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerResultsFieldNumber = 2,
    kGameIdFieldNumber = 1,
  };
  // repeated .PlayerResult playerResults = 2;
  int playerresults_size() const;
  private:
  int _internal_playerresults_size() const;
  public:
  void clear_playerresults();
  ::PlayerResult* mutable_playerresults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerResult >*
      mutable_playerresults();
  private:
  const ::PlayerResult& _internal_playerresults(int index) const;
  ::PlayerResult* _internal_add_playerresults();
  public:
  const ::PlayerResult& playerresults(int index) const;
  ::PlayerResult* add_playerresults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerResult >&
      playerresults() const;

  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EndOfHandShowCardsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerResult > playerresults_;
  uint32_t gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndOfHandHideCardsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:EndOfHandHideCardsMessage) */ {
 public:
  inline EndOfHandHideCardsMessage() : EndOfHandHideCardsMessage(nullptr) {}
  ~EndOfHandHideCardsMessage() override;
  explicit constexpr EndOfHandHideCardsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndOfHandHideCardsMessage(const EndOfHandHideCardsMessage& from);
  EndOfHandHideCardsMessage(EndOfHandHideCardsMessage&& from) noexcept
    : EndOfHandHideCardsMessage() {
    *this = ::std::move(from);
  }

  inline EndOfHandHideCardsMessage& operator=(const EndOfHandHideCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndOfHandHideCardsMessage& operator=(EndOfHandHideCardsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EndOfHandHideCardsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndOfHandHideCardsMessage* internal_default_instance() {
    return reinterpret_cast<const EndOfHandHideCardsMessage*>(
               &_EndOfHandHideCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(EndOfHandHideCardsMessage& a, EndOfHandHideCardsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EndOfHandHideCardsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndOfHandHideCardsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndOfHandHideCardsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndOfHandHideCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EndOfHandHideCardsMessage& from);
  void MergeFrom(const EndOfHandHideCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndOfHandHideCardsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EndOfHandHideCardsMessage";
  }
  protected:
  explicit EndOfHandHideCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kMoneyWonFieldNumber = 3,
    kPlayerMoneyFieldNumber = 4,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required uint32 moneyWon = 3;
  bool has_moneywon() const;
  private:
  bool _internal_has_moneywon() const;
  public:
  void clear_moneywon();
  uint32_t moneywon() const;
  void set_moneywon(uint32_t value);
  private:
  uint32_t _internal_moneywon() const;
  void _internal_set_moneywon(uint32_t value);
  public:

  // required uint32 playerMoney = 4;
  bool has_playermoney() const;
  private:
  bool _internal_has_playermoney() const;
  public:
  void clear_playermoney();
  uint32_t playermoney() const;
  void set_playermoney(uint32_t value);
  private:
  uint32_t _internal_playermoney() const;
  void _internal_set_playermoney(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EndOfHandHideCardsMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  uint32_t moneywon_;
  uint32_t playermoney_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ShowMyCardsRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShowMyCardsRequestMessage) */ {
 public:
  inline ShowMyCardsRequestMessage() : ShowMyCardsRequestMessage(nullptr) {}
  ~ShowMyCardsRequestMessage() override;
  explicit constexpr ShowMyCardsRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowMyCardsRequestMessage(const ShowMyCardsRequestMessage& from);
  ShowMyCardsRequestMessage(ShowMyCardsRequestMessage&& from) noexcept
    : ShowMyCardsRequestMessage() {
    *this = ::std::move(from);
  }

  inline ShowMyCardsRequestMessage& operator=(const ShowMyCardsRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowMyCardsRequestMessage& operator=(ShowMyCardsRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowMyCardsRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowMyCardsRequestMessage* internal_default_instance() {
    return reinterpret_cast<const ShowMyCardsRequestMessage*>(
               &_ShowMyCardsRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(ShowMyCardsRequestMessage& a, ShowMyCardsRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowMyCardsRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowMyCardsRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowMyCardsRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowMyCardsRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowMyCardsRequestMessage& from);
  void MergeFrom(const ShowMyCardsRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowMyCardsRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShowMyCardsRequestMessage";
  }
  protected:
  explicit ShowMyCardsRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ShowMyCardsRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AfterHandShowCardsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AfterHandShowCardsMessage) */ {
 public:
  inline AfterHandShowCardsMessage() : AfterHandShowCardsMessage(nullptr) {}
  ~AfterHandShowCardsMessage() override;
  explicit constexpr AfterHandShowCardsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AfterHandShowCardsMessage(const AfterHandShowCardsMessage& from);
  AfterHandShowCardsMessage(AfterHandShowCardsMessage&& from) noexcept
    : AfterHandShowCardsMessage() {
    *this = ::std::move(from);
  }

  inline AfterHandShowCardsMessage& operator=(const AfterHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AfterHandShowCardsMessage& operator=(AfterHandShowCardsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AfterHandShowCardsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AfterHandShowCardsMessage* internal_default_instance() {
    return reinterpret_cast<const AfterHandShowCardsMessage*>(
               &_AfterHandShowCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(AfterHandShowCardsMessage& a, AfterHandShowCardsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AfterHandShowCardsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AfterHandShowCardsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AfterHandShowCardsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AfterHandShowCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AfterHandShowCardsMessage& from);
  void MergeFrom(const AfterHandShowCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AfterHandShowCardsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AfterHandShowCardsMessage";
  }
  protected:
  explicit AfterHandShowCardsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerResultFieldNumber = 1,
  };
  // required .PlayerResult playerResult = 1;
  bool has_playerresult() const;
  private:
  bool _internal_has_playerresult() const;
  public:
  void clear_playerresult();
  const ::PlayerResult& playerresult() const;
  PROTOBUF_NODISCARD ::PlayerResult* release_playerresult();
  ::PlayerResult* mutable_playerresult();
  void set_allocated_playerresult(::PlayerResult* playerresult);
  private:
  const ::PlayerResult& _internal_playerresult() const;
  ::PlayerResult* _internal_mutable_playerresult();
  public:
  void unsafe_arena_set_allocated_playerresult(
      ::PlayerResult* playerresult);
  ::PlayerResult* unsafe_arena_release_playerresult();

  // @@protoc_insertion_point(class_scope:AfterHandShowCardsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PlayerResult* playerresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndOfGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:EndOfGameMessage) */ {
 public:
  inline EndOfGameMessage() : EndOfGameMessage(nullptr) {}
  ~EndOfGameMessage() override;
  explicit constexpr EndOfGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndOfGameMessage(const EndOfGameMessage& from);
  EndOfGameMessage(EndOfGameMessage&& from) noexcept
    : EndOfGameMessage() {
    *this = ::std::move(from);
  }

  inline EndOfGameMessage& operator=(const EndOfGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndOfGameMessage& operator=(EndOfGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EndOfGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndOfGameMessage* internal_default_instance() {
    return reinterpret_cast<const EndOfGameMessage*>(
               &_EndOfGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(EndOfGameMessage& a, EndOfGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EndOfGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndOfGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndOfGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndOfGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EndOfGameMessage& from);
  void MergeFrom(const EndOfGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndOfGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EndOfGameMessage";
  }
  protected:
  explicit EndOfGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kWinnerPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 winnerPlayerId = 2;
  bool has_winnerplayerid() const;
  private:
  bool _internal_has_winnerplayerid() const;
  public:
  void clear_winnerplayerid();
  uint32_t winnerplayerid() const;
  void set_winnerplayerid(uint32_t value);
  private:
  uint32_t _internal_winnerplayerid() const;
  void _internal_set_winnerplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EndOfGameMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t winnerplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerIdChangedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PlayerIdChangedMessage) */ {
 public:
  inline PlayerIdChangedMessage() : PlayerIdChangedMessage(nullptr) {}
  ~PlayerIdChangedMessage() override;
  explicit constexpr PlayerIdChangedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerIdChangedMessage(const PlayerIdChangedMessage& from);
  PlayerIdChangedMessage(PlayerIdChangedMessage&& from) noexcept
    : PlayerIdChangedMessage() {
    *this = ::std::move(from);
  }

  inline PlayerIdChangedMessage& operator=(const PlayerIdChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerIdChangedMessage& operator=(PlayerIdChangedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PlayerIdChangedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerIdChangedMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerIdChangedMessage*>(
               &_PlayerIdChangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(PlayerIdChangedMessage& a, PlayerIdChangedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerIdChangedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerIdChangedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerIdChangedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerIdChangedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PlayerIdChangedMessage& from);
  void MergeFrom(const PlayerIdChangedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerIdChangedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerIdChangedMessage";
  }
  protected:
  explicit PlayerIdChangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPlayerIdFieldNumber = 1,
    kNewPlayerIdFieldNumber = 2,
  };
  // required uint32 oldPlayerId = 1;
  bool has_oldplayerid() const;
  private:
  bool _internal_has_oldplayerid() const;
  public:
  void clear_oldplayerid();
  uint32_t oldplayerid() const;
  void set_oldplayerid(uint32_t value);
  private:
  uint32_t _internal_oldplayerid() const;
  void _internal_set_oldplayerid(uint32_t value);
  public:

  // required uint32 newPlayerId = 2;
  bool has_newplayerid() const;
  private:
  bool _internal_has_newplayerid() const;
  public:
  void clear_newplayerid();
  uint32_t newplayerid() const;
  void set_newplayerid(uint32_t value);
  private:
  uint32_t _internal_newplayerid() const;
  void _internal_set_newplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerIdChangedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t oldplayerid_;
  uint32_t newplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AskKickPlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AskKickPlayerMessage) */ {
 public:
  inline AskKickPlayerMessage() : AskKickPlayerMessage(nullptr) {}
  ~AskKickPlayerMessage() override;
  explicit constexpr AskKickPlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskKickPlayerMessage(const AskKickPlayerMessage& from);
  AskKickPlayerMessage(AskKickPlayerMessage&& from) noexcept
    : AskKickPlayerMessage() {
    *this = ::std::move(from);
  }

  inline AskKickPlayerMessage& operator=(const AskKickPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskKickPlayerMessage& operator=(AskKickPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AskKickPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskKickPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const AskKickPlayerMessage*>(
               &_AskKickPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(AskKickPlayerMessage& a, AskKickPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AskKickPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskKickPlayerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskKickPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskKickPlayerMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AskKickPlayerMessage& from);
  void MergeFrom(const AskKickPlayerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AskKickPlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AskKickPlayerMessage";
  }
  protected:
  explicit AskKickPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AskKickPlayerMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AskKickDeniedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AskKickDeniedMessage) */ {
 public:
  inline AskKickDeniedMessage() : AskKickDeniedMessage(nullptr) {}
  ~AskKickDeniedMessage() override;
  explicit constexpr AskKickDeniedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskKickDeniedMessage(const AskKickDeniedMessage& from);
  AskKickDeniedMessage(AskKickDeniedMessage&& from) noexcept
    : AskKickDeniedMessage() {
    *this = ::std::move(from);
  }

  inline AskKickDeniedMessage& operator=(const AskKickDeniedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskKickDeniedMessage& operator=(AskKickDeniedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AskKickDeniedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskKickDeniedMessage* internal_default_instance() {
    return reinterpret_cast<const AskKickDeniedMessage*>(
               &_AskKickDeniedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(AskKickDeniedMessage& a, AskKickDeniedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AskKickDeniedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskKickDeniedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskKickDeniedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskKickDeniedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AskKickDeniedMessage& from);
  void MergeFrom(const AskKickDeniedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AskKickDeniedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AskKickDeniedMessage";
  }
  protected:
  explicit AskKickDeniedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AskKickDeniedMessage_KickDeniedReason KickDeniedReason;
  static constexpr KickDeniedReason kickDeniedInvalidGameState =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
  static constexpr KickDeniedReason kickDeniedNotPossible =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible;
  static constexpr KickDeniedReason kickDeniedTryAgainLater =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater;
  static constexpr KickDeniedReason kickDeniedAlreadyInProgress =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress;
  static constexpr KickDeniedReason kickDeniedInvalidPlayerId =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
  static inline bool KickDeniedReason_IsValid(int value) {
    return AskKickDeniedMessage_KickDeniedReason_IsValid(value);
  }
  static constexpr KickDeniedReason KickDeniedReason_MIN =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN;
  static constexpr KickDeniedReason KickDeniedReason_MAX =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX;
  static constexpr int KickDeniedReason_ARRAYSIZE =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& KickDeniedReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KickDeniedReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KickDeniedReason_Name.");
    return AskKickDeniedMessage_KickDeniedReason_Name(enum_t_value);
  }
  static inline bool KickDeniedReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KickDeniedReason* value) {
    return AskKickDeniedMessage_KickDeniedReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kKickDeniedReasonFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
  bool has_kickdeniedreason() const;
  private:
  bool _internal_has_kickdeniedreason() const;
  public:
  void clear_kickdeniedreason();
  ::AskKickDeniedMessage_KickDeniedReason kickdeniedreason() const;
  void set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value);
  private:
  ::AskKickDeniedMessage_KickDeniedReason _internal_kickdeniedreason() const;
  void _internal_set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value);
  public:

  // @@protoc_insertion_point(class_scope:AskKickDeniedMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t playerid_;
  int kickdeniedreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StartKickPetitionMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:StartKickPetitionMessage) */ {
 public:
  inline StartKickPetitionMessage() : StartKickPetitionMessage(nullptr) {}
  ~StartKickPetitionMessage() override;
  explicit constexpr StartKickPetitionMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartKickPetitionMessage(const StartKickPetitionMessage& from);
  StartKickPetitionMessage(StartKickPetitionMessage&& from) noexcept
    : StartKickPetitionMessage() {
    *this = ::std::move(from);
  }

  inline StartKickPetitionMessage& operator=(const StartKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartKickPetitionMessage& operator=(StartKickPetitionMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StartKickPetitionMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartKickPetitionMessage* internal_default_instance() {
    return reinterpret_cast<const StartKickPetitionMessage*>(
               &_StartKickPetitionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(StartKickPetitionMessage& a, StartKickPetitionMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartKickPetitionMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartKickPetitionMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartKickPetitionMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartKickPetitionMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StartKickPetitionMessage& from);
  void MergeFrom(const StartKickPetitionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartKickPetitionMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartKickPetitionMessage";
  }
  protected:
  explicit StartKickPetitionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPetitionIdFieldNumber = 2,
    kProposingPlayerIdFieldNumber = 3,
    kKickPlayerIdFieldNumber = 4,
    kKickTimeoutSecFieldNumber = 5,
    kNumVotesNeededToKickFieldNumber = 6,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  private:
  bool _internal_has_petitionid() const;
  public:
  void clear_petitionid();
  uint32_t petitionid() const;
  void set_petitionid(uint32_t value);
  private:
  uint32_t _internal_petitionid() const;
  void _internal_set_petitionid(uint32_t value);
  public:

  // required uint32 proposingPlayerId = 3;
  bool has_proposingplayerid() const;
  private:
  bool _internal_has_proposingplayerid() const;
  public:
  void clear_proposingplayerid();
  uint32_t proposingplayerid() const;
  void set_proposingplayerid(uint32_t value);
  private:
  uint32_t _internal_proposingplayerid() const;
  void _internal_set_proposingplayerid(uint32_t value);
  public:

  // required uint32 kickPlayerId = 4;
  bool has_kickplayerid() const;
  private:
  bool _internal_has_kickplayerid() const;
  public:
  void clear_kickplayerid();
  uint32_t kickplayerid() const;
  void set_kickplayerid(uint32_t value);
  private:
  uint32_t _internal_kickplayerid() const;
  void _internal_set_kickplayerid(uint32_t value);
  public:

  // required uint32 kickTimeoutSec = 5;
  bool has_kicktimeoutsec() const;
  private:
  bool _internal_has_kicktimeoutsec() const;
  public:
  void clear_kicktimeoutsec();
  uint32_t kicktimeoutsec() const;
  void set_kicktimeoutsec(uint32_t value);
  private:
  uint32_t _internal_kicktimeoutsec() const;
  void _internal_set_kicktimeoutsec(uint32_t value);
  public:

  // required uint32 numVotesNeededToKick = 6;
  bool has_numvotesneededtokick() const;
  private:
  bool _internal_has_numvotesneededtokick() const;
  public:
  void clear_numvotesneededtokick();
  uint32_t numvotesneededtokick() const;
  void set_numvotesneededtokick(uint32_t value);
  private:
  uint32_t _internal_numvotesneededtokick() const;
  void _internal_set_numvotesneededtokick(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StartKickPetitionMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t petitionid_;
  uint32_t proposingplayerid_;
  uint32_t kickplayerid_;
  uint32_t kicktimeoutsec_;
  uint32_t numvotesneededtokick_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class VoteKickRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:VoteKickRequestMessage) */ {
 public:
  inline VoteKickRequestMessage() : VoteKickRequestMessage(nullptr) {}
  ~VoteKickRequestMessage() override;
  explicit constexpr VoteKickRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteKickRequestMessage(const VoteKickRequestMessage& from);
  VoteKickRequestMessage(VoteKickRequestMessage&& from) noexcept
    : VoteKickRequestMessage() {
    *this = ::std::move(from);
  }

  inline VoteKickRequestMessage& operator=(const VoteKickRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteKickRequestMessage& operator=(VoteKickRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VoteKickRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteKickRequestMessage* internal_default_instance() {
    return reinterpret_cast<const VoteKickRequestMessage*>(
               &_VoteKickRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(VoteKickRequestMessage& a, VoteKickRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteKickRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteKickRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteKickRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteKickRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VoteKickRequestMessage& from);
  void MergeFrom(const VoteKickRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoteKickRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VoteKickRequestMessage";
  }
  protected:
  explicit VoteKickRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPetitionIdFieldNumber = 2,
    kVoteKickFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  private:
  bool _internal_has_petitionid() const;
  public:
  void clear_petitionid();
  uint32_t petitionid() const;
  void set_petitionid(uint32_t value);
  private:
  uint32_t _internal_petitionid() const;
  void _internal_set_petitionid(uint32_t value);
  public:

  // required bool voteKick = 3;
  bool has_votekick() const;
  private:
  bool _internal_has_votekick() const;
  public:
  void clear_votekick();
  bool votekick() const;
  void set_votekick(bool value);
  private:
  bool _internal_votekick() const;
  void _internal_set_votekick(bool value);
  public:

  // @@protoc_insertion_point(class_scope:VoteKickRequestMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t petitionid_;
  bool votekick_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class VoteKickReplyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:VoteKickReplyMessage) */ {
 public:
  inline VoteKickReplyMessage() : VoteKickReplyMessage(nullptr) {}
  ~VoteKickReplyMessage() override;
  explicit constexpr VoteKickReplyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteKickReplyMessage(const VoteKickReplyMessage& from);
  VoteKickReplyMessage(VoteKickReplyMessage&& from) noexcept
    : VoteKickReplyMessage() {
    *this = ::std::move(from);
  }

  inline VoteKickReplyMessage& operator=(const VoteKickReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteKickReplyMessage& operator=(VoteKickReplyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VoteKickReplyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteKickReplyMessage* internal_default_instance() {
    return reinterpret_cast<const VoteKickReplyMessage*>(
               &_VoteKickReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(VoteKickReplyMessage& a, VoteKickReplyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteKickReplyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteKickReplyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteKickReplyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteKickReplyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VoteKickReplyMessage& from);
  void MergeFrom(const VoteKickReplyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoteKickReplyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VoteKickReplyMessage";
  }
  protected:
  explicit VoteKickReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VoteKickReplyMessage_VoteKickReplyType VoteKickReplyType;
  static constexpr VoteKickReplyType voteKickAck =
    VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
  static constexpr VoteKickReplyType voteKickDeniedInvalid =
    VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid;
  static constexpr VoteKickReplyType voteKickDeniedAlreadyVoted =
    VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
  static inline bool VoteKickReplyType_IsValid(int value) {
    return VoteKickReplyMessage_VoteKickReplyType_IsValid(value);
  }
  static constexpr VoteKickReplyType VoteKickReplyType_MIN =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN;
  static constexpr VoteKickReplyType VoteKickReplyType_MAX =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX;
  static constexpr int VoteKickReplyType_ARRAYSIZE =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& VoteKickReplyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VoteKickReplyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VoteKickReplyType_Name.");
    return VoteKickReplyMessage_VoteKickReplyType_Name(enum_t_value);
  }
  static inline bool VoteKickReplyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VoteKickReplyType* value) {
    return VoteKickReplyMessage_VoteKickReplyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPetitionIdFieldNumber = 2,
    kVoteKickReplyTypeFieldNumber = 3,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  private:
  bool _internal_has_petitionid() const;
  public:
  void clear_petitionid();
  uint32_t petitionid() const;
  void set_petitionid(uint32_t value);
  private:
  uint32_t _internal_petitionid() const;
  void _internal_set_petitionid(uint32_t value);
  public:

  // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
  bool has_votekickreplytype() const;
  private:
  bool _internal_has_votekickreplytype() const;
  public:
  void clear_votekickreplytype();
  ::VoteKickReplyMessage_VoteKickReplyType votekickreplytype() const;
  void set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value);
  private:
  ::VoteKickReplyMessage_VoteKickReplyType _internal_votekickreplytype() const;
  void _internal_set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value);
  public:

  // @@protoc_insertion_point(class_scope:VoteKickReplyMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t petitionid_;
  int votekickreplytype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class KickPetitionUpdateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:KickPetitionUpdateMessage) */ {
 public:
  inline KickPetitionUpdateMessage() : KickPetitionUpdateMessage(nullptr) {}
  ~KickPetitionUpdateMessage() override;
  explicit constexpr KickPetitionUpdateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPetitionUpdateMessage(const KickPetitionUpdateMessage& from);
  KickPetitionUpdateMessage(KickPetitionUpdateMessage&& from) noexcept
    : KickPetitionUpdateMessage() {
    *this = ::std::move(from);
  }

  inline KickPetitionUpdateMessage& operator=(const KickPetitionUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPetitionUpdateMessage& operator=(KickPetitionUpdateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KickPetitionUpdateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPetitionUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const KickPetitionUpdateMessage*>(
               &_KickPetitionUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(KickPetitionUpdateMessage& a, KickPetitionUpdateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPetitionUpdateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPetitionUpdateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPetitionUpdateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPetitionUpdateMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KickPetitionUpdateMessage& from);
  void MergeFrom(const KickPetitionUpdateMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickPetitionUpdateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KickPetitionUpdateMessage";
  }
  protected:
  explicit KickPetitionUpdateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPetitionIdFieldNumber = 2,
    kNumVotesAgainstKickingFieldNumber = 3,
    kNumVotesInFavourOfKickingFieldNumber = 4,
    kNumVotesNeededToKickFieldNumber = 5,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  private:
  bool _internal_has_petitionid() const;
  public:
  void clear_petitionid();
  uint32_t petitionid() const;
  void set_petitionid(uint32_t value);
  private:
  uint32_t _internal_petitionid() const;
  void _internal_set_petitionid(uint32_t value);
  public:

  // required uint32 numVotesAgainstKicking = 3;
  bool has_numvotesagainstkicking() const;
  private:
  bool _internal_has_numvotesagainstkicking() const;
  public:
  void clear_numvotesagainstkicking();
  uint32_t numvotesagainstkicking() const;
  void set_numvotesagainstkicking(uint32_t value);
  private:
  uint32_t _internal_numvotesagainstkicking() const;
  void _internal_set_numvotesagainstkicking(uint32_t value);
  public:

  // required uint32 numVotesInFavourOfKicking = 4;
  bool has_numvotesinfavourofkicking() const;
  private:
  bool _internal_has_numvotesinfavourofkicking() const;
  public:
  void clear_numvotesinfavourofkicking();
  uint32_t numvotesinfavourofkicking() const;
  void set_numvotesinfavourofkicking(uint32_t value);
  private:
  uint32_t _internal_numvotesinfavourofkicking() const;
  void _internal_set_numvotesinfavourofkicking(uint32_t value);
  public:

  // required uint32 numVotesNeededToKick = 5;
  bool has_numvotesneededtokick() const;
  private:
  bool _internal_has_numvotesneededtokick() const;
  public:
  void clear_numvotesneededtokick();
  uint32_t numvotesneededtokick() const;
  void set_numvotesneededtokick(uint32_t value);
  private:
  uint32_t _internal_numvotesneededtokick() const;
  void _internal_set_numvotesneededtokick(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KickPetitionUpdateMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t petitionid_;
  uint32_t numvotesagainstkicking_;
  uint32_t numvotesinfavourofkicking_;
  uint32_t numvotesneededtokick_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndKickPetitionMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:EndKickPetitionMessage) */ {
 public:
  inline EndKickPetitionMessage() : EndKickPetitionMessage(nullptr) {}
  ~EndKickPetitionMessage() override;
  explicit constexpr EndKickPetitionMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndKickPetitionMessage(const EndKickPetitionMessage& from);
  EndKickPetitionMessage(EndKickPetitionMessage&& from) noexcept
    : EndKickPetitionMessage() {
    *this = ::std::move(from);
  }

  inline EndKickPetitionMessage& operator=(const EndKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndKickPetitionMessage& operator=(EndKickPetitionMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EndKickPetitionMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndKickPetitionMessage* internal_default_instance() {
    return reinterpret_cast<const EndKickPetitionMessage*>(
               &_EndKickPetitionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(EndKickPetitionMessage& a, EndKickPetitionMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EndKickPetitionMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndKickPetitionMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndKickPetitionMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndKickPetitionMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EndKickPetitionMessage& from);
  void MergeFrom(const EndKickPetitionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndKickPetitionMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EndKickPetitionMessage";
  }
  protected:
  explicit EndKickPetitionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EndKickPetitionMessage_PetitionEndReason PetitionEndReason;
  static constexpr PetitionEndReason petitionEndEnoughVotes =
    EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
  static constexpr PetitionEndReason petitionEndTooFewPlayers =
    EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers;
  static constexpr PetitionEndReason petitionEndPlayerLeft =
    EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft;
  static constexpr PetitionEndReason petitionEndTimeout =
    EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
  static inline bool PetitionEndReason_IsValid(int value) {
    return EndKickPetitionMessage_PetitionEndReason_IsValid(value);
  }
  static constexpr PetitionEndReason PetitionEndReason_MIN =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN;
  static constexpr PetitionEndReason PetitionEndReason_MAX =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX;
  static constexpr int PetitionEndReason_ARRAYSIZE =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PetitionEndReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PetitionEndReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PetitionEndReason_Name.");
    return EndKickPetitionMessage_PetitionEndReason_Name(enum_t_value);
  }
  static inline bool PetitionEndReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PetitionEndReason* value) {
    return EndKickPetitionMessage_PetitionEndReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPetitionIdFieldNumber = 2,
    kNumVotesAgainstKickingFieldNumber = 3,
    kNumVotesInFavourOfKickingFieldNumber = 4,
    kResultPlayerKickedFieldNumber = 5,
    kPetitionEndReasonFieldNumber = 6,
  };
  // required uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  private:
  bool _internal_has_petitionid() const;
  public:
  void clear_petitionid();
  uint32_t petitionid() const;
  void set_petitionid(uint32_t value);
  private:
  uint32_t _internal_petitionid() const;
  void _internal_set_petitionid(uint32_t value);
  public:

  // required uint32 numVotesAgainstKicking = 3;
  bool has_numvotesagainstkicking() const;
  private:
  bool _internal_has_numvotesagainstkicking() const;
  public:
  void clear_numvotesagainstkicking();
  uint32_t numvotesagainstkicking() const;
  void set_numvotesagainstkicking(uint32_t value);
  private:
  uint32_t _internal_numvotesagainstkicking() const;
  void _internal_set_numvotesagainstkicking(uint32_t value);
  public:

  // required uint32 numVotesInFavourOfKicking = 4;
  bool has_numvotesinfavourofkicking() const;
  private:
  bool _internal_has_numvotesinfavourofkicking() const;
  public:
  void clear_numvotesinfavourofkicking();
  uint32_t numvotesinfavourofkicking() const;
  void set_numvotesinfavourofkicking(uint32_t value);
  private:
  uint32_t _internal_numvotesinfavourofkicking() const;
  void _internal_set_numvotesinfavourofkicking(uint32_t value);
  public:

  // required uint32 resultPlayerKicked = 5;
  bool has_resultplayerkicked() const;
  private:
  bool _internal_has_resultplayerkicked() const;
  public:
  void clear_resultplayerkicked();
  uint32_t resultplayerkicked() const;
  void set_resultplayerkicked(uint32_t value);
  private:
  uint32_t _internal_resultplayerkicked() const;
  void _internal_set_resultplayerkicked(uint32_t value);
  public:

  // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
  bool has_petitionendreason() const;
  private:
  bool _internal_has_petitionendreason() const;
  public:
  void clear_petitionendreason();
  ::EndKickPetitionMessage_PetitionEndReason petitionendreason() const;
  void set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value);
  private:
  ::EndKickPetitionMessage_PetitionEndReason _internal_petitionendreason() const;
  void _internal_set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value);
  public:

  // @@protoc_insertion_point(class_scope:EndKickPetitionMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t gameid_;
  uint32_t petitionid_;
  uint32_t numvotesagainstkicking_;
  uint32_t numvotesinfavourofkicking_;
  uint32_t resultplayerkicked_;
  int petitionendreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StatisticsMessage_StatisticsData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:StatisticsMessage.StatisticsData) */ {
 public:
  inline StatisticsMessage_StatisticsData() : StatisticsMessage_StatisticsData(nullptr) {}
  ~StatisticsMessage_StatisticsData() override;
  explicit constexpr StatisticsMessage_StatisticsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatisticsMessage_StatisticsData(const StatisticsMessage_StatisticsData& from);
  StatisticsMessage_StatisticsData(StatisticsMessage_StatisticsData&& from) noexcept
    : StatisticsMessage_StatisticsData() {
    *this = ::std::move(from);
  }

  inline StatisticsMessage_StatisticsData& operator=(const StatisticsMessage_StatisticsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatisticsMessage_StatisticsData& operator=(StatisticsMessage_StatisticsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StatisticsMessage_StatisticsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatisticsMessage_StatisticsData* internal_default_instance() {
    return reinterpret_cast<const StatisticsMessage_StatisticsData*>(
               &_StatisticsMessage_StatisticsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(StatisticsMessage_StatisticsData& a, StatisticsMessage_StatisticsData& b) {
    a.Swap(&b);
  }
  inline void Swap(StatisticsMessage_StatisticsData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatisticsMessage_StatisticsData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatisticsMessage_StatisticsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatisticsMessage_StatisticsData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StatisticsMessage_StatisticsData& from);
  void MergeFrom(const StatisticsMessage_StatisticsData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatisticsMessage_StatisticsData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatisticsMessage.StatisticsData";
  }
  protected:
  explicit StatisticsMessage_StatisticsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StatisticsMessage_StatisticsData_StatisticsType StatisticsType;
  static constexpr StatisticsType statNumberOfPlayers =
    StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
  static inline bool StatisticsType_IsValid(int value) {
    return StatisticsMessage_StatisticsData_StatisticsType_IsValid(value);
  }
  static constexpr StatisticsType StatisticsType_MIN =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN;
  static constexpr StatisticsType StatisticsType_MAX =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX;
  static constexpr int StatisticsType_ARRAYSIZE =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StatisticsType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StatisticsType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StatisticsType_Name.");
    return StatisticsMessage_StatisticsData_StatisticsType_Name(enum_t_value);
  }
  static inline bool StatisticsType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StatisticsType* value) {
    return StatisticsMessage_StatisticsData_StatisticsType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatisticsValueFieldNumber = 2,
    kStatisticsTypeFieldNumber = 1,
  };
  // required uint32 statisticsValue = 2;
  bool has_statisticsvalue() const;
  private:
  bool _internal_has_statisticsvalue() const;
  public:
  void clear_statisticsvalue();
  uint32_t statisticsvalue() const;
  void set_statisticsvalue(uint32_t value);
  private:
  uint32_t _internal_statisticsvalue() const;
  void _internal_set_statisticsvalue(uint32_t value);
  public:

  // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
  bool has_statisticstype() const;
  private:
  bool _internal_has_statisticstype() const;
  public:
  void clear_statisticstype();
  ::StatisticsMessage_StatisticsData_StatisticsType statisticstype() const;
  void set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value);
  private:
  ::StatisticsMessage_StatisticsData_StatisticsType _internal_statisticstype() const;
  void _internal_set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value);
  public:

  // @@protoc_insertion_point(class_scope:StatisticsMessage.StatisticsData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t statisticsvalue_;
  int statisticstype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StatisticsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:StatisticsMessage) */ {
 public:
  inline StatisticsMessage() : StatisticsMessage(nullptr) {}
  ~StatisticsMessage() override;
  explicit constexpr StatisticsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatisticsMessage(const StatisticsMessage& from);
  StatisticsMessage(StatisticsMessage&& from) noexcept
    : StatisticsMessage() {
    *this = ::std::move(from);
  }

  inline StatisticsMessage& operator=(const StatisticsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatisticsMessage& operator=(StatisticsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StatisticsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatisticsMessage* internal_default_instance() {
    return reinterpret_cast<const StatisticsMessage*>(
               &_StatisticsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(StatisticsMessage& a, StatisticsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StatisticsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatisticsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatisticsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatisticsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StatisticsMessage& from);
  void MergeFrom(const StatisticsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatisticsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatisticsMessage";
  }
  protected:
  explicit StatisticsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StatisticsMessage_StatisticsData StatisticsData;

  // accessors -------------------------------------------------------

  enum : int {
    kStatisticsDataFieldNumber = 1,
  };
  // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
  int statisticsdata_size() const;
  private:
  int _internal_statisticsdata_size() const;
  public:
  void clear_statisticsdata();
  ::StatisticsMessage_StatisticsData* mutable_statisticsdata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
      mutable_statisticsdata();
  private:
  const ::StatisticsMessage_StatisticsData& _internal_statisticsdata(int index) const;
  ::StatisticsMessage_StatisticsData* _internal_add_statisticsdata();
  public:
  const ::StatisticsMessage_StatisticsData& statisticsdata(int index) const;
  ::StatisticsMessage_StatisticsData* add_statisticsdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
      statisticsdata() const;

  // @@protoc_insertion_point(class_scope:StatisticsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatisticsMessage_StatisticsData > statisticsdata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ChatRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ChatRequestMessage) */ {
 public:
  inline ChatRequestMessage() : ChatRequestMessage(nullptr) {}
  ~ChatRequestMessage() override;
  explicit constexpr ChatRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatRequestMessage(const ChatRequestMessage& from);
  ChatRequestMessage(ChatRequestMessage&& from) noexcept
    : ChatRequestMessage() {
    *this = ::std::move(from);
  }

  inline ChatRequestMessage& operator=(const ChatRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRequestMessage& operator=(ChatRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChatRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatRequestMessage* internal_default_instance() {
    return reinterpret_cast<const ChatRequestMessage*>(
               &_ChatRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(ChatRequestMessage& a, ChatRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChatRequestMessage& from);
  void MergeFrom(const ChatRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatRequestMessage";
  }
  protected:
  explicit ChatRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatTextFieldNumber = 3,
    kTargetGameIdFieldNumber = 1,
    kTargetPlayerIdFieldNumber = 2,
  };
  // required string chatText = 3;
  bool has_chattext() const;
  private:
  bool _internal_has_chattext() const;
  public:
  void clear_chattext();
  const std::string& chattext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chattext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chattext();
  PROTOBUF_NODISCARD std::string* release_chattext();
  void set_allocated_chattext(std::string* chattext);
  private:
  const std::string& _internal_chattext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chattext(const std::string& value);
  std::string* _internal_mutable_chattext();
  public:

  // optional uint32 targetGameId = 1;
  bool has_targetgameid() const;
  private:
  bool _internal_has_targetgameid() const;
  public:
  void clear_targetgameid();
  uint32_t targetgameid() const;
  void set_targetgameid(uint32_t value);
  private:
  uint32_t _internal_targetgameid() const;
  void _internal_set_targetgameid(uint32_t value);
  public:

  // optional uint32 targetPlayerId = 2;
  bool has_targetplayerid() const;
  private:
  bool _internal_has_targetplayerid() const;
  public:
  void clear_targetplayerid();
  uint32_t targetplayerid() const;
  void set_targetplayerid(uint32_t value);
  private:
  uint32_t _internal_targetplayerid() const;
  void _internal_set_targetplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChatRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chattext_;
  uint32_t targetgameid_;
  uint32_t targetplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit constexpr ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ChatMessage_ChatType ChatType;
  static constexpr ChatType chatTypeLobby =
    ChatMessage_ChatType_chatTypeLobby;
  static constexpr ChatType chatTypeGame =
    ChatMessage_ChatType_chatTypeGame;
  static constexpr ChatType chatTypeBot =
    ChatMessage_ChatType_chatTypeBot;
  static constexpr ChatType chatTypeBroadcast =
    ChatMessage_ChatType_chatTypeBroadcast;
  static constexpr ChatType chatTypePrivate =
    ChatMessage_ChatType_chatTypePrivate;
  static inline bool ChatType_IsValid(int value) {
    return ChatMessage_ChatType_IsValid(value);
  }
  static constexpr ChatType ChatType_MIN =
    ChatMessage_ChatType_ChatType_MIN;
  static constexpr ChatType ChatType_MAX =
    ChatMessage_ChatType_ChatType_MAX;
  static constexpr int ChatType_ARRAYSIZE =
    ChatMessage_ChatType_ChatType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ChatType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChatType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChatType_Name.");
    return ChatMessage_ChatType_Name(enum_t_value);
  }
  static inline bool ChatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChatType* value) {
    return ChatMessage_ChatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChatTextFieldNumber = 4,
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kChatTypeFieldNumber = 3,
  };
  // required string chatText = 4;
  bool has_chattext() const;
  private:
  bool _internal_has_chattext() const;
  public:
  void clear_chattext();
  const std::string& chattext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chattext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chattext();
  PROTOBUF_NODISCARD std::string* release_chattext();
  void set_allocated_chattext(std::string* chattext);
  private:
  const std::string& _internal_chattext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chattext(const std::string& value);
  std::string* _internal_mutable_chattext();
  public:

  // optional uint32 gameId = 1;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // optional uint32 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .ChatMessage.ChatType chatType = 3;
  bool has_chattype() const;
  private:
  bool _internal_has_chattype() const;
  public:
  void clear_chattype();
  ::ChatMessage_ChatType chattype() const;
  void set_chattype(::ChatMessage_ChatType value);
  private:
  ::ChatMessage_ChatType _internal_chattype() const;
  void _internal_set_chattype(::ChatMessage_ChatType value);
  public:

  // @@protoc_insertion_point(class_scope:ChatMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chattext_;
  uint32_t gameid_;
  uint32_t playerid_;
  int chattype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ChatRejectMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ChatRejectMessage) */ {
 public:
  inline ChatRejectMessage() : ChatRejectMessage(nullptr) {}
  ~ChatRejectMessage() override;
  explicit constexpr ChatRejectMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatRejectMessage(const ChatRejectMessage& from);
  ChatRejectMessage(ChatRejectMessage&& from) noexcept
    : ChatRejectMessage() {
    *this = ::std::move(from);
  }

  inline ChatRejectMessage& operator=(const ChatRejectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRejectMessage& operator=(ChatRejectMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChatRejectMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatRejectMessage* internal_default_instance() {
    return reinterpret_cast<const ChatRejectMessage*>(
               &_ChatRejectMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(ChatRejectMessage& a, ChatRejectMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRejectMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatRejectMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatRejectMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatRejectMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChatRejectMessage& from);
  void MergeFrom(const ChatRejectMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatRejectMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatRejectMessage";
  }
  protected:
  explicit ChatRejectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatTextFieldNumber = 1,
  };
  // required string chatText = 1;
  bool has_chattext() const;
  private:
  bool _internal_has_chattext() const;
  public:
  void clear_chattext();
  const std::string& chattext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chattext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chattext();
  PROTOBUF_NODISCARD std::string* release_chattext();
  void set_allocated_chattext(std::string* chattext);
  private:
  const std::string& _internal_chattext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chattext(const std::string& value);
  std::string* _internal_mutable_chattext();
  public:

  // @@protoc_insertion_point(class_scope:ChatRejectMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chattext_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DialogMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DialogMessage) */ {
 public:
  inline DialogMessage() : DialogMessage(nullptr) {}
  ~DialogMessage() override;
  explicit constexpr DialogMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DialogMessage(const DialogMessage& from);
  DialogMessage(DialogMessage&& from) noexcept
    : DialogMessage() {
    *this = ::std::move(from);
  }

  inline DialogMessage& operator=(const DialogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DialogMessage& operator=(DialogMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DialogMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DialogMessage* internal_default_instance() {
    return reinterpret_cast<const DialogMessage*>(
               &_DialogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(DialogMessage& a, DialogMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DialogMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DialogMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DialogMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DialogMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DialogMessage& from);
  void MergeFrom(const DialogMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DialogMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DialogMessage";
  }
  protected:
  explicit DialogMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationTextFieldNumber = 1,
  };
  // required string notificationText = 1;
  bool has_notificationtext() const;
  private:
  bool _internal_has_notificationtext() const;
  public:
  void clear_notificationtext();
  const std::string& notificationtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notificationtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notificationtext();
  PROTOBUF_NODISCARD std::string* release_notificationtext();
  void set_allocated_notificationtext(std::string* notificationtext);
  private:
  const std::string& _internal_notificationtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notificationtext(const std::string& value);
  std::string* _internal_mutable_notificationtext();
  public:

  // @@protoc_insertion_point(class_scope:DialogMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notificationtext_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class TimeoutWarningMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:TimeoutWarningMessage) */ {
 public:
  inline TimeoutWarningMessage() : TimeoutWarningMessage(nullptr) {}
  ~TimeoutWarningMessage() override;
  explicit constexpr TimeoutWarningMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeoutWarningMessage(const TimeoutWarningMessage& from);
  TimeoutWarningMessage(TimeoutWarningMessage&& from) noexcept
    : TimeoutWarningMessage() {
    *this = ::std::move(from);
  }

  inline TimeoutWarningMessage& operator=(const TimeoutWarningMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeoutWarningMessage& operator=(TimeoutWarningMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimeoutWarningMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeoutWarningMessage* internal_default_instance() {
    return reinterpret_cast<const TimeoutWarningMessage*>(
               &_TimeoutWarningMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(TimeoutWarningMessage& a, TimeoutWarningMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeoutWarningMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeoutWarningMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeoutWarningMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeoutWarningMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimeoutWarningMessage& from);
  void MergeFrom(const TimeoutWarningMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeoutWarningMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TimeoutWarningMessage";
  }
  protected:
  explicit TimeoutWarningMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TimeoutWarningMessage_TimeoutReason TimeoutReason;
  static constexpr TimeoutReason timeoutNoDataReceived =
    TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
  static constexpr TimeoutReason timeoutInactiveGame =
    TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame;
  static constexpr TimeoutReason timeoutKickAfterAutofold =
    TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
  static inline bool TimeoutReason_IsValid(int value) {
    return TimeoutWarningMessage_TimeoutReason_IsValid(value);
  }
  static constexpr TimeoutReason TimeoutReason_MIN =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN;
  static constexpr TimeoutReason TimeoutReason_MAX =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX;
  static constexpr int TimeoutReason_ARRAYSIZE =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TimeoutReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TimeoutReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TimeoutReason_Name.");
    return TimeoutWarningMessage_TimeoutReason_Name(enum_t_value);
  }
  static inline bool TimeoutReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TimeoutReason* value) {
    return TimeoutWarningMessage_TimeoutReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutReasonFieldNumber = 1,
    kRemainingSecondsFieldNumber = 2,
  };
  // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
  bool has_timeoutreason() const;
  private:
  bool _internal_has_timeoutreason() const;
  public:
  void clear_timeoutreason();
  ::TimeoutWarningMessage_TimeoutReason timeoutreason() const;
  void set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value);
  private:
  ::TimeoutWarningMessage_TimeoutReason _internal_timeoutreason() const;
  void _internal_set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value);
  public:

  // required uint32 remainingSeconds = 2;
  bool has_remainingseconds() const;
  private:
  bool _internal_has_remainingseconds() const;
  public:
  void clear_remainingseconds();
  uint32_t remainingseconds() const;
  void set_remainingseconds(uint32_t value);
  private:
  uint32_t _internal_remainingseconds() const;
  void _internal_set_remainingseconds(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TimeoutWarningMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int timeoutreason_;
  uint32_t remainingseconds_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ResetTimeoutMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ResetTimeoutMessage) */ {
 public:
  inline ResetTimeoutMessage() : ResetTimeoutMessage(nullptr) {}
  ~ResetTimeoutMessage() override;
  explicit constexpr ResetTimeoutMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetTimeoutMessage(const ResetTimeoutMessage& from);
  ResetTimeoutMessage(ResetTimeoutMessage&& from) noexcept
    : ResetTimeoutMessage() {
    *this = ::std::move(from);
  }

  inline ResetTimeoutMessage& operator=(const ResetTimeoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetTimeoutMessage& operator=(ResetTimeoutMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ResetTimeoutMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetTimeoutMessage* internal_default_instance() {
    return reinterpret_cast<const ResetTimeoutMessage*>(
               &_ResetTimeoutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(ResetTimeoutMessage& a, ResetTimeoutMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetTimeoutMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetTimeoutMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetTimeoutMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetTimeoutMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResetTimeoutMessage& from);
  void MergeFrom(const ResetTimeoutMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetTimeoutMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResetTimeoutMessage";
  }
  protected:
  explicit ResetTimeoutMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ResetTimeoutMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportAvatarMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ReportAvatarMessage) */ {
 public:
  inline ReportAvatarMessage() : ReportAvatarMessage(nullptr) {}
  ~ReportAvatarMessage() override;
  explicit constexpr ReportAvatarMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportAvatarMessage(const ReportAvatarMessage& from);
  ReportAvatarMessage(ReportAvatarMessage&& from) noexcept
    : ReportAvatarMessage() {
    *this = ::std::move(from);
  }

  inline ReportAvatarMessage& operator=(const ReportAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportAvatarMessage& operator=(ReportAvatarMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReportAvatarMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportAvatarMessage* internal_default_instance() {
    return reinterpret_cast<const ReportAvatarMessage*>(
               &_ReportAvatarMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ReportAvatarMessage& a, ReportAvatarMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportAvatarMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportAvatarMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportAvatarMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportAvatarMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReportAvatarMessage& from);
  void MergeFrom(const ReportAvatarMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportAvatarMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReportAvatarMessage";
  }
  protected:
  explicit ReportAvatarMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportedAvatarHashFieldNumber = 2,
    kReportedPlayerIdFieldNumber = 1,
  };
  // required bytes reportedAvatarHash = 2;
  bool has_reportedavatarhash() const;
  private:
  bool _internal_has_reportedavatarhash() const;
  public:
  void clear_reportedavatarhash();
  const std::string& reportedavatarhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reportedavatarhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reportedavatarhash();
  PROTOBUF_NODISCARD std::string* release_reportedavatarhash();
  void set_allocated_reportedavatarhash(std::string* reportedavatarhash);
  private:
  const std::string& _internal_reportedavatarhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reportedavatarhash(const std::string& value);
  std::string* _internal_mutable_reportedavatarhash();
  public:

  // required uint32 reportedPlayerId = 1;
  bool has_reportedplayerid() const;
  private:
  bool _internal_has_reportedplayerid() const;
  public:
  void clear_reportedplayerid();
  uint32_t reportedplayerid() const;
  void set_reportedplayerid(uint32_t value);
  private:
  uint32_t _internal_reportedplayerid() const;
  void _internal_set_reportedplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReportAvatarMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reportedavatarhash_;
  uint32_t reportedplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportAvatarAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ReportAvatarAckMessage) */ {
 public:
  inline ReportAvatarAckMessage() : ReportAvatarAckMessage(nullptr) {}
  ~ReportAvatarAckMessage() override;
  explicit constexpr ReportAvatarAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportAvatarAckMessage(const ReportAvatarAckMessage& from);
  ReportAvatarAckMessage(ReportAvatarAckMessage&& from) noexcept
    : ReportAvatarAckMessage() {
    *this = ::std::move(from);
  }

  inline ReportAvatarAckMessage& operator=(const ReportAvatarAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportAvatarAckMessage& operator=(ReportAvatarAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReportAvatarAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportAvatarAckMessage* internal_default_instance() {
    return reinterpret_cast<const ReportAvatarAckMessage*>(
               &_ReportAvatarAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(ReportAvatarAckMessage& a, ReportAvatarAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportAvatarAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportAvatarAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportAvatarAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportAvatarAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReportAvatarAckMessage& from);
  void MergeFrom(const ReportAvatarAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportAvatarAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReportAvatarAckMessage";
  }
  protected:
  explicit ReportAvatarAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ReportAvatarAckMessage_ReportAvatarResult ReportAvatarResult;
  static constexpr ReportAvatarResult avatarReportAccepted =
    ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
  static constexpr ReportAvatarResult avatarReportDuplicate =
    ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate;
  static constexpr ReportAvatarResult avatarReportInvalid =
    ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
  static inline bool ReportAvatarResult_IsValid(int value) {
    return ReportAvatarAckMessage_ReportAvatarResult_IsValid(value);
  }
  static constexpr ReportAvatarResult ReportAvatarResult_MIN =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN;
  static constexpr ReportAvatarResult ReportAvatarResult_MAX =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX;
  static constexpr int ReportAvatarResult_ARRAYSIZE =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ReportAvatarResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReportAvatarResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReportAvatarResult_Name.");
    return ReportAvatarAckMessage_ReportAvatarResult_Name(enum_t_value);
  }
  static inline bool ReportAvatarResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReportAvatarResult* value) {
    return ReportAvatarAckMessage_ReportAvatarResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReportedPlayerIdFieldNumber = 1,
    kReportAvatarResultFieldNumber = 2,
  };
  // required uint32 reportedPlayerId = 1;
  bool has_reportedplayerid() const;
  private:
  bool _internal_has_reportedplayerid() const;
  public:
  void clear_reportedplayerid();
  uint32_t reportedplayerid() const;
  void set_reportedplayerid(uint32_t value);
  private:
  uint32_t _internal_reportedplayerid() const;
  void _internal_set_reportedplayerid(uint32_t value);
  public:

  // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
  bool has_reportavatarresult() const;
  private:
  bool _internal_has_reportavatarresult() const;
  public:
  void clear_reportavatarresult();
  ::ReportAvatarAckMessage_ReportAvatarResult reportavatarresult() const;
  void set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value);
  private:
  ::ReportAvatarAckMessage_ReportAvatarResult _internal_reportavatarresult() const;
  void _internal_set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value);
  public:

  // @@protoc_insertion_point(class_scope:ReportAvatarAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t reportedplayerid_;
  int reportavatarresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ReportGameMessage) */ {
 public:
  inline ReportGameMessage() : ReportGameMessage(nullptr) {}
  ~ReportGameMessage() override;
  explicit constexpr ReportGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportGameMessage(const ReportGameMessage& from);
  ReportGameMessage(ReportGameMessage&& from) noexcept
    : ReportGameMessage() {
    *this = ::std::move(from);
  }

  inline ReportGameMessage& operator=(const ReportGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportGameMessage& operator=(ReportGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReportGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportGameMessage* internal_default_instance() {
    return reinterpret_cast<const ReportGameMessage*>(
               &_ReportGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(ReportGameMessage& a, ReportGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReportGameMessage& from);
  void MergeFrom(const ReportGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReportGameMessage";
  }
  protected:
  explicit ReportGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportedGameIdFieldNumber = 1,
  };
  // required uint32 reportedGameId = 1;
  bool has_reportedgameid() const;
  private:
  bool _internal_has_reportedgameid() const;
  public:
  void clear_reportedgameid();
  uint32_t reportedgameid() const;
  void set_reportedgameid(uint32_t value);
  private:
  uint32_t _internal_reportedgameid() const;
  void _internal_set_reportedgameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReportGameMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t reportedgameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportGameAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ReportGameAckMessage) */ {
 public:
  inline ReportGameAckMessage() : ReportGameAckMessage(nullptr) {}
  ~ReportGameAckMessage() override;
  explicit constexpr ReportGameAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportGameAckMessage(const ReportGameAckMessage& from);
  ReportGameAckMessage(ReportGameAckMessage&& from) noexcept
    : ReportGameAckMessage() {
    *this = ::std::move(from);
  }

  inline ReportGameAckMessage& operator=(const ReportGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportGameAckMessage& operator=(ReportGameAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReportGameAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportGameAckMessage* internal_default_instance() {
    return reinterpret_cast<const ReportGameAckMessage*>(
               &_ReportGameAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(ReportGameAckMessage& a, ReportGameAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportGameAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportGameAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportGameAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportGameAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReportGameAckMessage& from);
  void MergeFrom(const ReportGameAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportGameAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReportGameAckMessage";
  }
  protected:
  explicit ReportGameAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ReportGameAckMessage_ReportGameResult ReportGameResult;
  static constexpr ReportGameResult gameReportAccepted =
    ReportGameAckMessage_ReportGameResult_gameReportAccepted;
  static constexpr ReportGameResult gameReportDuplicate =
    ReportGameAckMessage_ReportGameResult_gameReportDuplicate;
  static constexpr ReportGameResult gameReportInvalid =
    ReportGameAckMessage_ReportGameResult_gameReportInvalid;
  static inline bool ReportGameResult_IsValid(int value) {
    return ReportGameAckMessage_ReportGameResult_IsValid(value);
  }
  static constexpr ReportGameResult ReportGameResult_MIN =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN;
  static constexpr ReportGameResult ReportGameResult_MAX =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX;
  static constexpr int ReportGameResult_ARRAYSIZE =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ReportGameResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReportGameResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReportGameResult_Name.");
    return ReportGameAckMessage_ReportGameResult_Name(enum_t_value);
  }
  static inline bool ReportGameResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReportGameResult* value) {
    return ReportGameAckMessage_ReportGameResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReportedGameIdFieldNumber = 1,
    kReportGameResultFieldNumber = 2,
  };
  // required uint32 reportedGameId = 1;
  bool has_reportedgameid() const;
  private:
  bool _internal_has_reportedgameid() const;
  public:
  void clear_reportedgameid();
  uint32_t reportedgameid() const;
  void set_reportedgameid(uint32_t value);
  private:
  uint32_t _internal_reportedgameid() const;
  void _internal_set_reportedgameid(uint32_t value);
  public:

  // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
  bool has_reportgameresult() const;
  private:
  bool _internal_has_reportgameresult() const;
  public:
  void clear_reportgameresult();
  ::ReportGameAckMessage_ReportGameResult reportgameresult() const;
  void set_reportgameresult(::ReportGameAckMessage_ReportGameResult value);
  private:
  ::ReportGameAckMessage_ReportGameResult _internal_reportgameresult() const;
  void _internal_set_reportgameresult(::ReportGameAckMessage_ReportGameResult value);
  public:

  // @@protoc_insertion_point(class_scope:ReportGameAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t reportedgameid_;
  int reportgameresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ErrorMessage) */ {
 public:
  inline ErrorMessage() : ErrorMessage(nullptr) {}
  ~ErrorMessage() override;
  explicit constexpr ErrorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorMessage(const ErrorMessage& from);
  ErrorMessage(ErrorMessage&& from) noexcept
    : ErrorMessage() {
    *this = ::std::move(from);
  }

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
               &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(ErrorMessage& a, ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ErrorMessage& from);
  void MergeFrom(const ErrorMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ErrorMessage";
  }
  protected:
  explicit ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ErrorMessage_ErrorReason ErrorReason;
  static constexpr ErrorReason custReserved =
    ErrorMessage_ErrorReason_custReserved;
  static constexpr ErrorReason initVersionNotSupported =
    ErrorMessage_ErrorReason_initVersionNotSupported;
  static constexpr ErrorReason initServerFull =
    ErrorMessage_ErrorReason_initServerFull;
  static constexpr ErrorReason initAuthFailure =
    ErrorMessage_ErrorReason_initAuthFailure;
  static constexpr ErrorReason initPlayerNameInUse =
    ErrorMessage_ErrorReason_initPlayerNameInUse;
  static constexpr ErrorReason initInvalidPlayerName =
    ErrorMessage_ErrorReason_initInvalidPlayerName;
  static constexpr ErrorReason initServerMaintenance =
    ErrorMessage_ErrorReason_initServerMaintenance;
  static constexpr ErrorReason initBlocked =
    ErrorMessage_ErrorReason_initBlocked;
  static constexpr ErrorReason avatarTooLarge =
    ErrorMessage_ErrorReason_avatarTooLarge;
  static constexpr ErrorReason invalidPacket =
    ErrorMessage_ErrorReason_invalidPacket;
  static constexpr ErrorReason invalidState =
    ErrorMessage_ErrorReason_invalidState;
  static constexpr ErrorReason kickedFromServer =
    ErrorMessage_ErrorReason_kickedFromServer;
  static constexpr ErrorReason bannedFromServer =
    ErrorMessage_ErrorReason_bannedFromServer;
  static constexpr ErrorReason blockedByServer =
    ErrorMessage_ErrorReason_blockedByServer;
  static constexpr ErrorReason sessionTimeout =
    ErrorMessage_ErrorReason_sessionTimeout;
  static inline bool ErrorReason_IsValid(int value) {
    return ErrorMessage_ErrorReason_IsValid(value);
  }
  static constexpr ErrorReason ErrorReason_MIN =
    ErrorMessage_ErrorReason_ErrorReason_MIN;
  static constexpr ErrorReason ErrorReason_MAX =
    ErrorMessage_ErrorReason_ErrorReason_MAX;
  static constexpr int ErrorReason_ARRAYSIZE =
    ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorReason_Name.");
    return ErrorMessage_ErrorReason_Name(enum_t_value);
  }
  static inline bool ErrorReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorReason* value) {
    return ErrorMessage_ErrorReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorReasonFieldNumber = 1,
  };
  // required .ErrorMessage.ErrorReason errorReason = 1;
  bool has_errorreason() const;
  private:
  bool _internal_has_errorreason() const;
  public:
  void clear_errorreason();
  ::ErrorMessage_ErrorReason errorreason() const;
  void set_errorreason(::ErrorMessage_ErrorReason value);
  private:
  ::ErrorMessage_ErrorReason _internal_errorreason() const;
  void _internal_set_errorreason(::ErrorMessage_ErrorReason value);
  public:

  // @@protoc_insertion_point(class_scope:ErrorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int errorreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminRemoveGameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AdminRemoveGameMessage) */ {
 public:
  inline AdminRemoveGameMessage() : AdminRemoveGameMessage(nullptr) {}
  ~AdminRemoveGameMessage() override;
  explicit constexpr AdminRemoveGameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminRemoveGameMessage(const AdminRemoveGameMessage& from);
  AdminRemoveGameMessage(AdminRemoveGameMessage&& from) noexcept
    : AdminRemoveGameMessage() {
    *this = ::std::move(from);
  }

  inline AdminRemoveGameMessage& operator=(const AdminRemoveGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminRemoveGameMessage& operator=(AdminRemoveGameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AdminRemoveGameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminRemoveGameMessage* internal_default_instance() {
    return reinterpret_cast<const AdminRemoveGameMessage*>(
               &_AdminRemoveGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(AdminRemoveGameMessage& a, AdminRemoveGameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminRemoveGameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminRemoveGameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminRemoveGameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminRemoveGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AdminRemoveGameMessage& from);
  void MergeFrom(const AdminRemoveGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminRemoveGameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminRemoveGameMessage";
  }
  protected:
  explicit AdminRemoveGameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoveGameIdFieldNumber = 1,
  };
  // required uint32 removeGameId = 1;
  bool has_removegameid() const;
  private:
  bool _internal_has_removegameid() const;
  public:
  void clear_removegameid();
  uint32_t removegameid() const;
  void set_removegameid(uint32_t value);
  private:
  uint32_t _internal_removegameid() const;
  void _internal_set_removegameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminRemoveGameMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t removegameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminRemoveGameAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AdminRemoveGameAckMessage) */ {
 public:
  inline AdminRemoveGameAckMessage() : AdminRemoveGameAckMessage(nullptr) {}
  ~AdminRemoveGameAckMessage() override;
  explicit constexpr AdminRemoveGameAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminRemoveGameAckMessage(const AdminRemoveGameAckMessage& from);
  AdminRemoveGameAckMessage(AdminRemoveGameAckMessage&& from) noexcept
    : AdminRemoveGameAckMessage() {
    *this = ::std::move(from);
  }

  inline AdminRemoveGameAckMessage& operator=(const AdminRemoveGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminRemoveGameAckMessage& operator=(AdminRemoveGameAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AdminRemoveGameAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminRemoveGameAckMessage* internal_default_instance() {
    return reinterpret_cast<const AdminRemoveGameAckMessage*>(
               &_AdminRemoveGameAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(AdminRemoveGameAckMessage& a, AdminRemoveGameAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminRemoveGameAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminRemoveGameAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminRemoveGameAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminRemoveGameAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AdminRemoveGameAckMessage& from);
  void MergeFrom(const AdminRemoveGameAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminRemoveGameAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminRemoveGameAckMessage";
  }
  protected:
  explicit AdminRemoveGameAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameResult;
  static constexpr AdminRemoveGameResult gameRemoveAccepted =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted;
  static constexpr AdminRemoveGameResult gameRemoveInvalid =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid;
  static inline bool AdminRemoveGameResult_IsValid(int value) {
    return AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(value);
  }
  static constexpr AdminRemoveGameResult AdminRemoveGameResult_MIN =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MIN;
  static constexpr AdminRemoveGameResult AdminRemoveGameResult_MAX =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX;
  static constexpr int AdminRemoveGameResult_ARRAYSIZE =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AdminRemoveGameResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdminRemoveGameResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdminRemoveGameResult_Name.");
    return AdminRemoveGameAckMessage_AdminRemoveGameResult_Name(enum_t_value);
  }
  static inline bool AdminRemoveGameResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AdminRemoveGameResult* value) {
    return AdminRemoveGameAckMessage_AdminRemoveGameResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRemoveGameIdFieldNumber = 1,
    kRemoveGameResultFieldNumber = 2,
  };
  // required uint32 removeGameId = 1;
  bool has_removegameid() const;
  private:
  bool _internal_has_removegameid() const;
  public:
  void clear_removegameid();
  uint32_t removegameid() const;
  void set_removegameid(uint32_t value);
  private:
  uint32_t _internal_removegameid() const;
  void _internal_set_removegameid(uint32_t value);
  public:

  // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
  bool has_removegameresult() const;
  private:
  bool _internal_has_removegameresult() const;
  public:
  void clear_removegameresult();
  ::AdminRemoveGameAckMessage_AdminRemoveGameResult removegameresult() const;
  void set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value);
  private:
  ::AdminRemoveGameAckMessage_AdminRemoveGameResult _internal_removegameresult() const;
  void _internal_set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value);
  public:

  // @@protoc_insertion_point(class_scope:AdminRemoveGameAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t removegameid_;
  int removegameresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminBanPlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AdminBanPlayerMessage) */ {
 public:
  inline AdminBanPlayerMessage() : AdminBanPlayerMessage(nullptr) {}
  ~AdminBanPlayerMessage() override;
  explicit constexpr AdminBanPlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminBanPlayerMessage(const AdminBanPlayerMessage& from);
  AdminBanPlayerMessage(AdminBanPlayerMessage&& from) noexcept
    : AdminBanPlayerMessage() {
    *this = ::std::move(from);
  }

  inline AdminBanPlayerMessage& operator=(const AdminBanPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminBanPlayerMessage& operator=(AdminBanPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AdminBanPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminBanPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const AdminBanPlayerMessage*>(
               &_AdminBanPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(AdminBanPlayerMessage& a, AdminBanPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminBanPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminBanPlayerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminBanPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminBanPlayerMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AdminBanPlayerMessage& from);
  void MergeFrom(const AdminBanPlayerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminBanPlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminBanPlayerMessage";
  }
  protected:
  explicit AdminBanPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBanPlayerIdFieldNumber = 1,
  };
  // required uint32 banPlayerId = 1;
  bool has_banplayerid() const;
  private:
  bool _internal_has_banplayerid() const;
  public:
  void clear_banplayerid();
  uint32_t banplayerid() const;
  void set_banplayerid(uint32_t value);
  private:
  uint32_t _internal_banplayerid() const;
  void _internal_set_banplayerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminBanPlayerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t banplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminBanPlayerAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:AdminBanPlayerAckMessage) */ {
 public:
  inline AdminBanPlayerAckMessage() : AdminBanPlayerAckMessage(nullptr) {}
  ~AdminBanPlayerAckMessage() override;
  explicit constexpr AdminBanPlayerAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminBanPlayerAckMessage(const AdminBanPlayerAckMessage& from);
  AdminBanPlayerAckMessage(AdminBanPlayerAckMessage&& from) noexcept
    : AdminBanPlayerAckMessage() {
    *this = ::std::move(from);
  }

  inline AdminBanPlayerAckMessage& operator=(const AdminBanPlayerAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminBanPlayerAckMessage& operator=(AdminBanPlayerAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AdminBanPlayerAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminBanPlayerAckMessage* internal_default_instance() {
    return reinterpret_cast<const AdminBanPlayerAckMessage*>(
               &_AdminBanPlayerAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(AdminBanPlayerAckMessage& a, AdminBanPlayerAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminBanPlayerAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminBanPlayerAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminBanPlayerAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminBanPlayerAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AdminBanPlayerAckMessage& from);
  void MergeFrom(const AdminBanPlayerAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminBanPlayerAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminBanPlayerAckMessage";
  }
  protected:
  explicit AdminBanPlayerAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerResult;
  static constexpr AdminBanPlayerResult banPlayerAccepted =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted;
  static constexpr AdminBanPlayerResult banPlayerPending =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerPending;
  static constexpr AdminBanPlayerResult banPlayerNoDB =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerNoDB;
  static constexpr AdminBanPlayerResult banPlayerDBError =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerDBError;
  static constexpr AdminBanPlayerResult banPlayerInvalid =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid;
  static inline bool AdminBanPlayerResult_IsValid(int value) {
    return AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(value);
  }
  static constexpr AdminBanPlayerResult AdminBanPlayerResult_MIN =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MIN;
  static constexpr AdminBanPlayerResult AdminBanPlayerResult_MAX =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX;
  static constexpr int AdminBanPlayerResult_ARRAYSIZE =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AdminBanPlayerResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdminBanPlayerResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdminBanPlayerResult_Name.");
    return AdminBanPlayerAckMessage_AdminBanPlayerResult_Name(enum_t_value);
  }
  static inline bool AdminBanPlayerResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AdminBanPlayerResult* value) {
    return AdminBanPlayerAckMessage_AdminBanPlayerResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBanPlayerIdFieldNumber = 1,
    kBanPlayerResultFieldNumber = 2,
  };
  // required uint32 banPlayerId = 1;
  bool has_banplayerid() const;
  private:
  bool _internal_has_banplayerid() const;
  public:
  void clear_banplayerid();
  uint32_t banplayerid() const;
  void set_banplayerid(uint32_t value);
  private:
  uint32_t _internal_banplayerid() const;
  void _internal_set_banplayerid(uint32_t value);
  public:

  // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
  bool has_banplayerresult() const;
  private:
  bool _internal_has_banplayerresult() const;
  public:
  void clear_banplayerresult();
  ::AdminBanPlayerAckMessage_AdminBanPlayerResult banplayerresult() const;
  void set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value);
  private:
  ::AdminBanPlayerAckMessage_AdminBanPlayerResult _internal_banplayerresult() const;
  void _internal_set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value);
  public:

  // @@protoc_insertion_point(class_scope:AdminBanPlayerAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t banplayerid_;
  int banplayerresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PokerTHMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PokerTHMessage) */ {
 public:
  inline PokerTHMessage() : PokerTHMessage(nullptr) {}
  ~PokerTHMessage() override;
  explicit constexpr PokerTHMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PokerTHMessage(const PokerTHMessage& from);
  PokerTHMessage(PokerTHMessage&& from) noexcept
    : PokerTHMessage() {
    *this = ::std::move(from);
  }

  inline PokerTHMessage& operator=(const PokerTHMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PokerTHMessage& operator=(PokerTHMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PokerTHMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PokerTHMessage* internal_default_instance() {
    return reinterpret_cast<const PokerTHMessage*>(
               &_PokerTHMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(PokerTHMessage& a, PokerTHMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PokerTHMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PokerTHMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PokerTHMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PokerTHMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PokerTHMessage& from);
  void MergeFrom(const PokerTHMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PokerTHMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerTHMessage";
  }
  protected:
  explicit PokerTHMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PokerTHMessage_PokerTHMessageType PokerTHMessageType;
  static constexpr PokerTHMessageType Type_AnnounceMessage =
    PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
  static constexpr PokerTHMessageType Type_InitMessage =
    PokerTHMessage_PokerTHMessageType_Type_InitMessage;
  static constexpr PokerTHMessageType Type_AuthServerChallengeMessage =
    PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage;
  static constexpr PokerTHMessageType Type_AuthClientResponseMessage =
    PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage;
  static constexpr PokerTHMessageType Type_AuthServerVerificationMessage =
    PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage;
  static constexpr PokerTHMessageType Type_InitAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_InitAckMessage;
  static constexpr PokerTHMessageType Type_AvatarRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage;
  static constexpr PokerTHMessageType Type_AvatarHeaderMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage;
  static constexpr PokerTHMessageType Type_AvatarDataMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage;
  static constexpr PokerTHMessageType Type_AvatarEndMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage;
  static constexpr PokerTHMessageType Type_UnknownAvatarMessage =
    PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage;
  static constexpr PokerTHMessageType Type_PlayerListMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage;
  static constexpr PokerTHMessageType Type_GameListNewMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage;
  static constexpr PokerTHMessageType Type_GameListUpdateMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage;
  static constexpr PokerTHMessageType Type_GameListPlayerJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage;
  static constexpr PokerTHMessageType Type_GameListPlayerLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage;
  static constexpr PokerTHMessageType Type_GameListAdminChangedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage;
  static constexpr PokerTHMessageType Type_PlayerInfoRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage;
  static constexpr PokerTHMessageType Type_PlayerInfoReplyMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage;
  static constexpr PokerTHMessageType Type_SubscriptionRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage;
  static constexpr PokerTHMessageType Type_JoinExistingGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage;
  static constexpr PokerTHMessageType Type_JoinNewGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage;
  static constexpr PokerTHMessageType Type_RejoinExistingGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage;
  static constexpr PokerTHMessageType Type_JoinGameAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage;
  static constexpr PokerTHMessageType Type_JoinGameFailedMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage;
  static constexpr PokerTHMessageType Type_GamePlayerJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage;
  static constexpr PokerTHMessageType Type_GamePlayerLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage;
  static constexpr PokerTHMessageType Type_GameAdminChangedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage;
  static constexpr PokerTHMessageType Type_RemovedFromGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage;
  static constexpr PokerTHMessageType Type_KickPlayerRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage;
  static constexpr PokerTHMessageType Type_LeaveGameRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage;
  static constexpr PokerTHMessageType Type_InvitePlayerToGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage;
  static constexpr PokerTHMessageType Type_InviteNotifyMessage =
    PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage;
  static constexpr PokerTHMessageType Type_RejectGameInvitationMessage =
    PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage;
  static constexpr PokerTHMessageType Type_RejectInvNotifyMessage =
    PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage;
  static constexpr PokerTHMessageType Type_StartEventMessage =
    PokerTHMessage_PokerTHMessageType_Type_StartEventMessage;
  static constexpr PokerTHMessageType Type_StartEventAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage;
  static constexpr PokerTHMessageType Type_GameStartInitialMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage;
  static constexpr PokerTHMessageType Type_GameStartRejoinMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage;
  static constexpr PokerTHMessageType Type_HandStartMessage =
    PokerTHMessage_PokerTHMessageType_Type_HandStartMessage;
  static constexpr PokerTHMessageType Type_PlayersTurnMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage;
  static constexpr PokerTHMessageType Type_MyActionRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage;
  static constexpr PokerTHMessageType Type_YourActionRejectedMessage =
    PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage;
  static constexpr PokerTHMessageType Type_PlayersActionDoneMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage;
  static constexpr PokerTHMessageType Type_DealFlopCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage;
  static constexpr PokerTHMessageType Type_DealTurnCardMessage =
    PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage;
  static constexpr PokerTHMessageType Type_DealRiverCardMessage =
    PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage;
  static constexpr PokerTHMessageType Type_AllInShowCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage;
  static constexpr PokerTHMessageType Type_EndOfHandShowCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage;
  static constexpr PokerTHMessageType Type_EndOfHandHideCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage;
  static constexpr PokerTHMessageType Type_ShowMyCardsRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage;
  static constexpr PokerTHMessageType Type_AfterHandShowCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage;
  static constexpr PokerTHMessageType Type_EndOfGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage;
  static constexpr PokerTHMessageType Type_PlayerIdChangedMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage;
  static constexpr PokerTHMessageType Type_AskKickPlayerMessage =
    PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage;
  static constexpr PokerTHMessageType Type_AskKickDeniedMessage =
    PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage;
  static constexpr PokerTHMessageType Type_StartKickPetitionMessage =
    PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage;
  static constexpr PokerTHMessageType Type_VoteKickRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage;
  static constexpr PokerTHMessageType Type_VoteKickReplyMessage =
    PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage;
  static constexpr PokerTHMessageType Type_KickPetitionUpdateMessage =
    PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage;
  static constexpr PokerTHMessageType Type_EndKickPetitionMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage;
  static constexpr PokerTHMessageType Type_StatisticsMessage =
    PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage;
  static constexpr PokerTHMessageType Type_ChatRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage;
  static constexpr PokerTHMessageType Type_ChatMessage =
    PokerTHMessage_PokerTHMessageType_Type_ChatMessage;
  static constexpr PokerTHMessageType Type_ChatRejectMessage =
    PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage;
  static constexpr PokerTHMessageType Type_DialogMessage =
    PokerTHMessage_PokerTHMessageType_Type_DialogMessage;
  static constexpr PokerTHMessageType Type_TimeoutWarningMessage =
    PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage;
  static constexpr PokerTHMessageType Type_ResetTimeoutMessage =
    PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage;
  static constexpr PokerTHMessageType Type_ReportAvatarMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage;
  static constexpr PokerTHMessageType Type_ReportAvatarAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage;
  static constexpr PokerTHMessageType Type_ReportGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage;
  static constexpr PokerTHMessageType Type_ReportGameAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage;
  static constexpr PokerTHMessageType Type_ErrorMessage =
    PokerTHMessage_PokerTHMessageType_Type_ErrorMessage;
  static constexpr PokerTHMessageType Type_AdminRemoveGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameMessage;
  static constexpr PokerTHMessageType Type_AdminRemoveGameAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameAckMessage;
  static constexpr PokerTHMessageType Type_AdminBanPlayerMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerMessage;
  static constexpr PokerTHMessageType Type_AdminBanPlayerAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerAckMessage;
  static constexpr PokerTHMessageType Type_GameListSpectatorJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorJoinedMessage;
  static constexpr PokerTHMessageType Type_GameListSpectatorLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorLeftMessage;
  static constexpr PokerTHMessageType Type_GameSpectatorJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameSpectatorJoinedMessage;
  static constexpr PokerTHMessageType Type_GameSpectatorLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage;
  static inline bool PokerTHMessageType_IsValid(int value) {
    return PokerTHMessage_PokerTHMessageType_IsValid(value);
  }
  static constexpr PokerTHMessageType PokerTHMessageType_MIN =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN;
  static constexpr PokerTHMessageType PokerTHMessageType_MAX =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX;
  static constexpr int PokerTHMessageType_ARRAYSIZE =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PokerTHMessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PokerTHMessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PokerTHMessageType_Name.");
    return PokerTHMessage_PokerTHMessageType_Name(enum_t_value);
  }
  static inline bool PokerTHMessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PokerTHMessageType* value) {
    return PokerTHMessage_PokerTHMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAnnounceMessageFieldNumber = 2,
    kInitMessageFieldNumber = 3,
    kAuthServerChallengeMessageFieldNumber = 4,
    kAuthClientResponseMessageFieldNumber = 5,
    kAuthServerVerificationMessageFieldNumber = 6,
    kInitAckMessageFieldNumber = 7,
    kAvatarRequestMessageFieldNumber = 8,
    kAvatarHeaderMessageFieldNumber = 9,
    kAvatarDataMessageFieldNumber = 10,
    kAvatarEndMessageFieldNumber = 11,
    kUnknownAvatarMessageFieldNumber = 12,
    kPlayerListMessageFieldNumber = 13,
    kGameListNewMessageFieldNumber = 14,
    kGameListUpdateMessageFieldNumber = 15,
    kGameListPlayerJoinedMessageFieldNumber = 16,
    kGameListPlayerLeftMessageFieldNumber = 17,
    kGameListAdminChangedMessageFieldNumber = 18,
    kPlayerInfoRequestMessageFieldNumber = 19,
    kPlayerInfoReplyMessageFieldNumber = 20,
    kSubscriptionRequestMessageFieldNumber = 21,
    kJoinExistingGameMessageFieldNumber = 22,
    kJoinNewGameMessageFieldNumber = 23,
    kRejoinExistingGameMessageFieldNumber = 24,
    kJoinGameAckMessageFieldNumber = 25,
    kJoinGameFailedMessageFieldNumber = 26,
    kGamePlayerJoinedMessageFieldNumber = 27,
    kGamePlayerLeftMessageFieldNumber = 28,
    kGameAdminChangedMessageFieldNumber = 29,
    kRemovedFromGameMessageFieldNumber = 30,
    kKickPlayerRequestMessageFieldNumber = 31,
    kLeaveGameRequestMessageFieldNumber = 32,
    kInvitePlayerToGameMessageFieldNumber = 33,
    kInviteNotifyMessageFieldNumber = 34,
    kRejectGameInvitationMessageFieldNumber = 35,
    kRejectInvNotifyMessageFieldNumber = 36,
    kStartEventMessageFieldNumber = 37,
    kStartEventAckMessageFieldNumber = 38,
    kGameStartInitialMessageFieldNumber = 39,
    kGameStartRejoinMessageFieldNumber = 40,
    kHandStartMessageFieldNumber = 41,
    kPlayersTurnMessageFieldNumber = 42,
    kMyActionRequestMessageFieldNumber = 43,
    kYourActionRejectedMessageFieldNumber = 44,
    kPlayersActionDoneMessageFieldNumber = 45,
    kDealFlopCardsMessageFieldNumber = 46,
    kDealTurnCardMessageFieldNumber = 47,
    kDealRiverCardMessageFieldNumber = 48,
    kAllInShowCardsMessageFieldNumber = 49,
    kEndOfHandShowCardsMessageFieldNumber = 50,
    kEndOfHandHideCardsMessageFieldNumber = 51,
    kShowMyCardsRequestMessageFieldNumber = 52,
    kAfterHandShowCardsMessageFieldNumber = 53,
    kEndOfGameMessageFieldNumber = 54,
    kPlayerIdChangedMessageFieldNumber = 55,
    kAskKickPlayerMessageFieldNumber = 56,
    kAskKickDeniedMessageFieldNumber = 57,
    kStartKickPetitionMessageFieldNumber = 58,
    kVoteKickRequestMessageFieldNumber = 59,
    kVoteKickReplyMessageFieldNumber = 60,
    kKickPetitionUpdateMessageFieldNumber = 61,
    kEndKickPetitionMessageFieldNumber = 62,
    kStatisticsMessageFieldNumber = 63,
    kChatRequestMessageFieldNumber = 64,
    kChatMessageFieldNumber = 65,
    kChatRejectMessageFieldNumber = 66,
    kDialogMessageFieldNumber = 67,
    kTimeoutWarningMessageFieldNumber = 68,
    kResetTimeoutMessageFieldNumber = 69,
    kReportAvatarMessageFieldNumber = 70,
    kReportAvatarAckMessageFieldNumber = 71,
    kReportGameMessageFieldNumber = 72,
    kReportGameAckMessageFieldNumber = 73,
    kErrorMessageFieldNumber = 74,
    kAdminRemoveGameMessageFieldNumber = 75,
    kAdminRemoveGameAckMessageFieldNumber = 76,
    kAdminBanPlayerMessageFieldNumber = 77,
    kAdminBanPlayerAckMessageFieldNumber = 78,
    kGameListSpectatorJoinedMessageFieldNumber = 79,
    kGameListSpectatorLeftMessageFieldNumber = 80,
    kGameSpectatorJoinedMessageFieldNumber = 81,
    kGameSpectatorLeftMessageFieldNumber = 82,
    kMessageTypeFieldNumber = 1,
  };
  // optional .AnnounceMessage announceMessage = 2;
  bool has_announcemessage() const;
  private:
  bool _internal_has_announcemessage() const;
  public:
  void clear_announcemessage();
  const ::AnnounceMessage& announcemessage() const;
  PROTOBUF_NODISCARD ::AnnounceMessage* release_announcemessage();
  ::AnnounceMessage* mutable_announcemessage();
  void set_allocated_announcemessage(::AnnounceMessage* announcemessage);
  private:
  const ::AnnounceMessage& _internal_announcemessage() const;
  ::AnnounceMessage* _internal_mutable_announcemessage();
  public:
  void unsafe_arena_set_allocated_announcemessage(
      ::AnnounceMessage* announcemessage);
  ::AnnounceMessage* unsafe_arena_release_announcemessage();

  // optional .InitMessage initMessage = 3;
  bool has_initmessage() const;
  private:
  bool _internal_has_initmessage() const;
  public:
  void clear_initmessage();
  const ::InitMessage& initmessage() const;
  PROTOBUF_NODISCARD ::InitMessage* release_initmessage();
  ::InitMessage* mutable_initmessage();
  void set_allocated_initmessage(::InitMessage* initmessage);
  private:
  const ::InitMessage& _internal_initmessage() const;
  ::InitMessage* _internal_mutable_initmessage();
  public:
  void unsafe_arena_set_allocated_initmessage(
      ::InitMessage* initmessage);
  ::InitMessage* unsafe_arena_release_initmessage();

  // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
  bool has_authserverchallengemessage() const;
  private:
  bool _internal_has_authserverchallengemessage() const;
  public:
  void clear_authserverchallengemessage();
  const ::AuthServerChallengeMessage& authserverchallengemessage() const;
  PROTOBUF_NODISCARD ::AuthServerChallengeMessage* release_authserverchallengemessage();
  ::AuthServerChallengeMessage* mutable_authserverchallengemessage();
  void set_allocated_authserverchallengemessage(::AuthServerChallengeMessage* authserverchallengemessage);
  private:
  const ::AuthServerChallengeMessage& _internal_authserverchallengemessage() const;
  ::AuthServerChallengeMessage* _internal_mutable_authserverchallengemessage();
  public:
  void unsafe_arena_set_allocated_authserverchallengemessage(
      ::AuthServerChallengeMessage* authserverchallengemessage);
  ::AuthServerChallengeMessage* unsafe_arena_release_authserverchallengemessage();

  // optional .AuthClientResponseMessage authClientResponseMessage = 5;
  bool has_authclientresponsemessage() const;
  private:
  bool _internal_has_authclientresponsemessage() const;
  public:
  void clear_authclientresponsemessage();
  const ::AuthClientResponseMessage& authclientresponsemessage() const;
  PROTOBUF_NODISCARD ::AuthClientResponseMessage* release_authclientresponsemessage();
  ::AuthClientResponseMessage* mutable_authclientresponsemessage();
  void set_allocated_authclientresponsemessage(::AuthClientResponseMessage* authclientresponsemessage);
  private:
  const ::AuthClientResponseMessage& _internal_authclientresponsemessage() const;
  ::AuthClientResponseMessage* _internal_mutable_authclientresponsemessage();
  public:
  void unsafe_arena_set_allocated_authclientresponsemessage(
      ::AuthClientResponseMessage* authclientresponsemessage);
  ::AuthClientResponseMessage* unsafe_arena_release_authclientresponsemessage();

  // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
  bool has_authserververificationmessage() const;
  private:
  bool _internal_has_authserververificationmessage() const;
  public:
  void clear_authserververificationmessage();
  const ::AuthServerVerificationMessage& authserververificationmessage() const;
  PROTOBUF_NODISCARD ::AuthServerVerificationMessage* release_authserververificationmessage();
  ::AuthServerVerificationMessage* mutable_authserververificationmessage();
  void set_allocated_authserververificationmessage(::AuthServerVerificationMessage* authserververificationmessage);
  private:
  const ::AuthServerVerificationMessage& _internal_authserververificationmessage() const;
  ::AuthServerVerificationMessage* _internal_mutable_authserververificationmessage();
  public:
  void unsafe_arena_set_allocated_authserververificationmessage(
      ::AuthServerVerificationMessage* authserververificationmessage);
  ::AuthServerVerificationMessage* unsafe_arena_release_authserververificationmessage();

  // optional .InitAckMessage initAckMessage = 7;
  bool has_initackmessage() const;
  private:
  bool _internal_has_initackmessage() const;
  public:
  void clear_initackmessage();
  const ::InitAckMessage& initackmessage() const;
  PROTOBUF_NODISCARD ::InitAckMessage* release_initackmessage();
  ::InitAckMessage* mutable_initackmessage();
  void set_allocated_initackmessage(::InitAckMessage* initackmessage);
  private:
  const ::InitAckMessage& _internal_initackmessage() const;
  ::InitAckMessage* _internal_mutable_initackmessage();
  public:
  void unsafe_arena_set_allocated_initackmessage(
      ::InitAckMessage* initackmessage);
  ::InitAckMessage* unsafe_arena_release_initackmessage();

  // optional .AvatarRequestMessage avatarRequestMessage = 8;
  bool has_avatarrequestmessage() const;
  private:
  bool _internal_has_avatarrequestmessage() const;
  public:
  void clear_avatarrequestmessage();
  const ::AvatarRequestMessage& avatarrequestmessage() const;
  PROTOBUF_NODISCARD ::AvatarRequestMessage* release_avatarrequestmessage();
  ::AvatarRequestMessage* mutable_avatarrequestmessage();
  void set_allocated_avatarrequestmessage(::AvatarRequestMessage* avatarrequestmessage);
  private:
  const ::AvatarRequestMessage& _internal_avatarrequestmessage() const;
  ::AvatarRequestMessage* _internal_mutable_avatarrequestmessage();
  public:
  void unsafe_arena_set_allocated_avatarrequestmessage(
      ::AvatarRequestMessage* avatarrequestmessage);
  ::AvatarRequestMessage* unsafe_arena_release_avatarrequestmessage();

  // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
  bool has_avatarheadermessage() const;
  private:
  bool _internal_has_avatarheadermessage() const;
  public:
  void clear_avatarheadermessage();
  const ::AvatarHeaderMessage& avatarheadermessage() const;
  PROTOBUF_NODISCARD ::AvatarHeaderMessage* release_avatarheadermessage();
  ::AvatarHeaderMessage* mutable_avatarheadermessage();
  void set_allocated_avatarheadermessage(::AvatarHeaderMessage* avatarheadermessage);
  private:
  const ::AvatarHeaderMessage& _internal_avatarheadermessage() const;
  ::AvatarHeaderMessage* _internal_mutable_avatarheadermessage();
  public:
  void unsafe_arena_set_allocated_avatarheadermessage(
      ::AvatarHeaderMessage* avatarheadermessage);
  ::AvatarHeaderMessage* unsafe_arena_release_avatarheadermessage();

  // optional .AvatarDataMessage avatarDataMessage = 10;
  bool has_avatardatamessage() const;
  private:
  bool _internal_has_avatardatamessage() const;
  public:
  void clear_avatardatamessage();
  const ::AvatarDataMessage& avatardatamessage() const;
  PROTOBUF_NODISCARD ::AvatarDataMessage* release_avatardatamessage();
  ::AvatarDataMessage* mutable_avatardatamessage();
  void set_allocated_avatardatamessage(::AvatarDataMessage* avatardatamessage);
  private:
  const ::AvatarDataMessage& _internal_avatardatamessage() const;
  ::AvatarDataMessage* _internal_mutable_avatardatamessage();
  public:
  void unsafe_arena_set_allocated_avatardatamessage(
      ::AvatarDataMessage* avatardatamessage);
  ::AvatarDataMessage* unsafe_arena_release_avatardatamessage();

  // optional .AvatarEndMessage avatarEndMessage = 11;
  bool has_avatarendmessage() const;
  private:
  bool _internal_has_avatarendmessage() const;
  public:
  void clear_avatarendmessage();
  const ::AvatarEndMessage& avatarendmessage() const;
  PROTOBUF_NODISCARD ::AvatarEndMessage* release_avatarendmessage();
  ::AvatarEndMessage* mutable_avatarendmessage();
  void set_allocated_avatarendmessage(::AvatarEndMessage* avatarendmessage);
  private:
  const ::AvatarEndMessage& _internal_avatarendmessage() const;
  ::AvatarEndMessage* _internal_mutable_avatarendmessage();
  public:
  void unsafe_arena_set_allocated_avatarendmessage(
      ::AvatarEndMessage* avatarendmessage);
  ::AvatarEndMessage* unsafe_arena_release_avatarendmessage();

  // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
  bool has_unknownavatarmessage() const;
  private:
  bool _internal_has_unknownavatarmessage() const;
  public:
  void clear_unknownavatarmessage();
  const ::UnknownAvatarMessage& unknownavatarmessage() const;
  PROTOBUF_NODISCARD ::UnknownAvatarMessage* release_unknownavatarmessage();
  ::UnknownAvatarMessage* mutable_unknownavatarmessage();
  void set_allocated_unknownavatarmessage(::UnknownAvatarMessage* unknownavatarmessage);
  private:
  const ::UnknownAvatarMessage& _internal_unknownavatarmessage() const;
  ::UnknownAvatarMessage* _internal_mutable_unknownavatarmessage();
  public:
  void unsafe_arena_set_allocated_unknownavatarmessage(
      ::UnknownAvatarMessage* unknownavatarmessage);
  ::UnknownAvatarMessage* unsafe_arena_release_unknownavatarmessage();

  // optional .PlayerListMessage playerListMessage = 13;
  bool has_playerlistmessage() const;
  private:
  bool _internal_has_playerlistmessage() const;
  public:
  void clear_playerlistmessage();
  const ::PlayerListMessage& playerlistmessage() const;
  PROTOBUF_NODISCARD ::PlayerListMessage* release_playerlistmessage();
  ::PlayerListMessage* mutable_playerlistmessage();
  void set_allocated_playerlistmessage(::PlayerListMessage* playerlistmessage);
  private:
  const ::PlayerListMessage& _internal_playerlistmessage() const;
  ::PlayerListMessage* _internal_mutable_playerlistmessage();
  public:
  void unsafe_arena_set_allocated_playerlistmessage(
      ::PlayerListMessage* playerlistmessage);
  ::PlayerListMessage* unsafe_arena_release_playerlistmessage();

  // optional .GameListNewMessage gameListNewMessage = 14;
  bool has_gamelistnewmessage() const;
  private:
  bool _internal_has_gamelistnewmessage() const;
  public:
  void clear_gamelistnewmessage();
  const ::GameListNewMessage& gamelistnewmessage() const;
  PROTOBUF_NODISCARD ::GameListNewMessage* release_gamelistnewmessage();
  ::GameListNewMessage* mutable_gamelistnewmessage();
  void set_allocated_gamelistnewmessage(::GameListNewMessage* gamelistnewmessage);
  private:
  const ::GameListNewMessage& _internal_gamelistnewmessage() const;
  ::GameListNewMessage* _internal_mutable_gamelistnewmessage();
  public:
  void unsafe_arena_set_allocated_gamelistnewmessage(
      ::GameListNewMessage* gamelistnewmessage);
  ::GameListNewMessage* unsafe_arena_release_gamelistnewmessage();

  // optional .GameListUpdateMessage gameListUpdateMessage = 15;
  bool has_gamelistupdatemessage() const;
  private:
  bool _internal_has_gamelistupdatemessage() const;
  public:
  void clear_gamelistupdatemessage();
  const ::GameListUpdateMessage& gamelistupdatemessage() const;
  PROTOBUF_NODISCARD ::GameListUpdateMessage* release_gamelistupdatemessage();
  ::GameListUpdateMessage* mutable_gamelistupdatemessage();
  void set_allocated_gamelistupdatemessage(::GameListUpdateMessage* gamelistupdatemessage);
  private:
  const ::GameListUpdateMessage& _internal_gamelistupdatemessage() const;
  ::GameListUpdateMessage* _internal_mutable_gamelistupdatemessage();
  public:
  void unsafe_arena_set_allocated_gamelistupdatemessage(
      ::GameListUpdateMessage* gamelistupdatemessage);
  ::GameListUpdateMessage* unsafe_arena_release_gamelistupdatemessage();

  // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
  bool has_gamelistplayerjoinedmessage() const;
  private:
  bool _internal_has_gamelistplayerjoinedmessage() const;
  public:
  void clear_gamelistplayerjoinedmessage();
  const ::GameListPlayerJoinedMessage& gamelistplayerjoinedmessage() const;
  PROTOBUF_NODISCARD ::GameListPlayerJoinedMessage* release_gamelistplayerjoinedmessage();
  ::GameListPlayerJoinedMessage* mutable_gamelistplayerjoinedmessage();
  void set_allocated_gamelistplayerjoinedmessage(::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage);
  private:
  const ::GameListPlayerJoinedMessage& _internal_gamelistplayerjoinedmessage() const;
  ::GameListPlayerJoinedMessage* _internal_mutable_gamelistplayerjoinedmessage();
  public:
  void unsafe_arena_set_allocated_gamelistplayerjoinedmessage(
      ::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage);
  ::GameListPlayerJoinedMessage* unsafe_arena_release_gamelistplayerjoinedmessage();

  // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
  bool has_gamelistplayerleftmessage() const;
  private:
  bool _internal_has_gamelistplayerleftmessage() const;
  public:
  void clear_gamelistplayerleftmessage();
  const ::GameListPlayerLeftMessage& gamelistplayerleftmessage() const;
  PROTOBUF_NODISCARD ::GameListPlayerLeftMessage* release_gamelistplayerleftmessage();
  ::GameListPlayerLeftMessage* mutable_gamelistplayerleftmessage();
  void set_allocated_gamelistplayerleftmessage(::GameListPlayerLeftMessage* gamelistplayerleftmessage);
  private:
  const ::GameListPlayerLeftMessage& _internal_gamelistplayerleftmessage() const;
  ::GameListPlayerLeftMessage* _internal_mutable_gamelistplayerleftmessage();
  public:
  void unsafe_arena_set_allocated_gamelistplayerleftmessage(
      ::GameListPlayerLeftMessage* gamelistplayerleftmessage);
  ::GameListPlayerLeftMessage* unsafe_arena_release_gamelistplayerleftmessage();

  // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
  bool has_gamelistadminchangedmessage() const;
  private:
  bool _internal_has_gamelistadminchangedmessage() const;
  public:
  void clear_gamelistadminchangedmessage();
  const ::GameListAdminChangedMessage& gamelistadminchangedmessage() const;
  PROTOBUF_NODISCARD ::GameListAdminChangedMessage* release_gamelistadminchangedmessage();
  ::GameListAdminChangedMessage* mutable_gamelistadminchangedmessage();
  void set_allocated_gamelistadminchangedmessage(::GameListAdminChangedMessage* gamelistadminchangedmessage);
  private:
  const ::GameListAdminChangedMessage& _internal_gamelistadminchangedmessage() const;
  ::GameListAdminChangedMessage* _internal_mutable_gamelistadminchangedmessage();
  public:
  void unsafe_arena_set_allocated_gamelistadminchangedmessage(
      ::GameListAdminChangedMessage* gamelistadminchangedmessage);
  ::GameListAdminChangedMessage* unsafe_arena_release_gamelistadminchangedmessage();

  // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
  bool has_playerinforequestmessage() const;
  private:
  bool _internal_has_playerinforequestmessage() const;
  public:
  void clear_playerinforequestmessage();
  const ::PlayerInfoRequestMessage& playerinforequestmessage() const;
  PROTOBUF_NODISCARD ::PlayerInfoRequestMessage* release_playerinforequestmessage();
  ::PlayerInfoRequestMessage* mutable_playerinforequestmessage();
  void set_allocated_playerinforequestmessage(::PlayerInfoRequestMessage* playerinforequestmessage);
  private:
  const ::PlayerInfoRequestMessage& _internal_playerinforequestmessage() const;
  ::PlayerInfoRequestMessage* _internal_mutable_playerinforequestmessage();
  public:
  void unsafe_arena_set_allocated_playerinforequestmessage(
      ::PlayerInfoRequestMessage* playerinforequestmessage);
  ::PlayerInfoRequestMessage* unsafe_arena_release_playerinforequestmessage();

  // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
  bool has_playerinforeplymessage() const;
  private:
  bool _internal_has_playerinforeplymessage() const;
  public:
  void clear_playerinforeplymessage();
  const ::PlayerInfoReplyMessage& playerinforeplymessage() const;
  PROTOBUF_NODISCARD ::PlayerInfoReplyMessage* release_playerinforeplymessage();
  ::PlayerInfoReplyMessage* mutable_playerinforeplymessage();
  void set_allocated_playerinforeplymessage(::PlayerInfoReplyMessage* playerinforeplymessage);
  private:
  const ::PlayerInfoReplyMessage& _internal_playerinforeplymessage() const;
  ::PlayerInfoReplyMessage* _internal_mutable_playerinforeplymessage();
  public:
  void unsafe_arena_set_allocated_playerinforeplymessage(
      ::PlayerInfoReplyMessage* playerinforeplymessage);
  ::PlayerInfoReplyMessage* unsafe_arena_release_playerinforeplymessage();

  // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
  bool has_subscriptionrequestmessage() const;
  private:
  bool _internal_has_subscriptionrequestmessage() const;
  public:
  void clear_subscriptionrequestmessage();
  const ::SubscriptionRequestMessage& subscriptionrequestmessage() const;
  PROTOBUF_NODISCARD ::SubscriptionRequestMessage* release_subscriptionrequestmessage();
  ::SubscriptionRequestMessage* mutable_subscriptionrequestmessage();
  void set_allocated_subscriptionrequestmessage(::SubscriptionRequestMessage* subscriptionrequestmessage);
  private:
  const ::SubscriptionRequestMessage& _internal_subscriptionrequestmessage() const;
  ::SubscriptionRequestMessage* _internal_mutable_subscriptionrequestmessage();
  public:
  void unsafe_arena_set_allocated_subscriptionrequestmessage(
      ::SubscriptionRequestMessage* subscriptionrequestmessage);
  ::SubscriptionRequestMessage* unsafe_arena_release_subscriptionrequestmessage();

  // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
  bool has_joinexistinggamemessage() const;
  private:
  bool _internal_has_joinexistinggamemessage() const;
  public:
  void clear_joinexistinggamemessage();
  const ::JoinExistingGameMessage& joinexistinggamemessage() const;
  PROTOBUF_NODISCARD ::JoinExistingGameMessage* release_joinexistinggamemessage();
  ::JoinExistingGameMessage* mutable_joinexistinggamemessage();
  void set_allocated_joinexistinggamemessage(::JoinExistingGameMessage* joinexistinggamemessage);
  private:
  const ::JoinExistingGameMessage& _internal_joinexistinggamemessage() const;
  ::JoinExistingGameMessage* _internal_mutable_joinexistinggamemessage();
  public:
  void unsafe_arena_set_allocated_joinexistinggamemessage(
      ::JoinExistingGameMessage* joinexistinggamemessage);
  ::JoinExistingGameMessage* unsafe_arena_release_joinexistinggamemessage();

  // optional .JoinNewGameMessage joinNewGameMessage = 23;
  bool has_joinnewgamemessage() const;
  private:
  bool _internal_has_joinnewgamemessage() const;
  public:
  void clear_joinnewgamemessage();
  const ::JoinNewGameMessage& joinnewgamemessage() const;
  PROTOBUF_NODISCARD ::JoinNewGameMessage* release_joinnewgamemessage();
  ::JoinNewGameMessage* mutable_joinnewgamemessage();
  void set_allocated_joinnewgamemessage(::JoinNewGameMessage* joinnewgamemessage);
  private:
  const ::JoinNewGameMessage& _internal_joinnewgamemessage() const;
  ::JoinNewGameMessage* _internal_mutable_joinnewgamemessage();
  public:
  void unsafe_arena_set_allocated_joinnewgamemessage(
      ::JoinNewGameMessage* joinnewgamemessage);
  ::JoinNewGameMessage* unsafe_arena_release_joinnewgamemessage();

  // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
  bool has_rejoinexistinggamemessage() const;
  private:
  bool _internal_has_rejoinexistinggamemessage() const;
  public:
  void clear_rejoinexistinggamemessage();
  const ::RejoinExistingGameMessage& rejoinexistinggamemessage() const;
  PROTOBUF_NODISCARD ::RejoinExistingGameMessage* release_rejoinexistinggamemessage();
  ::RejoinExistingGameMessage* mutable_rejoinexistinggamemessage();
  void set_allocated_rejoinexistinggamemessage(::RejoinExistingGameMessage* rejoinexistinggamemessage);
  private:
  const ::RejoinExistingGameMessage& _internal_rejoinexistinggamemessage() const;
  ::RejoinExistingGameMessage* _internal_mutable_rejoinexistinggamemessage();
  public:
  void unsafe_arena_set_allocated_rejoinexistinggamemessage(
      ::RejoinExistingGameMessage* rejoinexistinggamemessage);
  ::RejoinExistingGameMessage* unsafe_arena_release_rejoinexistinggamemessage();

  // optional .JoinGameAckMessage joinGameAckMessage = 25;
  bool has_joingameackmessage() const;
  private:
  bool _internal_has_joingameackmessage() const;
  public:
  void clear_joingameackmessage();
  const ::JoinGameAckMessage& joingameackmessage() const;
  PROTOBUF_NODISCARD ::JoinGameAckMessage* release_joingameackmessage();
  ::JoinGameAckMessage* mutable_joingameackmessage();
  void set_allocated_joingameackmessage(::JoinGameAckMessage* joingameackmessage);
  private:
  const ::JoinGameAckMessage& _internal_joingameackmessage() const;
  ::JoinGameAckMessage* _internal_mutable_joingameackmessage();
  public:
  void unsafe_arena_set_allocated_joingameackmessage(
      ::JoinGameAckMessage* joingameackmessage);
  ::JoinGameAckMessage* unsafe_arena_release_joingameackmessage();

  // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
  bool has_joingamefailedmessage() const;
  private:
  bool _internal_has_joingamefailedmessage() const;
  public:
  void clear_joingamefailedmessage();
  const ::JoinGameFailedMessage& joingamefailedmessage() const;
  PROTOBUF_NODISCARD ::JoinGameFailedMessage* release_joingamefailedmessage();
  ::JoinGameFailedMessage* mutable_joingamefailedmessage();
  void set_allocated_joingamefailedmessage(::JoinGameFailedMessage* joingamefailedmessage);
  private:
  const ::JoinGameFailedMessage& _internal_joingamefailedmessage() const;
  ::JoinGameFailedMessage* _internal_mutable_joingamefailedmessage();
  public:
  void unsafe_arena_set_allocated_joingamefailedmessage(
      ::JoinGameFailedMessage* joingamefailedmessage);
  ::JoinGameFailedMessage* unsafe_arena_release_joingamefailedmessage();

  // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
  bool has_gameplayerjoinedmessage() const;
  private:
  bool _internal_has_gameplayerjoinedmessage() const;
  public:
  void clear_gameplayerjoinedmessage();
  const ::GamePlayerJoinedMessage& gameplayerjoinedmessage() const;
  PROTOBUF_NODISCARD ::GamePlayerJoinedMessage* release_gameplayerjoinedmessage();
  ::GamePlayerJoinedMessage* mutable_gameplayerjoinedmessage();
  void set_allocated_gameplayerjoinedmessage(::GamePlayerJoinedMessage* gameplayerjoinedmessage);
  private:
  const ::GamePlayerJoinedMessage& _internal_gameplayerjoinedmessage() const;
  ::GamePlayerJoinedMessage* _internal_mutable_gameplayerjoinedmessage();
  public:
  void unsafe_arena_set_allocated_gameplayerjoinedmessage(
      ::GamePlayerJoinedMessage* gameplayerjoinedmessage);
  ::GamePlayerJoinedMessage* unsafe_arena_release_gameplayerjoinedmessage();

  // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
  bool has_gameplayerleftmessage() const;
  private:
  bool _internal_has_gameplayerleftmessage() const;
  public:
  void clear_gameplayerleftmessage();
  const ::GamePlayerLeftMessage& gameplayerleftmessage() const;
  PROTOBUF_NODISCARD ::GamePlayerLeftMessage* release_gameplayerleftmessage();
  ::GamePlayerLeftMessage* mutable_gameplayerleftmessage();
  void set_allocated_gameplayerleftmessage(::GamePlayerLeftMessage* gameplayerleftmessage);
  private:
  const ::GamePlayerLeftMessage& _internal_gameplayerleftmessage() const;
  ::GamePlayerLeftMessage* _internal_mutable_gameplayerleftmessage();
  public:
  void unsafe_arena_set_allocated_gameplayerleftmessage(
      ::GamePlayerLeftMessage* gameplayerleftmessage);
  ::GamePlayerLeftMessage* unsafe_arena_release_gameplayerleftmessage();

  // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
  bool has_gameadminchangedmessage() const;
  private:
  bool _internal_has_gameadminchangedmessage() const;
  public:
  void clear_gameadminchangedmessage();
  const ::GameAdminChangedMessage& gameadminchangedmessage() const;
  PROTOBUF_NODISCARD ::GameAdminChangedMessage* release_gameadminchangedmessage();
  ::GameAdminChangedMessage* mutable_gameadminchangedmessage();
  void set_allocated_gameadminchangedmessage(::GameAdminChangedMessage* gameadminchangedmessage);
  private:
  const ::GameAdminChangedMessage& _internal_gameadminchangedmessage() const;
  ::GameAdminChangedMessage* _internal_mutable_gameadminchangedmessage();
  public:
  void unsafe_arena_set_allocated_gameadminchangedmessage(
      ::GameAdminChangedMessage* gameadminchangedmessage);
  ::GameAdminChangedMessage* unsafe_arena_release_gameadminchangedmessage();

  // optional .RemovedFromGameMessage removedFromGameMessage = 30;
  bool has_removedfromgamemessage() const;
  private:
  bool _internal_has_removedfromgamemessage() const;
  public:
  void clear_removedfromgamemessage();
  const ::RemovedFromGameMessage& removedfromgamemessage() const;
  PROTOBUF_NODISCARD ::RemovedFromGameMessage* release_removedfromgamemessage();
  ::RemovedFromGameMessage* mutable_removedfromgamemessage();
  void set_allocated_removedfromgamemessage(::RemovedFromGameMessage* removedfromgamemessage);
  private:
  const ::RemovedFromGameMessage& _internal_removedfromgamemessage() const;
  ::RemovedFromGameMessage* _internal_mutable_removedfromgamemessage();
  public:
  void unsafe_arena_set_allocated_removedfromgamemessage(
      ::RemovedFromGameMessage* removedfromgamemessage);
  ::RemovedFromGameMessage* unsafe_arena_release_removedfromgamemessage();

  // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
  bool has_kickplayerrequestmessage() const;
  private:
  bool _internal_has_kickplayerrequestmessage() const;
  public:
  void clear_kickplayerrequestmessage();
  const ::KickPlayerRequestMessage& kickplayerrequestmessage() const;
  PROTOBUF_NODISCARD ::KickPlayerRequestMessage* release_kickplayerrequestmessage();
  ::KickPlayerRequestMessage* mutable_kickplayerrequestmessage();
  void set_allocated_kickplayerrequestmessage(::KickPlayerRequestMessage* kickplayerrequestmessage);
  private:
  const ::KickPlayerRequestMessage& _internal_kickplayerrequestmessage() const;
  ::KickPlayerRequestMessage* _internal_mutable_kickplayerrequestmessage();
  public:
  void unsafe_arena_set_allocated_kickplayerrequestmessage(
      ::KickPlayerRequestMessage* kickplayerrequestmessage);
  ::KickPlayerRequestMessage* unsafe_arena_release_kickplayerrequestmessage();

  // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
  bool has_leavegamerequestmessage() const;
  private:
  bool _internal_has_leavegamerequestmessage() const;
  public:
  void clear_leavegamerequestmessage();
  const ::LeaveGameRequestMessage& leavegamerequestmessage() const;
  PROTOBUF_NODISCARD ::LeaveGameRequestMessage* release_leavegamerequestmessage();
  ::LeaveGameRequestMessage* mutable_leavegamerequestmessage();
  void set_allocated_leavegamerequestmessage(::LeaveGameRequestMessage* leavegamerequestmessage);
  private:
  const ::LeaveGameRequestMessage& _internal_leavegamerequestmessage() const;
  ::LeaveGameRequestMessage* _internal_mutable_leavegamerequestmessage();
  public:
  void unsafe_arena_set_allocated_leavegamerequestmessage(
      ::LeaveGameRequestMessage* leavegamerequestmessage);
  ::LeaveGameRequestMessage* unsafe_arena_release_leavegamerequestmessage();

  // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
  bool has_inviteplayertogamemessage() const;
  private:
  bool _internal_has_inviteplayertogamemessage() const;
  public:
  void clear_inviteplayertogamemessage();
  const ::InvitePlayerToGameMessage& inviteplayertogamemessage() const;
  PROTOBUF_NODISCARD ::InvitePlayerToGameMessage* release_inviteplayertogamemessage();
  ::InvitePlayerToGameMessage* mutable_inviteplayertogamemessage();
  void set_allocated_inviteplayertogamemessage(::InvitePlayerToGameMessage* inviteplayertogamemessage);
  private:
  const ::InvitePlayerToGameMessage& _internal_inviteplayertogamemessage() const;
  ::InvitePlayerToGameMessage* _internal_mutable_inviteplayertogamemessage();
  public:
  void unsafe_arena_set_allocated_inviteplayertogamemessage(
      ::InvitePlayerToGameMessage* inviteplayertogamemessage);
  ::InvitePlayerToGameMessage* unsafe_arena_release_inviteplayertogamemessage();

  // optional .InviteNotifyMessage inviteNotifyMessage = 34;
  bool has_invitenotifymessage() const;
  private:
  bool _internal_has_invitenotifymessage() const;
  public:
  void clear_invitenotifymessage();
  const ::InviteNotifyMessage& invitenotifymessage() const;
  PROTOBUF_NODISCARD ::InviteNotifyMessage* release_invitenotifymessage();
  ::InviteNotifyMessage* mutable_invitenotifymessage();
  void set_allocated_invitenotifymessage(::InviteNotifyMessage* invitenotifymessage);
  private:
  const ::InviteNotifyMessage& _internal_invitenotifymessage() const;
  ::InviteNotifyMessage* _internal_mutable_invitenotifymessage();
  public:
  void unsafe_arena_set_allocated_invitenotifymessage(
      ::InviteNotifyMessage* invitenotifymessage);
  ::InviteNotifyMessage* unsafe_arena_release_invitenotifymessage();

  // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
  bool has_rejectgameinvitationmessage() const;
  private:
  bool _internal_has_rejectgameinvitationmessage() const;
  public:
  void clear_rejectgameinvitationmessage();
  const ::RejectGameInvitationMessage& rejectgameinvitationmessage() const;
  PROTOBUF_NODISCARD ::RejectGameInvitationMessage* release_rejectgameinvitationmessage();
  ::RejectGameInvitationMessage* mutable_rejectgameinvitationmessage();
  void set_allocated_rejectgameinvitationmessage(::RejectGameInvitationMessage* rejectgameinvitationmessage);
  private:
  const ::RejectGameInvitationMessage& _internal_rejectgameinvitationmessage() const;
  ::RejectGameInvitationMessage* _internal_mutable_rejectgameinvitationmessage();
  public:
  void unsafe_arena_set_allocated_rejectgameinvitationmessage(
      ::RejectGameInvitationMessage* rejectgameinvitationmessage);
  ::RejectGameInvitationMessage* unsafe_arena_release_rejectgameinvitationmessage();

  // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
  bool has_rejectinvnotifymessage() const;
  private:
  bool _internal_has_rejectinvnotifymessage() const;
  public:
  void clear_rejectinvnotifymessage();
  const ::RejectInvNotifyMessage& rejectinvnotifymessage() const;
  PROTOBUF_NODISCARD ::RejectInvNotifyMessage* release_rejectinvnotifymessage();
  ::RejectInvNotifyMessage* mutable_rejectinvnotifymessage();
  void set_allocated_rejectinvnotifymessage(::RejectInvNotifyMessage* rejectinvnotifymessage);
  private:
  const ::RejectInvNotifyMessage& _internal_rejectinvnotifymessage() const;
  ::RejectInvNotifyMessage* _internal_mutable_rejectinvnotifymessage();
  public:
  void unsafe_arena_set_allocated_rejectinvnotifymessage(
      ::RejectInvNotifyMessage* rejectinvnotifymessage);
  ::RejectInvNotifyMessage* unsafe_arena_release_rejectinvnotifymessage();

  // optional .StartEventMessage startEventMessage = 37;
  bool has_starteventmessage() const;
  private:
  bool _internal_has_starteventmessage() const;
  public:
  void clear_starteventmessage();
  const ::StartEventMessage& starteventmessage() const;
  PROTOBUF_NODISCARD ::StartEventMessage* release_starteventmessage();
  ::StartEventMessage* mutable_starteventmessage();
  void set_allocated_starteventmessage(::StartEventMessage* starteventmessage);
  private:
  const ::StartEventMessage& _internal_starteventmessage() const;
  ::StartEventMessage* _internal_mutable_starteventmessage();
  public:
  void unsafe_arena_set_allocated_starteventmessage(
      ::StartEventMessage* starteventmessage);
  ::StartEventMessage* unsafe_arena_release_starteventmessage();

  // optional .StartEventAckMessage startEventAckMessage = 38;
  bool has_starteventackmessage() const;
  private:
  bool _internal_has_starteventackmessage() const;
  public:
  void clear_starteventackmessage();
  const ::StartEventAckMessage& starteventackmessage() const;
  PROTOBUF_NODISCARD ::StartEventAckMessage* release_starteventackmessage();
  ::StartEventAckMessage* mutable_starteventackmessage();
  void set_allocated_starteventackmessage(::StartEventAckMessage* starteventackmessage);
  private:
  const ::StartEventAckMessage& _internal_starteventackmessage() const;
  ::StartEventAckMessage* _internal_mutable_starteventackmessage();
  public:
  void unsafe_arena_set_allocated_starteventackmessage(
      ::StartEventAckMessage* starteventackmessage);
  ::StartEventAckMessage* unsafe_arena_release_starteventackmessage();

  // optional .GameStartInitialMessage gameStartInitialMessage = 39;
  bool has_gamestartinitialmessage() const;
  private:
  bool _internal_has_gamestartinitialmessage() const;
  public:
  void clear_gamestartinitialmessage();
  const ::GameStartInitialMessage& gamestartinitialmessage() const;
  PROTOBUF_NODISCARD ::GameStartInitialMessage* release_gamestartinitialmessage();
  ::GameStartInitialMessage* mutable_gamestartinitialmessage();
  void set_allocated_gamestartinitialmessage(::GameStartInitialMessage* gamestartinitialmessage);
  private:
  const ::GameStartInitialMessage& _internal_gamestartinitialmessage() const;
  ::GameStartInitialMessage* _internal_mutable_gamestartinitialmessage();
  public:
  void unsafe_arena_set_allocated_gamestartinitialmessage(
      ::GameStartInitialMessage* gamestartinitialmessage);
  ::GameStartInitialMessage* unsafe_arena_release_gamestartinitialmessage();

  // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
  bool has_gamestartrejoinmessage() const;
  private:
  bool _internal_has_gamestartrejoinmessage() const;
  public:
  void clear_gamestartrejoinmessage();
  const ::GameStartRejoinMessage& gamestartrejoinmessage() const;
  PROTOBUF_NODISCARD ::GameStartRejoinMessage* release_gamestartrejoinmessage();
  ::GameStartRejoinMessage* mutable_gamestartrejoinmessage();
  void set_allocated_gamestartrejoinmessage(::GameStartRejoinMessage* gamestartrejoinmessage);
  private:
  const ::GameStartRejoinMessage& _internal_gamestartrejoinmessage() const;
  ::GameStartRejoinMessage* _internal_mutable_gamestartrejoinmessage();
  public:
  void unsafe_arena_set_allocated_gamestartrejoinmessage(
      ::GameStartRejoinMessage* gamestartrejoinmessage);
  ::GameStartRejoinMessage* unsafe_arena_release_gamestartrejoinmessage();

  // optional .HandStartMessage handStartMessage = 41;
  bool has_handstartmessage() const;
  private:
  bool _internal_has_handstartmessage() const;
  public:
  void clear_handstartmessage();
  const ::HandStartMessage& handstartmessage() const;
  PROTOBUF_NODISCARD ::HandStartMessage* release_handstartmessage();
  ::HandStartMessage* mutable_handstartmessage();
  void set_allocated_handstartmessage(::HandStartMessage* handstartmessage);
  private:
  const ::HandStartMessage& _internal_handstartmessage() const;
  ::HandStartMessage* _internal_mutable_handstartmessage();
  public:
  void unsafe_arena_set_allocated_handstartmessage(
      ::HandStartMessage* handstartmessage);
  ::HandStartMessage* unsafe_arena_release_handstartmessage();

  // optional .PlayersTurnMessage playersTurnMessage = 42;
  bool has_playersturnmessage() const;
  private:
  bool _internal_has_playersturnmessage() const;
  public:
  void clear_playersturnmessage();
  const ::PlayersTurnMessage& playersturnmessage() const;
  PROTOBUF_NODISCARD ::PlayersTurnMessage* release_playersturnmessage();
  ::PlayersTurnMessage* mutable_playersturnmessage();
  void set_allocated_playersturnmessage(::PlayersTurnMessage* playersturnmessage);
  private:
  const ::PlayersTurnMessage& _internal_playersturnmessage() const;
  ::PlayersTurnMessage* _internal_mutable_playersturnmessage();
  public:
  void unsafe_arena_set_allocated_playersturnmessage(
      ::PlayersTurnMessage* playersturnmessage);
  ::PlayersTurnMessage* unsafe_arena_release_playersturnmessage();

  // optional .MyActionRequestMessage myActionRequestMessage = 43;
  bool has_myactionrequestmessage() const;
  private:
  bool _internal_has_myactionrequestmessage() const;
  public:
  void clear_myactionrequestmessage();
  const ::MyActionRequestMessage& myactionrequestmessage() const;
  PROTOBUF_NODISCARD ::MyActionRequestMessage* release_myactionrequestmessage();
  ::MyActionRequestMessage* mutable_myactionrequestmessage();
  void set_allocated_myactionrequestmessage(::MyActionRequestMessage* myactionrequestmessage);
  private:
  const ::MyActionRequestMessage& _internal_myactionrequestmessage() const;
  ::MyActionRequestMessage* _internal_mutable_myactionrequestmessage();
  public:
  void unsafe_arena_set_allocated_myactionrequestmessage(
      ::MyActionRequestMessage* myactionrequestmessage);
  ::MyActionRequestMessage* unsafe_arena_release_myactionrequestmessage();

  // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
  bool has_youractionrejectedmessage() const;
  private:
  bool _internal_has_youractionrejectedmessage() const;
  public:
  void clear_youractionrejectedmessage();
  const ::YourActionRejectedMessage& youractionrejectedmessage() const;
  PROTOBUF_NODISCARD ::YourActionRejectedMessage* release_youractionrejectedmessage();
  ::YourActionRejectedMessage* mutable_youractionrejectedmessage();
  void set_allocated_youractionrejectedmessage(::YourActionRejectedMessage* youractionrejectedmessage);
  private:
  const ::YourActionRejectedMessage& _internal_youractionrejectedmessage() const;
  ::YourActionRejectedMessage* _internal_mutable_youractionrejectedmessage();
  public:
  void unsafe_arena_set_allocated_youractionrejectedmessage(
      ::YourActionRejectedMessage* youractionrejectedmessage);
  ::YourActionRejectedMessage* unsafe_arena_release_youractionrejectedmessage();

  // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
  bool has_playersactiondonemessage() const;
  private:
  bool _internal_has_playersactiondonemessage() const;
  public:
  void clear_playersactiondonemessage();
  const ::PlayersActionDoneMessage& playersactiondonemessage() const;
  PROTOBUF_NODISCARD ::PlayersActionDoneMessage* release_playersactiondonemessage();
  ::PlayersActionDoneMessage* mutable_playersactiondonemessage();
  void set_allocated_playersactiondonemessage(::PlayersActionDoneMessage* playersactiondonemessage);
  private:
  const ::PlayersActionDoneMessage& _internal_playersactiondonemessage() const;
  ::PlayersActionDoneMessage* _internal_mutable_playersactiondonemessage();
  public:
  void unsafe_arena_set_allocated_playersactiondonemessage(
      ::PlayersActionDoneMessage* playersactiondonemessage);
  ::PlayersActionDoneMessage* unsafe_arena_release_playersactiondonemessage();

  // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
  bool has_dealflopcardsmessage() const;
  private:
  bool _internal_has_dealflopcardsmessage() const;
  public:
  void clear_dealflopcardsmessage();
  const ::DealFlopCardsMessage& dealflopcardsmessage() const;
  PROTOBUF_NODISCARD ::DealFlopCardsMessage* release_dealflopcardsmessage();
  ::DealFlopCardsMessage* mutable_dealflopcardsmessage();
  void set_allocated_dealflopcardsmessage(::DealFlopCardsMessage* dealflopcardsmessage);
  private:
  const ::DealFlopCardsMessage& _internal_dealflopcardsmessage() const;
  ::DealFlopCardsMessage* _internal_mutable_dealflopcardsmessage();
  public:
  void unsafe_arena_set_allocated_dealflopcardsmessage(
      ::DealFlopCardsMessage* dealflopcardsmessage);
  ::DealFlopCardsMessage* unsafe_arena_release_dealflopcardsmessage();

  // optional .DealTurnCardMessage dealTurnCardMessage = 47;
  bool has_dealturncardmessage() const;
  private:
  bool _internal_has_dealturncardmessage() const;
  public:
  void clear_dealturncardmessage();
  const ::DealTurnCardMessage& dealturncardmessage() const;
  PROTOBUF_NODISCARD ::DealTurnCardMessage* release_dealturncardmessage();
  ::DealTurnCardMessage* mutable_dealturncardmessage();
  void set_allocated_dealturncardmessage(::DealTurnCardMessage* dealturncardmessage);
  private:
  const ::DealTurnCardMessage& _internal_dealturncardmessage() const;
  ::DealTurnCardMessage* _internal_mutable_dealturncardmessage();
  public:
  void unsafe_arena_set_allocated_dealturncardmessage(
      ::DealTurnCardMessage* dealturncardmessage);
  ::DealTurnCardMessage* unsafe_arena_release_dealturncardmessage();

  // optional .DealRiverCardMessage dealRiverCardMessage = 48;
  bool has_dealrivercardmessage() const;
  private:
  bool _internal_has_dealrivercardmessage() const;
  public:
  void clear_dealrivercardmessage();
  const ::DealRiverCardMessage& dealrivercardmessage() const;
  PROTOBUF_NODISCARD ::DealRiverCardMessage* release_dealrivercardmessage();
  ::DealRiverCardMessage* mutable_dealrivercardmessage();
  void set_allocated_dealrivercardmessage(::DealRiverCardMessage* dealrivercardmessage);
  private:
  const ::DealRiverCardMessage& _internal_dealrivercardmessage() const;
  ::DealRiverCardMessage* _internal_mutable_dealrivercardmessage();
  public:
  void unsafe_arena_set_allocated_dealrivercardmessage(
      ::DealRiverCardMessage* dealrivercardmessage);
  ::DealRiverCardMessage* unsafe_arena_release_dealrivercardmessage();

  // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
  bool has_allinshowcardsmessage() const;
  private:
  bool _internal_has_allinshowcardsmessage() const;
  public:
  void clear_allinshowcardsmessage();
  const ::AllInShowCardsMessage& allinshowcardsmessage() const;
  PROTOBUF_NODISCARD ::AllInShowCardsMessage* release_allinshowcardsmessage();
  ::AllInShowCardsMessage* mutable_allinshowcardsmessage();
  void set_allocated_allinshowcardsmessage(::AllInShowCardsMessage* allinshowcardsmessage);
  private:
  const ::AllInShowCardsMessage& _internal_allinshowcardsmessage() const;
  ::AllInShowCardsMessage* _internal_mutable_allinshowcardsmessage();
  public:
  void unsafe_arena_set_allocated_allinshowcardsmessage(
      ::AllInShowCardsMessage* allinshowcardsmessage);
  ::AllInShowCardsMessage* unsafe_arena_release_allinshowcardsmessage();

  // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
  bool has_endofhandshowcardsmessage() const;
  private:
  bool _internal_has_endofhandshowcardsmessage() const;
  public:
  void clear_endofhandshowcardsmessage();
  const ::EndOfHandShowCardsMessage& endofhandshowcardsmessage() const;
  PROTOBUF_NODISCARD ::EndOfHandShowCardsMessage* release_endofhandshowcardsmessage();
  ::EndOfHandShowCardsMessage* mutable_endofhandshowcardsmessage();
  void set_allocated_endofhandshowcardsmessage(::EndOfHandShowCardsMessage* endofhandshowcardsmessage);
  private:
  const ::EndOfHandShowCardsMessage& _internal_endofhandshowcardsmessage() const;
  ::EndOfHandShowCardsMessage* _internal_mutable_endofhandshowcardsmessage();
  public:
  void unsafe_arena_set_allocated_endofhandshowcardsmessage(
      ::EndOfHandShowCardsMessage* endofhandshowcardsmessage);
  ::EndOfHandShowCardsMessage* unsafe_arena_release_endofhandshowcardsmessage();

  // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
  bool has_endofhandhidecardsmessage() const;
  private:
  bool _internal_has_endofhandhidecardsmessage() const;
  public:
  void clear_endofhandhidecardsmessage();
  const ::EndOfHandHideCardsMessage& endofhandhidecardsmessage() const;
  PROTOBUF_NODISCARD ::EndOfHandHideCardsMessage* release_endofhandhidecardsmessage();
  ::EndOfHandHideCardsMessage* mutable_endofhandhidecardsmessage();
  void set_allocated_endofhandhidecardsmessage(::EndOfHandHideCardsMessage* endofhandhidecardsmessage);
  private:
  const ::EndOfHandHideCardsMessage& _internal_endofhandhidecardsmessage() const;
  ::EndOfHandHideCardsMessage* _internal_mutable_endofhandhidecardsmessage();
  public:
  void unsafe_arena_set_allocated_endofhandhidecardsmessage(
      ::EndOfHandHideCardsMessage* endofhandhidecardsmessage);
  ::EndOfHandHideCardsMessage* unsafe_arena_release_endofhandhidecardsmessage();

  // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
  bool has_showmycardsrequestmessage() const;
  private:
  bool _internal_has_showmycardsrequestmessage() const;
  public:
  void clear_showmycardsrequestmessage();
  const ::ShowMyCardsRequestMessage& showmycardsrequestmessage() const;
  PROTOBUF_NODISCARD ::ShowMyCardsRequestMessage* release_showmycardsrequestmessage();
  ::ShowMyCardsRequestMessage* mutable_showmycardsrequestmessage();
  void set_allocated_showmycardsrequestmessage(::ShowMyCardsRequestMessage* showmycardsrequestmessage);
  private:
  const ::ShowMyCardsRequestMessage& _internal_showmycardsrequestmessage() const;
  ::ShowMyCardsRequestMessage* _internal_mutable_showmycardsrequestmessage();
  public:
  void unsafe_arena_set_allocated_showmycardsrequestmessage(
      ::ShowMyCardsRequestMessage* showmycardsrequestmessage);
  ::ShowMyCardsRequestMessage* unsafe_arena_release_showmycardsrequestmessage();

  // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
  bool has_afterhandshowcardsmessage() const;
  private:
  bool _internal_has_afterhandshowcardsmessage() const;
  public:
  void clear_afterhandshowcardsmessage();
  const ::AfterHandShowCardsMessage& afterhandshowcardsmessage() const;
  PROTOBUF_NODISCARD ::AfterHandShowCardsMessage* release_afterhandshowcardsmessage();
  ::AfterHandShowCardsMessage* mutable_afterhandshowcardsmessage();
  void set_allocated_afterhandshowcardsmessage(::AfterHandShowCardsMessage* afterhandshowcardsmessage);
  private:
  const ::AfterHandShowCardsMessage& _internal_afterhandshowcardsmessage() const;
  ::AfterHandShowCardsMessage* _internal_mutable_afterhandshowcardsmessage();
  public:
  void unsafe_arena_set_allocated_afterhandshowcardsmessage(
      ::AfterHandShowCardsMessage* afterhandshowcardsmessage);
  ::AfterHandShowCardsMessage* unsafe_arena_release_afterhandshowcardsmessage();

  // optional .EndOfGameMessage endOfGameMessage = 54;
  bool has_endofgamemessage() const;
  private:
  bool _internal_has_endofgamemessage() const;
  public:
  void clear_endofgamemessage();
  const ::EndOfGameMessage& endofgamemessage() const;
  PROTOBUF_NODISCARD ::EndOfGameMessage* release_endofgamemessage();
  ::EndOfGameMessage* mutable_endofgamemessage();
  void set_allocated_endofgamemessage(::EndOfGameMessage* endofgamemessage);
  private:
  const ::EndOfGameMessage& _internal_endofgamemessage() const;
  ::EndOfGameMessage* _internal_mutable_endofgamemessage();
  public:
  void unsafe_arena_set_allocated_endofgamemessage(
      ::EndOfGameMessage* endofgamemessage);
  ::EndOfGameMessage* unsafe_arena_release_endofgamemessage();

  // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
  bool has_playeridchangedmessage() const;
  private:
  bool _internal_has_playeridchangedmessage() const;
  public:
  void clear_playeridchangedmessage();
  const ::PlayerIdChangedMessage& playeridchangedmessage() const;
  PROTOBUF_NODISCARD ::PlayerIdChangedMessage* release_playeridchangedmessage();
  ::PlayerIdChangedMessage* mutable_playeridchangedmessage();
  void set_allocated_playeridchangedmessage(::PlayerIdChangedMessage* playeridchangedmessage);
  private:
  const ::PlayerIdChangedMessage& _internal_playeridchangedmessage() const;
  ::PlayerIdChangedMessage* _internal_mutable_playeridchangedmessage();
  public:
  void unsafe_arena_set_allocated_playeridchangedmessage(
      ::PlayerIdChangedMessage* playeridchangedmessage);
  ::PlayerIdChangedMessage* unsafe_arena_release_playeridchangedmessage();

  // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
  bool has_askkickplayermessage() const;
  private:
  bool _internal_has_askkickplayermessage() const;
  public:
  void clear_askkickplayermessage();
  const ::AskKickPlayerMessage& askkickplayermessage() const;
  PROTOBUF_NODISCARD ::AskKickPlayerMessage* release_askkickplayermessage();
  ::AskKickPlayerMessage* mutable_askkickplayermessage();
  void set_allocated_askkickplayermessage(::AskKickPlayerMessage* askkickplayermessage);
  private:
  const ::AskKickPlayerMessage& _internal_askkickplayermessage() const;
  ::AskKickPlayerMessage* _internal_mutable_askkickplayermessage();
  public:
  void unsafe_arena_set_allocated_askkickplayermessage(
      ::AskKickPlayerMessage* askkickplayermessage);
  ::AskKickPlayerMessage* unsafe_arena_release_askkickplayermessage();

  // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
  bool has_askkickdeniedmessage() const;
  private:
  bool _internal_has_askkickdeniedmessage() const;
  public:
  void clear_askkickdeniedmessage();
  const ::AskKickDeniedMessage& askkickdeniedmessage() const;
  PROTOBUF_NODISCARD ::AskKickDeniedMessage* release_askkickdeniedmessage();
  ::AskKickDeniedMessage* mutable_askkickdeniedmessage();
  void set_allocated_askkickdeniedmessage(::AskKickDeniedMessage* askkickdeniedmessage);
  private:
  const ::AskKickDeniedMessage& _internal_askkickdeniedmessage() const;
  ::AskKickDeniedMessage* _internal_mutable_askkickdeniedmessage();
  public:
  void unsafe_arena_set_allocated_askkickdeniedmessage(
      ::AskKickDeniedMessage* askkickdeniedmessage);
  ::AskKickDeniedMessage* unsafe_arena_release_askkickdeniedmessage();

  // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
  bool has_startkickpetitionmessage() const;
  private:
  bool _internal_has_startkickpetitionmessage() const;
  public:
  void clear_startkickpetitionmessage();
  const ::StartKickPetitionMessage& startkickpetitionmessage() const;
  PROTOBUF_NODISCARD ::StartKickPetitionMessage* release_startkickpetitionmessage();
  ::StartKickPetitionMessage* mutable_startkickpetitionmessage();
  void set_allocated_startkickpetitionmessage(::StartKickPetitionMessage* startkickpetitionmessage);
  private:
  const ::StartKickPetitionMessage& _internal_startkickpetitionmessage() const;
  ::StartKickPetitionMessage* _internal_mutable_startkickpetitionmessage();
  public:
  void unsafe_arena_set_allocated_startkickpetitionmessage(
      ::StartKickPetitionMessage* startkickpetitionmessage);
  ::StartKickPetitionMessage* unsafe_arena_release_startkickpetitionmessage();

  // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
  bool has_votekickrequestmessage() const;
  private:
  bool _internal_has_votekickrequestmessage() const;
  public:
  void clear_votekickrequestmessage();
  const ::VoteKickRequestMessage& votekickrequestmessage() const;
  PROTOBUF_NODISCARD ::VoteKickRequestMessage* release_votekickrequestmessage();
  ::VoteKickRequestMessage* mutable_votekickrequestmessage();
  void set_allocated_votekickrequestmessage(::VoteKickRequestMessage* votekickrequestmessage);
  private:
  const ::VoteKickRequestMessage& _internal_votekickrequestmessage() const;
  ::VoteKickRequestMessage* _internal_mutable_votekickrequestmessage();
  public:
  void unsafe_arena_set_allocated_votekickrequestmessage(
      ::VoteKickRequestMessage* votekickrequestmessage);
  ::VoteKickRequestMessage* unsafe_arena_release_votekickrequestmessage();

  // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
  bool has_votekickreplymessage() const;
  private:
  bool _internal_has_votekickreplymessage() const;
  public:
  void clear_votekickreplymessage();
  const ::VoteKickReplyMessage& votekickreplymessage() const;
  PROTOBUF_NODISCARD ::VoteKickReplyMessage* release_votekickreplymessage();
  ::VoteKickReplyMessage* mutable_votekickreplymessage();
  void set_allocated_votekickreplymessage(::VoteKickReplyMessage* votekickreplymessage);
  private:
  const ::VoteKickReplyMessage& _internal_votekickreplymessage() const;
  ::VoteKickReplyMessage* _internal_mutable_votekickreplymessage();
  public:
  void unsafe_arena_set_allocated_votekickreplymessage(
      ::VoteKickReplyMessage* votekickreplymessage);
  ::VoteKickReplyMessage* unsafe_arena_release_votekickreplymessage();

  // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
  bool has_kickpetitionupdatemessage() const;
  private:
  bool _internal_has_kickpetitionupdatemessage() const;
  public:
  void clear_kickpetitionupdatemessage();
  const ::KickPetitionUpdateMessage& kickpetitionupdatemessage() const;
  PROTOBUF_NODISCARD ::KickPetitionUpdateMessage* release_kickpetitionupdatemessage();
  ::KickPetitionUpdateMessage* mutable_kickpetitionupdatemessage();
  void set_allocated_kickpetitionupdatemessage(::KickPetitionUpdateMessage* kickpetitionupdatemessage);
  private:
  const ::KickPetitionUpdateMessage& _internal_kickpetitionupdatemessage() const;
  ::KickPetitionUpdateMessage* _internal_mutable_kickpetitionupdatemessage();
  public:
  void unsafe_arena_set_allocated_kickpetitionupdatemessage(
      ::KickPetitionUpdateMessage* kickpetitionupdatemessage);
  ::KickPetitionUpdateMessage* unsafe_arena_release_kickpetitionupdatemessage();

  // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
  bool has_endkickpetitionmessage() const;
  private:
  bool _internal_has_endkickpetitionmessage() const;
  public:
  void clear_endkickpetitionmessage();
  const ::EndKickPetitionMessage& endkickpetitionmessage() const;
  PROTOBUF_NODISCARD ::EndKickPetitionMessage* release_endkickpetitionmessage();
  ::EndKickPetitionMessage* mutable_endkickpetitionmessage();
  void set_allocated_endkickpetitionmessage(::EndKickPetitionMessage* endkickpetitionmessage);
  private:
  const ::EndKickPetitionMessage& _internal_endkickpetitionmessage() const;
  ::EndKickPetitionMessage* _internal_mutable_endkickpetitionmessage();
  public:
  void unsafe_arena_set_allocated_endkickpetitionmessage(
      ::EndKickPetitionMessage* endkickpetitionmessage);
  ::EndKickPetitionMessage* unsafe_arena_release_endkickpetitionmessage();

  // optional .StatisticsMessage statisticsMessage = 63;
  bool has_statisticsmessage() const;
  private:
  bool _internal_has_statisticsmessage() const;
  public:
  void clear_statisticsmessage();
  const ::StatisticsMessage& statisticsmessage() const;
  PROTOBUF_NODISCARD ::StatisticsMessage* release_statisticsmessage();
  ::StatisticsMessage* mutable_statisticsmessage();
  void set_allocated_statisticsmessage(::StatisticsMessage* statisticsmessage);
  private:
  const ::StatisticsMessage& _internal_statisticsmessage() const;
  ::StatisticsMessage* _internal_mutable_statisticsmessage();
  public:
  void unsafe_arena_set_allocated_statisticsmessage(
      ::StatisticsMessage* statisticsmessage);
  ::StatisticsMessage* unsafe_arena_release_statisticsmessage();

  // optional .ChatRequestMessage chatRequestMessage = 64;
  bool has_chatrequestmessage() const;
  private:
  bool _internal_has_chatrequestmessage() const;
  public:
  void clear_chatrequestmessage();
  const ::ChatRequestMessage& chatrequestmessage() const;
  PROTOBUF_NODISCARD ::ChatRequestMessage* release_chatrequestmessage();
  ::ChatRequestMessage* mutable_chatrequestmessage();
  void set_allocated_chatrequestmessage(::ChatRequestMessage* chatrequestmessage);
  private:
  const ::ChatRequestMessage& _internal_chatrequestmessage() const;
  ::ChatRequestMessage* _internal_mutable_chatrequestmessage();
  public:
  void unsafe_arena_set_allocated_chatrequestmessage(
      ::ChatRequestMessage* chatrequestmessage);
  ::ChatRequestMessage* unsafe_arena_release_chatrequestmessage();

  // optional .ChatMessage chatMessage = 65;
  bool has_chatmessage() const;
  private:
  bool _internal_has_chatmessage() const;
  public:
  void clear_chatmessage();
  const ::ChatMessage& chatmessage() const;
  PROTOBUF_NODISCARD ::ChatMessage* release_chatmessage();
  ::ChatMessage* mutable_chatmessage();
  void set_allocated_chatmessage(::ChatMessage* chatmessage);
  private:
  const ::ChatMessage& _internal_chatmessage() const;
  ::ChatMessage* _internal_mutable_chatmessage();
  public:
  void unsafe_arena_set_allocated_chatmessage(
      ::ChatMessage* chatmessage);
  ::ChatMessage* unsafe_arena_release_chatmessage();

  // optional .ChatRejectMessage chatRejectMessage = 66;
  bool has_chatrejectmessage() const;
  private:
  bool _internal_has_chatrejectmessage() const;
  public:
  void clear_chatrejectmessage();
  const ::ChatRejectMessage& chatrejectmessage() const;
  PROTOBUF_NODISCARD ::ChatRejectMessage* release_chatrejectmessage();
  ::ChatRejectMessage* mutable_chatrejectmessage();
  void set_allocated_chatrejectmessage(::ChatRejectMessage* chatrejectmessage);
  private:
  const ::ChatRejectMessage& _internal_chatrejectmessage() const;
  ::ChatRejectMessage* _internal_mutable_chatrejectmessage();
  public:
  void unsafe_arena_set_allocated_chatrejectmessage(
      ::ChatRejectMessage* chatrejectmessage);
  ::ChatRejectMessage* unsafe_arena_release_chatrejectmessage();

  // optional .DialogMessage dialogMessage = 67;
  bool has_dialogmessage() const;
  private:
  bool _internal_has_dialogmessage() const;
  public:
  void clear_dialogmessage();
  const ::DialogMessage& dialogmessage() const;
  PROTOBUF_NODISCARD ::DialogMessage* release_dialogmessage();
  ::DialogMessage* mutable_dialogmessage();
  void set_allocated_dialogmessage(::DialogMessage* dialogmessage);
  private:
  const ::DialogMessage& _internal_dialogmessage() const;
  ::DialogMessage* _internal_mutable_dialogmessage();
  public:
  void unsafe_arena_set_allocated_dialogmessage(
      ::DialogMessage* dialogmessage);
  ::DialogMessage* unsafe_arena_release_dialogmessage();

  // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
  bool has_timeoutwarningmessage() const;
  private:
  bool _internal_has_timeoutwarningmessage() const;
  public:
  void clear_timeoutwarningmessage();
  const ::TimeoutWarningMessage& timeoutwarningmessage() const;
  PROTOBUF_NODISCARD ::TimeoutWarningMessage* release_timeoutwarningmessage();
  ::TimeoutWarningMessage* mutable_timeoutwarningmessage();
  void set_allocated_timeoutwarningmessage(::TimeoutWarningMessage* timeoutwarningmessage);
  private:
  const ::TimeoutWarningMessage& _internal_timeoutwarningmessage() const;
  ::TimeoutWarningMessage* _internal_mutable_timeoutwarningmessage();
  public:
  void unsafe_arena_set_allocated_timeoutwarningmessage(
      ::TimeoutWarningMessage* timeoutwarningmessage);
  ::TimeoutWarningMessage* unsafe_arena_release_timeoutwarningmessage();

  // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
  bool has_resettimeoutmessage() const;
  private:
  bool _internal_has_resettimeoutmessage() const;
  public:
  void clear_resettimeoutmessage();
  const ::ResetTimeoutMessage& resettimeoutmessage() const;
  PROTOBUF_NODISCARD ::ResetTimeoutMessage* release_resettimeoutmessage();
  ::ResetTimeoutMessage* mutable_resettimeoutmessage();
  void set_allocated_resettimeoutmessage(::ResetTimeoutMessage* resettimeoutmessage);
  private:
  const ::ResetTimeoutMessage& _internal_resettimeoutmessage() const;
  ::ResetTimeoutMessage* _internal_mutable_resettimeoutmessage();
  public:
  void unsafe_arena_set_allocated_resettimeoutmessage(
      ::ResetTimeoutMessage* resettimeoutmessage);
  ::ResetTimeoutMessage* unsafe_arena_release_resettimeoutmessage();

  // optional .ReportAvatarMessage reportAvatarMessage = 70;
  bool has_reportavatarmessage() const;
  private:
  bool _internal_has_reportavatarmessage() const;
  public:
  void clear_reportavatarmessage();
  const ::ReportAvatarMessage& reportavatarmessage() const;
  PROTOBUF_NODISCARD ::ReportAvatarMessage* release_reportavatarmessage();
  ::ReportAvatarMessage* mutable_reportavatarmessage();
  void set_allocated_reportavatarmessage(::ReportAvatarMessage* reportavatarmessage);
  private:
  const ::ReportAvatarMessage& _internal_reportavatarmessage() const;
  ::ReportAvatarMessage* _internal_mutable_reportavatarmessage();
  public:
  void unsafe_arena_set_allocated_reportavatarmessage(
      ::ReportAvatarMessage* reportavatarmessage);
  ::ReportAvatarMessage* unsafe_arena_release_reportavatarmessage();

  // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
  bool has_reportavatarackmessage() const;
  private:
  bool _internal_has_reportavatarackmessage() const;
  public:
  void clear_reportavatarackmessage();
  const ::ReportAvatarAckMessage& reportavatarackmessage() const;
  PROTOBUF_NODISCARD ::ReportAvatarAckMessage* release_reportavatarackmessage();
  ::ReportAvatarAckMessage* mutable_reportavatarackmessage();
  void set_allocated_reportavatarackmessage(::ReportAvatarAckMessage* reportavatarackmessage);
  private:
  const ::ReportAvatarAckMessage& _internal_reportavatarackmessage() const;
  ::ReportAvatarAckMessage* _internal_mutable_reportavatarackmessage();
  public:
  void unsafe_arena_set_allocated_reportavatarackmessage(
      ::ReportAvatarAckMessage* reportavatarackmessage);
  ::ReportAvatarAckMessage* unsafe_arena_release_reportavatarackmessage();

  // optional .ReportGameMessage reportGameMessage = 72;
  bool has_reportgamemessage() const;
  private:
  bool _internal_has_reportgamemessage() const;
  public:
  void clear_reportgamemessage();
  const ::ReportGameMessage& reportgamemessage() const;
  PROTOBUF_NODISCARD ::ReportGameMessage* release_reportgamemessage();
  ::ReportGameMessage* mutable_reportgamemessage();
  void set_allocated_reportgamemessage(::ReportGameMessage* reportgamemessage);
  private:
  const ::ReportGameMessage& _internal_reportgamemessage() const;
  ::ReportGameMessage* _internal_mutable_reportgamemessage();
  public:
  void unsafe_arena_set_allocated_reportgamemessage(
      ::ReportGameMessage* reportgamemessage);
  ::ReportGameMessage* unsafe_arena_release_reportgamemessage();

  // optional .ReportGameAckMessage reportGameAckMessage = 73;
  bool has_reportgameackmessage() const;
  private:
  bool _internal_has_reportgameackmessage() const;
  public:
  void clear_reportgameackmessage();
  const ::ReportGameAckMessage& reportgameackmessage() const;
  PROTOBUF_NODISCARD ::ReportGameAckMessage* release_reportgameackmessage();
  ::ReportGameAckMessage* mutable_reportgameackmessage();
  void set_allocated_reportgameackmessage(::ReportGameAckMessage* reportgameackmessage);
  private:
  const ::ReportGameAckMessage& _internal_reportgameackmessage() const;
  ::ReportGameAckMessage* _internal_mutable_reportgameackmessage();
  public:
  void unsafe_arena_set_allocated_reportgameackmessage(
      ::ReportGameAckMessage* reportgameackmessage);
  ::ReportGameAckMessage* unsafe_arena_release_reportgameackmessage();

  // optional .ErrorMessage errorMessage = 74;
  bool has_errormessage() const;
  private:
  bool _internal_has_errormessage() const;
  public:
  void clear_errormessage();
  const ::ErrorMessage& errormessage() const;
  PROTOBUF_NODISCARD ::ErrorMessage* release_errormessage();
  ::ErrorMessage* mutable_errormessage();
  void set_allocated_errormessage(::ErrorMessage* errormessage);
  private:
  const ::ErrorMessage& _internal_errormessage() const;
  ::ErrorMessage* _internal_mutable_errormessage();
  public:
  void unsafe_arena_set_allocated_errormessage(
      ::ErrorMessage* errormessage);
  ::ErrorMessage* unsafe_arena_release_errormessage();

  // optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
  bool has_adminremovegamemessage() const;
  private:
  bool _internal_has_adminremovegamemessage() const;
  public:
  void clear_adminremovegamemessage();
  const ::AdminRemoveGameMessage& adminremovegamemessage() const;
  PROTOBUF_NODISCARD ::AdminRemoveGameMessage* release_adminremovegamemessage();
  ::AdminRemoveGameMessage* mutable_adminremovegamemessage();
  void set_allocated_adminremovegamemessage(::AdminRemoveGameMessage* adminremovegamemessage);
  private:
  const ::AdminRemoveGameMessage& _internal_adminremovegamemessage() const;
  ::AdminRemoveGameMessage* _internal_mutable_adminremovegamemessage();
  public:
  void unsafe_arena_set_allocated_adminremovegamemessage(
      ::AdminRemoveGameMessage* adminremovegamemessage);
  ::AdminRemoveGameMessage* unsafe_arena_release_adminremovegamemessage();

  // optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
  bool has_adminremovegameackmessage() const;
  private:
  bool _internal_has_adminremovegameackmessage() const;
  public:
  void clear_adminremovegameackmessage();
  const ::AdminRemoveGameAckMessage& adminremovegameackmessage() const;
  PROTOBUF_NODISCARD ::AdminRemoveGameAckMessage* release_adminremovegameackmessage();
  ::AdminRemoveGameAckMessage* mutable_adminremovegameackmessage();
  void set_allocated_adminremovegameackmessage(::AdminRemoveGameAckMessage* adminremovegameackmessage);
  private:
  const ::AdminRemoveGameAckMessage& _internal_adminremovegameackmessage() const;
  ::AdminRemoveGameAckMessage* _internal_mutable_adminremovegameackmessage();
  public:
  void unsafe_arena_set_allocated_adminremovegameackmessage(
      ::AdminRemoveGameAckMessage* adminremovegameackmessage);
  ::AdminRemoveGameAckMessage* unsafe_arena_release_adminremovegameackmessage();

  // optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
  bool has_adminbanplayermessage() const;
  private:
  bool _internal_has_adminbanplayermessage() const;
  public:
  void clear_adminbanplayermessage();
  const ::AdminBanPlayerMessage& adminbanplayermessage() const;
  PROTOBUF_NODISCARD ::AdminBanPlayerMessage* release_adminbanplayermessage();
  ::AdminBanPlayerMessage* mutable_adminbanplayermessage();
  void set_allocated_adminbanplayermessage(::AdminBanPlayerMessage* adminbanplayermessage);
  private:
  const ::AdminBanPlayerMessage& _internal_adminbanplayermessage() const;
  ::AdminBanPlayerMessage* _internal_mutable_adminbanplayermessage();
  public:
  void unsafe_arena_set_allocated_adminbanplayermessage(
      ::AdminBanPlayerMessage* adminbanplayermessage);
  ::AdminBanPlayerMessage* unsafe_arena_release_adminbanplayermessage();

  // optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
  bool has_adminbanplayerackmessage() const;
  private:
  bool _internal_has_adminbanplayerackmessage() const;
  public:
  void clear_adminbanplayerackmessage();
  const ::AdminBanPlayerAckMessage& adminbanplayerackmessage() const;
  PROTOBUF_NODISCARD ::AdminBanPlayerAckMessage* release_adminbanplayerackmessage();
  ::AdminBanPlayerAckMessage* mutable_adminbanplayerackmessage();
  void set_allocated_adminbanplayerackmessage(::AdminBanPlayerAckMessage* adminbanplayerackmessage);
  private:
  const ::AdminBanPlayerAckMessage& _internal_adminbanplayerackmessage() const;
  ::AdminBanPlayerAckMessage* _internal_mutable_adminbanplayerackmessage();
  public:
  void unsafe_arena_set_allocated_adminbanplayerackmessage(
      ::AdminBanPlayerAckMessage* adminbanplayerackmessage);
  ::AdminBanPlayerAckMessage* unsafe_arena_release_adminbanplayerackmessage();

  // optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
  bool has_gamelistspectatorjoinedmessage() const;
  private:
  bool _internal_has_gamelistspectatorjoinedmessage() const;
  public:
  void clear_gamelistspectatorjoinedmessage();
  const ::GameListSpectatorJoinedMessage& gamelistspectatorjoinedmessage() const;
  PROTOBUF_NODISCARD ::GameListSpectatorJoinedMessage* release_gamelistspectatorjoinedmessage();
  ::GameListSpectatorJoinedMessage* mutable_gamelistspectatorjoinedmessage();
  void set_allocated_gamelistspectatorjoinedmessage(::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage);
  private:
  const ::GameListSpectatorJoinedMessage& _internal_gamelistspectatorjoinedmessage() const;
  ::GameListSpectatorJoinedMessage* _internal_mutable_gamelistspectatorjoinedmessage();
  public:
  void unsafe_arena_set_allocated_gamelistspectatorjoinedmessage(
      ::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage);
  ::GameListSpectatorJoinedMessage* unsafe_arena_release_gamelistspectatorjoinedmessage();

  // optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
  bool has_gamelistspectatorleftmessage() const;
  private:
  bool _internal_has_gamelistspectatorleftmessage() const;
  public:
  void clear_gamelistspectatorleftmessage();
  const ::GameListSpectatorLeftMessage& gamelistspectatorleftmessage() const;
  PROTOBUF_NODISCARD ::GameListSpectatorLeftMessage* release_gamelistspectatorleftmessage();
  ::GameListSpectatorLeftMessage* mutable_gamelistspectatorleftmessage();
  void set_allocated_gamelistspectatorleftmessage(::GameListSpectatorLeftMessage* gamelistspectatorleftmessage);
  private:
  const ::GameListSpectatorLeftMessage& _internal_gamelistspectatorleftmessage() const;
  ::GameListSpectatorLeftMessage* _internal_mutable_gamelistspectatorleftmessage();
  public:
  void unsafe_arena_set_allocated_gamelistspectatorleftmessage(
      ::GameListSpectatorLeftMessage* gamelistspectatorleftmessage);
  ::GameListSpectatorLeftMessage* unsafe_arena_release_gamelistspectatorleftmessage();

  // optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
  bool has_gamespectatorjoinedmessage() const;
  private:
  bool _internal_has_gamespectatorjoinedmessage() const;
  public:
  void clear_gamespectatorjoinedmessage();
  const ::GameSpectatorJoinedMessage& gamespectatorjoinedmessage() const;
  PROTOBUF_NODISCARD ::GameSpectatorJoinedMessage* release_gamespectatorjoinedmessage();
  ::GameSpectatorJoinedMessage* mutable_gamespectatorjoinedmessage();
  void set_allocated_gamespectatorjoinedmessage(::GameSpectatorJoinedMessage* gamespectatorjoinedmessage);
  private:
  const ::GameSpectatorJoinedMessage& _internal_gamespectatorjoinedmessage() const;
  ::GameSpectatorJoinedMessage* _internal_mutable_gamespectatorjoinedmessage();
  public:
  void unsafe_arena_set_allocated_gamespectatorjoinedmessage(
      ::GameSpectatorJoinedMessage* gamespectatorjoinedmessage);
  ::GameSpectatorJoinedMessage* unsafe_arena_release_gamespectatorjoinedmessage();

  // optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
  bool has_gamespectatorleftmessage() const;
  private:
  bool _internal_has_gamespectatorleftmessage() const;
  public:
  void clear_gamespectatorleftmessage();
  const ::GameSpectatorLeftMessage& gamespectatorleftmessage() const;
  PROTOBUF_NODISCARD ::GameSpectatorLeftMessage* release_gamespectatorleftmessage();
  ::GameSpectatorLeftMessage* mutable_gamespectatorleftmessage();
  void set_allocated_gamespectatorleftmessage(::GameSpectatorLeftMessage* gamespectatorleftmessage);
  private:
  const ::GameSpectatorLeftMessage& _internal_gamespectatorleftmessage() const;
  ::GameSpectatorLeftMessage* _internal_mutable_gamespectatorleftmessage();
  public:
  void unsafe_arena_set_allocated_gamespectatorleftmessage(
      ::GameSpectatorLeftMessage* gamespectatorleftmessage);
  ::GameSpectatorLeftMessage* unsafe_arena_release_gamespectatorleftmessage();

  // required .PokerTHMessage.PokerTHMessageType messageType = 1;
  bool has_messagetype() const;
  private:
  bool _internal_has_messagetype() const;
  public:
  void clear_messagetype();
  ::PokerTHMessage_PokerTHMessageType messagetype() const;
  void set_messagetype(::PokerTHMessage_PokerTHMessageType value);
  private:
  ::PokerTHMessage_PokerTHMessageType _internal_messagetype() const;
  void _internal_set_messagetype(::PokerTHMessage_PokerTHMessageType value);
  public:

  // @@protoc_insertion_point(class_scope:PokerTHMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<3> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::AnnounceMessage* announcemessage_;
  ::InitMessage* initmessage_;
  ::AuthServerChallengeMessage* authserverchallengemessage_;
  ::AuthClientResponseMessage* authclientresponsemessage_;
  ::AuthServerVerificationMessage* authserververificationmessage_;
  ::InitAckMessage* initackmessage_;
  ::AvatarRequestMessage* avatarrequestmessage_;
  ::AvatarHeaderMessage* avatarheadermessage_;
  ::AvatarDataMessage* avatardatamessage_;
  ::AvatarEndMessage* avatarendmessage_;
  ::UnknownAvatarMessage* unknownavatarmessage_;
  ::PlayerListMessage* playerlistmessage_;
  ::GameListNewMessage* gamelistnewmessage_;
  ::GameListUpdateMessage* gamelistupdatemessage_;
  ::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage_;
  ::GameListPlayerLeftMessage* gamelistplayerleftmessage_;
  ::GameListAdminChangedMessage* gamelistadminchangedmessage_;
  ::PlayerInfoRequestMessage* playerinforequestmessage_;
  ::PlayerInfoReplyMessage* playerinforeplymessage_;
  ::SubscriptionRequestMessage* subscriptionrequestmessage_;
  ::JoinExistingGameMessage* joinexistinggamemessage_;
  ::JoinNewGameMessage* joinnewgamemessage_;
  ::RejoinExistingGameMessage* rejoinexistinggamemessage_;
  ::JoinGameAckMessage* joingameackmessage_;
  ::JoinGameFailedMessage* joingamefailedmessage_;
  ::GamePlayerJoinedMessage* gameplayerjoinedmessage_;
  ::GamePlayerLeftMessage* gameplayerleftmessage_;
  ::GameAdminChangedMessage* gameadminchangedmessage_;
  ::RemovedFromGameMessage* removedfromgamemessage_;
  ::KickPlayerRequestMessage* kickplayerrequestmessage_;
  ::LeaveGameRequestMessage* leavegamerequestmessage_;
  ::InvitePlayerToGameMessage* inviteplayertogamemessage_;
  ::InviteNotifyMessage* invitenotifymessage_;
  ::RejectGameInvitationMessage* rejectgameinvitationmessage_;
  ::RejectInvNotifyMessage* rejectinvnotifymessage_;
  ::StartEventMessage* starteventmessage_;
  ::StartEventAckMessage* starteventackmessage_;
  ::GameStartInitialMessage* gamestartinitialmessage_;
  ::GameStartRejoinMessage* gamestartrejoinmessage_;
  ::HandStartMessage* handstartmessage_;
  ::PlayersTurnMessage* playersturnmessage_;
  ::MyActionRequestMessage* myactionrequestmessage_;
  ::YourActionRejectedMessage* youractionrejectedmessage_;
  ::PlayersActionDoneMessage* playersactiondonemessage_;
  ::DealFlopCardsMessage* dealflopcardsmessage_;
  ::DealTurnCardMessage* dealturncardmessage_;
  ::DealRiverCardMessage* dealrivercardmessage_;
  ::AllInShowCardsMessage* allinshowcardsmessage_;
  ::EndOfHandShowCardsMessage* endofhandshowcardsmessage_;
  ::EndOfHandHideCardsMessage* endofhandhidecardsmessage_;
  ::ShowMyCardsRequestMessage* showmycardsrequestmessage_;
  ::AfterHandShowCardsMessage* afterhandshowcardsmessage_;
  ::EndOfGameMessage* endofgamemessage_;
  ::PlayerIdChangedMessage* playeridchangedmessage_;
  ::AskKickPlayerMessage* askkickplayermessage_;
  ::AskKickDeniedMessage* askkickdeniedmessage_;
  ::StartKickPetitionMessage* startkickpetitionmessage_;
  ::VoteKickRequestMessage* votekickrequestmessage_;
  ::VoteKickReplyMessage* votekickreplymessage_;
  ::KickPetitionUpdateMessage* kickpetitionupdatemessage_;
  ::EndKickPetitionMessage* endkickpetitionmessage_;
  ::StatisticsMessage* statisticsmessage_;
  ::ChatRequestMessage* chatrequestmessage_;
  ::ChatMessage* chatmessage_;
  ::ChatRejectMessage* chatrejectmessage_;
  ::DialogMessage* dialogmessage_;
  ::TimeoutWarningMessage* timeoutwarningmessage_;
  ::ResetTimeoutMessage* resettimeoutmessage_;
  ::ReportAvatarMessage* reportavatarmessage_;
  ::ReportAvatarAckMessage* reportavatarackmessage_;
  ::ReportGameMessage* reportgamemessage_;
  ::ReportGameAckMessage* reportgameackmessage_;
  ::ErrorMessage* errormessage_;
  ::AdminRemoveGameMessage* adminremovegamemessage_;
  ::AdminRemoveGameAckMessage* adminremovegameackmessage_;
  ::AdminBanPlayerMessage* adminbanplayermessage_;
  ::AdminBanPlayerAckMessage* adminbanplayerackmessage_;
  ::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage_;
  ::GameListSpectatorLeftMessage* gamelistspectatorleftmessage_;
  ::GameSpectatorJoinedMessage* gamespectatorjoinedmessage_;
  ::GameSpectatorLeftMessage* gamespectatorleftmessage_;
  int messagetype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetGameInfo

// required string gameName = 1;
inline bool NetGameInfo::_internal_has_gamename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetGameInfo::has_gamename() const {
  return _internal_has_gamename();
}
inline void NetGameInfo::clear_gamename() {
  gamename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetGameInfo::gamename() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.gameName)
  return _internal_gamename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetGameInfo::set_gamename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 gamename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetGameInfo.gameName)
}
inline std::string* NetGameInfo::mutable_gamename() {
  std::string* _s = _internal_mutable_gamename();
  // @@protoc_insertion_point(field_mutable:NetGameInfo.gameName)
  return _s;
}
inline const std::string& NetGameInfo::_internal_gamename() const {
  return gamename_.Get();
}
inline void NetGameInfo::_internal_set_gamename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetGameInfo::_internal_mutable_gamename() {
  _has_bits_[0] |= 0x00000001u;
  return gamename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetGameInfo::release_gamename() {
  // @@protoc_insertion_point(field_release:NetGameInfo.gameName)
  if (!_internal_has_gamename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = gamename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetGameInfo::set_allocated_gamename(std::string* gamename) {
  if (gamename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetGameInfo.gameName)
}

// required .NetGameInfo.NetGameType netGameType = 2;
inline bool NetGameInfo::_internal_has_netgametype() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool NetGameInfo::has_netgametype() const {
  return _internal_has_netgametype();
}
inline void NetGameInfo::clear_netgametype() {
  netgametype_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::NetGameInfo_NetGameType NetGameInfo::_internal_netgametype() const {
  return static_cast< ::NetGameInfo_NetGameType >(netgametype_);
}
inline ::NetGameInfo_NetGameType NetGameInfo::netgametype() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.netGameType)
  return _internal_netgametype();
}
inline void NetGameInfo::_internal_set_netgametype(::NetGameInfo_NetGameType value) {
  assert(::NetGameInfo_NetGameType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  netgametype_ = value;
}
inline void NetGameInfo::set_netgametype(::NetGameInfo_NetGameType value) {
  _internal_set_netgametype(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.netGameType)
}

// required uint32 maxNumPlayers = 3;
inline bool NetGameInfo::_internal_has_maxnumplayers() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NetGameInfo::has_maxnumplayers() const {
  return _internal_has_maxnumplayers();
}
inline void NetGameInfo::clear_maxnumplayers() {
  maxnumplayers_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t NetGameInfo::_internal_maxnumplayers() const {
  return maxnumplayers_;
}
inline uint32_t NetGameInfo::maxnumplayers() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.maxNumPlayers)
  return _internal_maxnumplayers();
}
inline void NetGameInfo::_internal_set_maxnumplayers(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  maxnumplayers_ = value;
}
inline void NetGameInfo::set_maxnumplayers(uint32_t value) {
  _internal_set_maxnumplayers(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.maxNumPlayers)
}

// required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
inline bool NetGameInfo::_internal_has_raiseintervalmode() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool NetGameInfo::has_raiseintervalmode() const {
  return _internal_has_raiseintervalmode();
}
inline void NetGameInfo::clear_raiseintervalmode() {
  raiseintervalmode_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::NetGameInfo_RaiseIntervalMode NetGameInfo::_internal_raiseintervalmode() const {
  return static_cast< ::NetGameInfo_RaiseIntervalMode >(raiseintervalmode_);
}
inline ::NetGameInfo_RaiseIntervalMode NetGameInfo::raiseintervalmode() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseIntervalMode)
  return _internal_raiseintervalmode();
}
inline void NetGameInfo::_internal_set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value) {
  assert(::NetGameInfo_RaiseIntervalMode_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  raiseintervalmode_ = value;
}
inline void NetGameInfo::set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value) {
  _internal_set_raiseintervalmode(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseIntervalMode)
}

// optional uint32 raiseEveryHands = 5;
inline bool NetGameInfo::_internal_has_raiseeveryhands() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NetGameInfo::has_raiseeveryhands() const {
  return _internal_has_raiseeveryhands();
}
inline void NetGameInfo::clear_raiseeveryhands() {
  raiseeveryhands_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t NetGameInfo::_internal_raiseeveryhands() const {
  return raiseeveryhands_;
}
inline uint32_t NetGameInfo::raiseeveryhands() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseEveryHands)
  return _internal_raiseeveryhands();
}
inline void NetGameInfo::_internal_set_raiseeveryhands(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  raiseeveryhands_ = value;
}
inline void NetGameInfo::set_raiseeveryhands(uint32_t value) {
  _internal_set_raiseeveryhands(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseEveryHands)
}

// optional uint32 raiseEveryMinutes = 6;
inline bool NetGameInfo::_internal_has_raiseeveryminutes() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NetGameInfo::has_raiseeveryminutes() const {
  return _internal_has_raiseeveryminutes();
}
inline void NetGameInfo::clear_raiseeveryminutes() {
  raiseeveryminutes_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t NetGameInfo::_internal_raiseeveryminutes() const {
  return raiseeveryminutes_;
}
inline uint32_t NetGameInfo::raiseeveryminutes() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseEveryMinutes)
  return _internal_raiseeveryminutes();
}
inline void NetGameInfo::_internal_set_raiseeveryminutes(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  raiseeveryminutes_ = value;
}
inline void NetGameInfo::set_raiseeveryminutes(uint32_t value) {
  _internal_set_raiseeveryminutes(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseEveryMinutes)
}

// required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
inline bool NetGameInfo::_internal_has_endraisemode() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool NetGameInfo::has_endraisemode() const {
  return _internal_has_endraisemode();
}
inline void NetGameInfo::clear_endraisemode() {
  endraisemode_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::NetGameInfo_EndRaiseMode NetGameInfo::_internal_endraisemode() const {
  return static_cast< ::NetGameInfo_EndRaiseMode >(endraisemode_);
}
inline ::NetGameInfo_EndRaiseMode NetGameInfo::endraisemode() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.endRaiseMode)
  return _internal_endraisemode();
}
inline void NetGameInfo::_internal_set_endraisemode(::NetGameInfo_EndRaiseMode value) {
  assert(::NetGameInfo_EndRaiseMode_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  endraisemode_ = value;
}
inline void NetGameInfo::set_endraisemode(::NetGameInfo_EndRaiseMode value) {
  _internal_set_endraisemode(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.endRaiseMode)
}

// optional uint32 endRaiseSmallBlindValue = 8;
inline bool NetGameInfo::_internal_has_endraisesmallblindvalue() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NetGameInfo::has_endraisesmallblindvalue() const {
  return _internal_has_endraisesmallblindvalue();
}
inline void NetGameInfo::clear_endraisesmallblindvalue() {
  endraisesmallblindvalue_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t NetGameInfo::_internal_endraisesmallblindvalue() const {
  return endraisesmallblindvalue_;
}
inline uint32_t NetGameInfo::endraisesmallblindvalue() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.endRaiseSmallBlindValue)
  return _internal_endraisesmallblindvalue();
}
inline void NetGameInfo::_internal_set_endraisesmallblindvalue(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  endraisesmallblindvalue_ = value;
}
inline void NetGameInfo::set_endraisesmallblindvalue(uint32_t value) {
  _internal_set_endraisesmallblindvalue(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.endRaiseSmallBlindValue)
}

// required uint32 proposedGuiSpeed = 9;
inline bool NetGameInfo::_internal_has_proposedguispeed() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NetGameInfo::has_proposedguispeed() const {
  return _internal_has_proposedguispeed();
}
inline void NetGameInfo::clear_proposedguispeed() {
  proposedguispeed_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t NetGameInfo::_internal_proposedguispeed() const {
  return proposedguispeed_;
}
inline uint32_t NetGameInfo::proposedguispeed() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.proposedGuiSpeed)
  return _internal_proposedguispeed();
}
inline void NetGameInfo::_internal_set_proposedguispeed(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  proposedguispeed_ = value;
}
inline void NetGameInfo::set_proposedguispeed(uint32_t value) {
  _internal_set_proposedguispeed(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.proposedGuiSpeed)
}

// required uint32 delayBetweenHands = 10;
inline bool NetGameInfo::_internal_has_delaybetweenhands() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NetGameInfo::has_delaybetweenhands() const {
  return _internal_has_delaybetweenhands();
}
inline void NetGameInfo::clear_delaybetweenhands() {
  delaybetweenhands_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t NetGameInfo::_internal_delaybetweenhands() const {
  return delaybetweenhands_;
}
inline uint32_t NetGameInfo::delaybetweenhands() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.delayBetweenHands)
  return _internal_delaybetweenhands();
}
inline void NetGameInfo::_internal_set_delaybetweenhands(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  delaybetweenhands_ = value;
}
inline void NetGameInfo::set_delaybetweenhands(uint32_t value) {
  _internal_set_delaybetweenhands(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.delayBetweenHands)
}

// required uint32 playerActionTimeout = 11;
inline bool NetGameInfo::_internal_has_playeractiontimeout() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool NetGameInfo::has_playeractiontimeout() const {
  return _internal_has_playeractiontimeout();
}
inline void NetGameInfo::clear_playeractiontimeout() {
  playeractiontimeout_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t NetGameInfo::_internal_playeractiontimeout() const {
  return playeractiontimeout_;
}
inline uint32_t NetGameInfo::playeractiontimeout() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.playerActionTimeout)
  return _internal_playeractiontimeout();
}
inline void NetGameInfo::_internal_set_playeractiontimeout(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  playeractiontimeout_ = value;
}
inline void NetGameInfo::set_playeractiontimeout(uint32_t value) {
  _internal_set_playeractiontimeout(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.playerActionTimeout)
}

// required uint32 firstSmallBlind = 12;
inline bool NetGameInfo::_internal_has_firstsmallblind() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool NetGameInfo::has_firstsmallblind() const {
  return _internal_has_firstsmallblind();
}
inline void NetGameInfo::clear_firstsmallblind() {
  firstsmallblind_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t NetGameInfo::_internal_firstsmallblind() const {
  return firstsmallblind_;
}
inline uint32_t NetGameInfo::firstsmallblind() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.firstSmallBlind)
  return _internal_firstsmallblind();
}
inline void NetGameInfo::_internal_set_firstsmallblind(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  firstsmallblind_ = value;
}
inline void NetGameInfo::set_firstsmallblind(uint32_t value) {
  _internal_set_firstsmallblind(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.firstSmallBlind)
}

// required uint32 startMoney = 13;
inline bool NetGameInfo::_internal_has_startmoney() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool NetGameInfo::has_startmoney() const {
  return _internal_has_startmoney();
}
inline void NetGameInfo::clear_startmoney() {
  startmoney_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t NetGameInfo::_internal_startmoney() const {
  return startmoney_;
}
inline uint32_t NetGameInfo::startmoney() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.startMoney)
  return _internal_startmoney();
}
inline void NetGameInfo::_internal_set_startmoney(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  startmoney_ = value;
}
inline void NetGameInfo::set_startmoney(uint32_t value) {
  _internal_set_startmoney(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.startMoney)
}

// repeated uint32 manualBlinds = 14 [packed = true];
inline int NetGameInfo::_internal_manualblinds_size() const {
  return manualblinds_.size();
}
inline int NetGameInfo::manualblinds_size() const {
  return _internal_manualblinds_size();
}
inline void NetGameInfo::clear_manualblinds() {
  manualblinds_.Clear();
}
inline uint32_t NetGameInfo::_internal_manualblinds(int index) const {
  return manualblinds_.Get(index);
}
inline uint32_t NetGameInfo::manualblinds(int index) const {
  // @@protoc_insertion_point(field_get:NetGameInfo.manualBlinds)
  return _internal_manualblinds(index);
}
inline void NetGameInfo::set_manualblinds(int index, uint32_t value) {
  manualblinds_.Set(index, value);
  // @@protoc_insertion_point(field_set:NetGameInfo.manualBlinds)
}
inline void NetGameInfo::_internal_add_manualblinds(uint32_t value) {
  manualblinds_.Add(value);
}
inline void NetGameInfo::add_manualblinds(uint32_t value) {
  _internal_add_manualblinds(value);
  // @@protoc_insertion_point(field_add:NetGameInfo.manualBlinds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
NetGameInfo::_internal_manualblinds() const {
  return manualblinds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
NetGameInfo::manualblinds() const {
  // @@protoc_insertion_point(field_list:NetGameInfo.manualBlinds)
  return _internal_manualblinds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
NetGameInfo::_internal_mutable_manualblinds() {
  return &manualblinds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
NetGameInfo::mutable_manualblinds() {
  // @@protoc_insertion_point(field_mutable_list:NetGameInfo.manualBlinds)
  return _internal_mutable_manualblinds();
}

// optional bool allowSpectators = 15 [default = true];
inline bool NetGameInfo::_internal_has_allowspectators() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool NetGameInfo::has_allowspectators() const {
  return _internal_has_allowspectators();
}
inline void NetGameInfo::clear_allowspectators() {
  allowspectators_ = true;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool NetGameInfo::_internal_allowspectators() const {
  return allowspectators_;
}
inline bool NetGameInfo::allowspectators() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.allowSpectators)
  return _internal_allowspectators();
}
inline void NetGameInfo::_internal_set_allowspectators(bool value) {
  _has_bits_[0] |= 0x00002000u;
  allowspectators_ = value;
}
inline void NetGameInfo::set_allowspectators(bool value) {
  _internal_set_allowspectators(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.allowSpectators)
}

// -------------------------------------------------------------------

// PlayerResult

// required uint32 playerId = 1;
inline bool PlayerResult::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerResult::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerResult::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PlayerResult::_internal_playerid() const {
  return playerid_;
}
inline uint32_t PlayerResult::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerResult.playerId)
  return _internal_playerid();
}
inline void PlayerResult::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
}
inline void PlayerResult::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayerResult.playerId)
}

// required uint32 resultCard1 = 2;
inline bool PlayerResult::_internal_has_resultcard1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerResult::has_resultcard1() const {
  return _internal_has_resultcard1();
}
inline void PlayerResult::clear_resultcard1() {
  resultcard1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PlayerResult::_internal_resultcard1() const {
  return resultcard1_;
}
inline uint32_t PlayerResult::resultcard1() const {
  // @@protoc_insertion_point(field_get:PlayerResult.resultCard1)
  return _internal_resultcard1();
}
inline void PlayerResult::_internal_set_resultcard1(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  resultcard1_ = value;
}
inline void PlayerResult::set_resultcard1(uint32_t value) {
  _internal_set_resultcard1(value);
  // @@protoc_insertion_point(field_set:PlayerResult.resultCard1)
}

// required uint32 resultCard2 = 3;
inline bool PlayerResult::_internal_has_resultcard2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerResult::has_resultcard2() const {
  return _internal_has_resultcard2();
}
inline void PlayerResult::clear_resultcard2() {
  resultcard2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PlayerResult::_internal_resultcard2() const {
  return resultcard2_;
}
inline uint32_t PlayerResult::resultcard2() const {
  // @@protoc_insertion_point(field_get:PlayerResult.resultCard2)
  return _internal_resultcard2();
}
inline void PlayerResult::_internal_set_resultcard2(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  resultcard2_ = value;
}
inline void PlayerResult::set_resultcard2(uint32_t value) {
  _internal_set_resultcard2(value);
  // @@protoc_insertion_point(field_set:PlayerResult.resultCard2)
}

// repeated uint32 bestHandPosition = 4 [packed = true];
inline int PlayerResult::_internal_besthandposition_size() const {
  return besthandposition_.size();
}
inline int PlayerResult::besthandposition_size() const {
  return _internal_besthandposition_size();
}
inline void PlayerResult::clear_besthandposition() {
  besthandposition_.Clear();
}
inline uint32_t PlayerResult::_internal_besthandposition(int index) const {
  return besthandposition_.Get(index);
}
inline uint32_t PlayerResult::besthandposition(int index) const {
  // @@protoc_insertion_point(field_get:PlayerResult.bestHandPosition)
  return _internal_besthandposition(index);
}
inline void PlayerResult::set_besthandposition(int index, uint32_t value) {
  besthandposition_.Set(index, value);
  // @@protoc_insertion_point(field_set:PlayerResult.bestHandPosition)
}
inline void PlayerResult::_internal_add_besthandposition(uint32_t value) {
  besthandposition_.Add(value);
}
inline void PlayerResult::add_besthandposition(uint32_t value) {
  _internal_add_besthandposition(value);
  // @@protoc_insertion_point(field_add:PlayerResult.bestHandPosition)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerResult::_internal_besthandposition() const {
  return besthandposition_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerResult::besthandposition() const {
  // @@protoc_insertion_point(field_list:PlayerResult.bestHandPosition)
  return _internal_besthandposition();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerResult::_internal_mutable_besthandposition() {
  return &besthandposition_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerResult::mutable_besthandposition() {
  // @@protoc_insertion_point(field_mutable_list:PlayerResult.bestHandPosition)
  return _internal_mutable_besthandposition();
}

// required uint32 moneyWon = 5;
inline bool PlayerResult::_internal_has_moneywon() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerResult::has_moneywon() const {
  return _internal_has_moneywon();
}
inline void PlayerResult::clear_moneywon() {
  moneywon_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PlayerResult::_internal_moneywon() const {
  return moneywon_;
}
inline uint32_t PlayerResult::moneywon() const {
  // @@protoc_insertion_point(field_get:PlayerResult.moneyWon)
  return _internal_moneywon();
}
inline void PlayerResult::_internal_set_moneywon(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  moneywon_ = value;
}
inline void PlayerResult::set_moneywon(uint32_t value) {
  _internal_set_moneywon(value);
  // @@protoc_insertion_point(field_set:PlayerResult.moneyWon)
}

// required uint32 playerMoney = 6;
inline bool PlayerResult::_internal_has_playermoney() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerResult::has_playermoney() const {
  return _internal_has_playermoney();
}
inline void PlayerResult::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PlayerResult::_internal_playermoney() const {
  return playermoney_;
}
inline uint32_t PlayerResult::playermoney() const {
  // @@protoc_insertion_point(field_get:PlayerResult.playerMoney)
  return _internal_playermoney();
}
inline void PlayerResult::_internal_set_playermoney(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  playermoney_ = value;
}
inline void PlayerResult::set_playermoney(uint32_t value) {
  _internal_set_playermoney(value);
  // @@protoc_insertion_point(field_set:PlayerResult.playerMoney)
}

// optional uint32 cardsValue = 7;
inline bool PlayerResult::_internal_has_cardsvalue() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayerResult::has_cardsvalue() const {
  return _internal_has_cardsvalue();
}
inline void PlayerResult::clear_cardsvalue() {
  cardsvalue_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t PlayerResult::_internal_cardsvalue() const {
  return cardsvalue_;
}
inline uint32_t PlayerResult::cardsvalue() const {
  // @@protoc_insertion_point(field_get:PlayerResult.cardsValue)
  return _internal_cardsvalue();
}
inline void PlayerResult::_internal_set_cardsvalue(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  cardsvalue_ = value;
}
inline void PlayerResult::set_cardsvalue(uint32_t value) {
  _internal_set_cardsvalue(value);
  // @@protoc_insertion_point(field_set:PlayerResult.cardsValue)
}

// -------------------------------------------------------------------

// AnnounceMessage_Version

// required uint32 majorVersion = 1;
inline bool AnnounceMessage_Version::_internal_has_majorversion() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnnounceMessage_Version::has_majorversion() const {
  return _internal_has_majorversion();
}
inline void AnnounceMessage_Version::clear_majorversion() {
  majorversion_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AnnounceMessage_Version::_internal_majorversion() const {
  return majorversion_;
}
inline uint32_t AnnounceMessage_Version::majorversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.Version.majorVersion)
  return _internal_majorversion();
}
inline void AnnounceMessage_Version::_internal_set_majorversion(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  majorversion_ = value;
}
inline void AnnounceMessage_Version::set_majorversion(uint32_t value) {
  _internal_set_majorversion(value);
  // @@protoc_insertion_point(field_set:AnnounceMessage.Version.majorVersion)
}

// required uint32 minorVersion = 2;
inline bool AnnounceMessage_Version::_internal_has_minorversion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AnnounceMessage_Version::has_minorversion() const {
  return _internal_has_minorversion();
}
inline void AnnounceMessage_Version::clear_minorversion() {
  minorversion_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AnnounceMessage_Version::_internal_minorversion() const {
  return minorversion_;
}
inline uint32_t AnnounceMessage_Version::minorversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.Version.minorVersion)
  return _internal_minorversion();
}
inline void AnnounceMessage_Version::_internal_set_minorversion(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  minorversion_ = value;
}
inline void AnnounceMessage_Version::set_minorversion(uint32_t value) {
  _internal_set_minorversion(value);
  // @@protoc_insertion_point(field_set:AnnounceMessage.Version.minorVersion)
}

// -------------------------------------------------------------------

// AnnounceMessage

// required .AnnounceMessage.Version protocolVersion = 1;
inline bool AnnounceMessage::_internal_has_protocolversion() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || protocolversion_ != nullptr);
  return value;
}
inline bool AnnounceMessage::has_protocolversion() const {
  return _internal_has_protocolversion();
}
inline void AnnounceMessage::clear_protocolversion() {
  if (protocolversion_ != nullptr) protocolversion_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::AnnounceMessage_Version& AnnounceMessage::_internal_protocolversion() const {
  const ::AnnounceMessage_Version* p = protocolversion_;
  return p != nullptr ? *p : reinterpret_cast<const ::AnnounceMessage_Version&>(
      ::_AnnounceMessage_Version_default_instance_);
}
inline const ::AnnounceMessage_Version& AnnounceMessage::protocolversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.protocolVersion)
  return _internal_protocolversion();
}
inline void AnnounceMessage::unsafe_arena_set_allocated_protocolversion(
    ::AnnounceMessage_Version* protocolversion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(protocolversion_);
  }
  protocolversion_ = protocolversion;
  if (protocolversion) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnnounceMessage.protocolVersion)
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
  ::AnnounceMessage_Version* temp = protocolversion_;
  protocolversion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AnnounceMessage_Version* AnnounceMessage::unsafe_arena_release_protocolversion() {
  // @@protoc_insertion_point(field_release:AnnounceMessage.protocolVersion)
  _has_bits_[0] &= ~0x00000001u;
  ::AnnounceMessage_Version* temp = protocolversion_;
  protocolversion_ = nullptr;
  return temp;
}
inline ::AnnounceMessage_Version* AnnounceMessage::_internal_mutable_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
  if (protocolversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage_Version>(GetArenaForAllocation());
    protocolversion_ = p;
  }
  return protocolversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_protocolversion() {
  ::AnnounceMessage_Version* _msg = _internal_mutable_protocolversion();
  // @@protoc_insertion_point(field_mutable:AnnounceMessage.protocolVersion)
  return _msg;
}
inline void AnnounceMessage::set_allocated_protocolversion(::AnnounceMessage_Version* protocolversion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete protocolversion_;
  }
  if (protocolversion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AnnounceMessage_Version>::GetOwningArena(protocolversion);
    if (message_arena != submessage_arena) {
      protocolversion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocolversion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocolversion_ = protocolversion;
  // @@protoc_insertion_point(field_set_allocated:AnnounceMessage.protocolVersion)
}

// required .AnnounceMessage.Version latestGameVersion = 2;
inline bool AnnounceMessage::_internal_has_latestgameversion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || latestgameversion_ != nullptr);
  return value;
}
inline bool AnnounceMessage::has_latestgameversion() const {
  return _internal_has_latestgameversion();
}
inline void AnnounceMessage::clear_latestgameversion() {
  if (latestgameversion_ != nullptr) latestgameversion_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::AnnounceMessage_Version& AnnounceMessage::_internal_latestgameversion() const {
  const ::AnnounceMessage_Version* p = latestgameversion_;
  return p != nullptr ? *p : reinterpret_cast<const ::AnnounceMessage_Version&>(
      ::_AnnounceMessage_Version_default_instance_);
}
inline const ::AnnounceMessage_Version& AnnounceMessage::latestgameversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.latestGameVersion)
  return _internal_latestgameversion();
}
inline void AnnounceMessage::unsafe_arena_set_allocated_latestgameversion(
    ::AnnounceMessage_Version* latestgameversion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latestgameversion_);
  }
  latestgameversion_ = latestgameversion;
  if (latestgameversion) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AnnounceMessage.latestGameVersion)
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_latestgameversion() {
  _has_bits_[0] &= ~0x00000002u;
  ::AnnounceMessage_Version* temp = latestgameversion_;
  latestgameversion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AnnounceMessage_Version* AnnounceMessage::unsafe_arena_release_latestgameversion() {
  // @@protoc_insertion_point(field_release:AnnounceMessage.latestGameVersion)
  _has_bits_[0] &= ~0x00000002u;
  ::AnnounceMessage_Version* temp = latestgameversion_;
  latestgameversion_ = nullptr;
  return temp;
}
inline ::AnnounceMessage_Version* AnnounceMessage::_internal_mutable_latestgameversion() {
  _has_bits_[0] |= 0x00000002u;
  if (latestgameversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage_Version>(GetArenaForAllocation());
    latestgameversion_ = p;
  }
  return latestgameversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_latestgameversion() {
  ::AnnounceMessage_Version* _msg = _internal_mutable_latestgameversion();
  // @@protoc_insertion_point(field_mutable:AnnounceMessage.latestGameVersion)
  return _msg;
}
inline void AnnounceMessage::set_allocated_latestgameversion(::AnnounceMessage_Version* latestgameversion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete latestgameversion_;
  }
  if (latestgameversion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AnnounceMessage_Version>::GetOwningArena(latestgameversion);
    if (message_arena != submessage_arena) {
      latestgameversion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latestgameversion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  latestgameversion_ = latestgameversion;
  // @@protoc_insertion_point(field_set_allocated:AnnounceMessage.latestGameVersion)
}

// required uint32 latestBetaRevision = 3;
inline bool AnnounceMessage::_internal_has_latestbetarevision() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AnnounceMessage::has_latestbetarevision() const {
  return _internal_has_latestbetarevision();
}
inline void AnnounceMessage::clear_latestbetarevision() {
  latestbetarevision_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AnnounceMessage::_internal_latestbetarevision() const {
  return latestbetarevision_;
}
inline uint32_t AnnounceMessage::latestbetarevision() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.latestBetaRevision)
  return _internal_latestbetarevision();
}
inline void AnnounceMessage::_internal_set_latestbetarevision(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  latestbetarevision_ = value;
}
inline void AnnounceMessage::set_latestbetarevision(uint32_t value) {
  _internal_set_latestbetarevision(value);
  // @@protoc_insertion_point(field_set:AnnounceMessage.latestBetaRevision)
}

// required .AnnounceMessage.ServerType serverType = 4;
inline bool AnnounceMessage::_internal_has_servertype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AnnounceMessage::has_servertype() const {
  return _internal_has_servertype();
}
inline void AnnounceMessage::clear_servertype() {
  servertype_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::AnnounceMessage_ServerType AnnounceMessage::_internal_servertype() const {
  return static_cast< ::AnnounceMessage_ServerType >(servertype_);
}
inline ::AnnounceMessage_ServerType AnnounceMessage::servertype() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.serverType)
  return _internal_servertype();
}
inline void AnnounceMessage::_internal_set_servertype(::AnnounceMessage_ServerType value) {
  assert(::AnnounceMessage_ServerType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  servertype_ = value;
}
inline void AnnounceMessage::set_servertype(::AnnounceMessage_ServerType value) {
  _internal_set_servertype(value);
  // @@protoc_insertion_point(field_set:AnnounceMessage.serverType)
}

// required uint32 numPlayersOnServer = 5;
inline bool AnnounceMessage::_internal_has_numplayersonserver() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AnnounceMessage::has_numplayersonserver() const {
  return _internal_has_numplayersonserver();
}
inline void AnnounceMessage::clear_numplayersonserver() {
  numplayersonserver_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t AnnounceMessage::_internal_numplayersonserver() const {
  return numplayersonserver_;
}
inline uint32_t AnnounceMessage::numplayersonserver() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.numPlayersOnServer)
  return _internal_numplayersonserver();
}
inline void AnnounceMessage::_internal_set_numplayersonserver(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  numplayersonserver_ = value;
}
inline void AnnounceMessage::set_numplayersonserver(uint32_t value) {
  _internal_set_numplayersonserver(value);
  // @@protoc_insertion_point(field_set:AnnounceMessage.numPlayersOnServer)
}

// -------------------------------------------------------------------

// InitMessage

// required .AnnounceMessage.Version requestedVersion = 1;
inline bool InitMessage::_internal_has_requestedversion() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || requestedversion_ != nullptr);
  return value;
}
inline bool InitMessage::has_requestedversion() const {
  return _internal_has_requestedversion();
}
inline void InitMessage::clear_requestedversion() {
  if (requestedversion_ != nullptr) requestedversion_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::AnnounceMessage_Version& InitMessage::_internal_requestedversion() const {
  const ::AnnounceMessage_Version* p = requestedversion_;
  return p != nullptr ? *p : reinterpret_cast<const ::AnnounceMessage_Version&>(
      ::_AnnounceMessage_Version_default_instance_);
}
inline const ::AnnounceMessage_Version& InitMessage::requestedversion() const {
  // @@protoc_insertion_point(field_get:InitMessage.requestedVersion)
  return _internal_requestedversion();
}
inline void InitMessage::unsafe_arena_set_allocated_requestedversion(
    ::AnnounceMessage_Version* requestedversion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requestedversion_);
  }
  requestedversion_ = requestedversion;
  if (requestedversion) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InitMessage.requestedVersion)
}
inline ::AnnounceMessage_Version* InitMessage::release_requestedversion() {
  _has_bits_[0] &= ~0x00000020u;
  ::AnnounceMessage_Version* temp = requestedversion_;
  requestedversion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AnnounceMessage_Version* InitMessage::unsafe_arena_release_requestedversion() {
  // @@protoc_insertion_point(field_release:InitMessage.requestedVersion)
  _has_bits_[0] &= ~0x00000020u;
  ::AnnounceMessage_Version* temp = requestedversion_;
  requestedversion_ = nullptr;
  return temp;
}
inline ::AnnounceMessage_Version* InitMessage::_internal_mutable_requestedversion() {
  _has_bits_[0] |= 0x00000020u;
  if (requestedversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage_Version>(GetArenaForAllocation());
    requestedversion_ = p;
  }
  return requestedversion_;
}
inline ::AnnounceMessage_Version* InitMessage::mutable_requestedversion() {
  ::AnnounceMessage_Version* _msg = _internal_mutable_requestedversion();
  // @@protoc_insertion_point(field_mutable:InitMessage.requestedVersion)
  return _msg;
}
inline void InitMessage::set_allocated_requestedversion(::AnnounceMessage_Version* requestedversion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete requestedversion_;
  }
  if (requestedversion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AnnounceMessage_Version>::GetOwningArena(requestedversion);
    if (message_arena != submessage_arena) {
      requestedversion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestedversion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  requestedversion_ = requestedversion;
  // @@protoc_insertion_point(field_set_allocated:InitMessage.requestedVersion)
}

// required uint32 buildId = 2;
inline bool InitMessage::_internal_has_buildid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InitMessage::has_buildid() const {
  return _internal_has_buildid();
}
inline void InitMessage::clear_buildid() {
  buildid_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t InitMessage::_internal_buildid() const {
  return buildid_;
}
inline uint32_t InitMessage::buildid() const {
  // @@protoc_insertion_point(field_get:InitMessage.buildId)
  return _internal_buildid();
}
inline void InitMessage::_internal_set_buildid(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  buildid_ = value;
}
inline void InitMessage::set_buildid(uint32_t value) {
  _internal_set_buildid(value);
  // @@protoc_insertion_point(field_set:InitMessage.buildId)
}

// optional bytes myLastSessionId = 3;
inline bool InitMessage::_internal_has_mylastsessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitMessage::has_mylastsessionid() const {
  return _internal_has_mylastsessionid();
}
inline void InitMessage::clear_mylastsessionid() {
  mylastsessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitMessage::mylastsessionid() const {
  // @@protoc_insertion_point(field_get:InitMessage.myLastSessionId)
  return _internal_mylastsessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitMessage::set_mylastsessionid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 mylastsessionid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitMessage.myLastSessionId)
}
inline std::string* InitMessage::mutable_mylastsessionid() {
  std::string* _s = _internal_mutable_mylastsessionid();
  // @@protoc_insertion_point(field_mutable:InitMessage.myLastSessionId)
  return _s;
}
inline const std::string& InitMessage::_internal_mylastsessionid() const {
  return mylastsessionid_.Get();
}
inline void InitMessage::_internal_set_mylastsessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  mylastsessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitMessage::_internal_mutable_mylastsessionid() {
  _has_bits_[0] |= 0x00000001u;
  return mylastsessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitMessage::release_mylastsessionid() {
  // @@protoc_insertion_point(field_release:InitMessage.myLastSessionId)
  if (!_internal_has_mylastsessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = mylastsessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mylastsessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mylastsessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitMessage::set_allocated_mylastsessionid(std::string* mylastsessionid) {
  if (mylastsessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mylastsessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mylastsessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mylastsessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mylastsessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitMessage.myLastSessionId)
}

// optional string authServerPassword = 4;
inline bool InitMessage::_internal_has_authserverpassword() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InitMessage::has_authserverpassword() const {
  return _internal_has_authserverpassword();
}
inline void InitMessage::clear_authserverpassword() {
  authserverpassword_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InitMessage::authserverpassword() const {
  // @@protoc_insertion_point(field_get:InitMessage.authServerPassword)
  return _internal_authserverpassword();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitMessage::set_authserverpassword(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 authserverpassword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitMessage.authServerPassword)
}
inline std::string* InitMessage::mutable_authserverpassword() {
  std::string* _s = _internal_mutable_authserverpassword();
  // @@protoc_insertion_point(field_mutable:InitMessage.authServerPassword)
  return _s;
}
inline const std::string& InitMessage::_internal_authserverpassword() const {
  return authserverpassword_.Get();
}
inline void InitMessage::_internal_set_authserverpassword(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  authserverpassword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitMessage::_internal_mutable_authserverpassword() {
  _has_bits_[0] |= 0x00000002u;
  return authserverpassword_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitMessage::release_authserverpassword() {
  // @@protoc_insertion_point(field_release:InitMessage.authServerPassword)
  if (!_internal_has_authserverpassword()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = authserverpassword_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authserverpassword_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    authserverpassword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitMessage::set_allocated_authserverpassword(std::string* authserverpassword) {
  if (authserverpassword != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  authserverpassword_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), authserverpassword,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authserverpassword_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    authserverpassword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitMessage.authServerPassword)
}

// required .InitMessage.LoginType login = 5;
inline bool InitMessage::_internal_has_login() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InitMessage::has_login() const {
  return _internal_has_login();
}
inline void InitMessage::clear_login() {
  login_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::InitMessage_LoginType InitMessage::_internal_login() const {
  return static_cast< ::InitMessage_LoginType >(login_);
}
inline ::InitMessage_LoginType InitMessage::login() const {
  // @@protoc_insertion_point(field_get:InitMessage.login)
  return _internal_login();
}
inline void InitMessage::_internal_set_login(::InitMessage_LoginType value) {
  assert(::InitMessage_LoginType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  login_ = value;
}
inline void InitMessage::set_login(::InitMessage_LoginType value) {
  _internal_set_login(value);
  // @@protoc_insertion_point(field_set:InitMessage.login)
}

// optional string nickName = 6;
inline bool InitMessage::_internal_has_nickname() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InitMessage::has_nickname() const {
  return _internal_has_nickname();
}
inline void InitMessage::clear_nickname() {
  nickname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InitMessage::nickname() const {
  // @@protoc_insertion_point(field_get:InitMessage.nickName)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitMessage::set_nickname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitMessage.nickName)
}
inline std::string* InitMessage::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:InitMessage.nickName)
  return _s;
}
inline const std::string& InitMessage::_internal_nickname() const {
  return nickname_.Get();
}
inline void InitMessage::_internal_set_nickname(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitMessage::_internal_mutable_nickname() {
  _has_bits_[0] |= 0x00000004u;
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitMessage::release_nickname() {
  // @@protoc_insertion_point(field_release:InitMessage.nickName)
  if (!_internal_has_nickname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = nickname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitMessage::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitMessage.nickName)
}

// optional bytes clientUserData = 7;
inline bool InitMessage::_internal_has_clientuserdata() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InitMessage::has_clientuserdata() const {
  return _internal_has_clientuserdata();
}
inline void InitMessage::clear_clientuserdata() {
  clientuserdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InitMessage::clientuserdata() const {
  // @@protoc_insertion_point(field_get:InitMessage.clientUserData)
  return _internal_clientuserdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitMessage::set_clientuserdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 clientuserdata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitMessage.clientUserData)
}
inline std::string* InitMessage::mutable_clientuserdata() {
  std::string* _s = _internal_mutable_clientuserdata();
  // @@protoc_insertion_point(field_mutable:InitMessage.clientUserData)
  return _s;
}
inline const std::string& InitMessage::_internal_clientuserdata() const {
  return clientuserdata_.Get();
}
inline void InitMessage::_internal_set_clientuserdata(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  clientuserdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitMessage::_internal_mutable_clientuserdata() {
  _has_bits_[0] |= 0x00000008u;
  return clientuserdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitMessage::release_clientuserdata() {
  // @@protoc_insertion_point(field_release:InitMessage.clientUserData)
  if (!_internal_has_clientuserdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = clientuserdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientuserdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientuserdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitMessage::set_allocated_clientuserdata(std::string* clientuserdata) {
  if (clientuserdata != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  clientuserdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientuserdata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientuserdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientuserdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitMessage.clientUserData)
}

// optional bytes avatarHash = 8;
inline bool InitMessage::_internal_has_avatarhash() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InitMessage::has_avatarhash() const {
  return _internal_has_avatarhash();
}
inline void InitMessage::clear_avatarhash() {
  avatarhash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InitMessage::avatarhash() const {
  // @@protoc_insertion_point(field_get:InitMessage.avatarHash)
  return _internal_avatarhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitMessage::set_avatarhash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 avatarhash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitMessage.avatarHash)
}
inline std::string* InitMessage::mutable_avatarhash() {
  std::string* _s = _internal_mutable_avatarhash();
  // @@protoc_insertion_point(field_mutable:InitMessage.avatarHash)
  return _s;
}
inline const std::string& InitMessage::_internal_avatarhash() const {
  return avatarhash_.Get();
}
inline void InitMessage::_internal_set_avatarhash(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  avatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitMessage::_internal_mutable_avatarhash() {
  _has_bits_[0] |= 0x00000010u;
  return avatarhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitMessage::release_avatarhash() {
  // @@protoc_insertion_point(field_release:InitMessage.avatarHash)
  if (!_internal_has_avatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = avatarhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitMessage::set_allocated_avatarhash(std::string* avatarhash) {
  if (avatarhash != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  avatarhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatarhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitMessage.avatarHash)
}

// -------------------------------------------------------------------

// AuthServerChallengeMessage

// required bytes serverChallenge = 1;
inline bool AuthServerChallengeMessage::_internal_has_serverchallenge() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthServerChallengeMessage::has_serverchallenge() const {
  return _internal_has_serverchallenge();
}
inline void AuthServerChallengeMessage::clear_serverchallenge() {
  serverchallenge_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthServerChallengeMessage::serverchallenge() const {
  // @@protoc_insertion_point(field_get:AuthServerChallengeMessage.serverChallenge)
  return _internal_serverchallenge();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthServerChallengeMessage::set_serverchallenge(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serverchallenge_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AuthServerChallengeMessage.serverChallenge)
}
inline std::string* AuthServerChallengeMessage::mutable_serverchallenge() {
  std::string* _s = _internal_mutable_serverchallenge();
  // @@protoc_insertion_point(field_mutable:AuthServerChallengeMessage.serverChallenge)
  return _s;
}
inline const std::string& AuthServerChallengeMessage::_internal_serverchallenge() const {
  return serverchallenge_.Get();
}
inline void AuthServerChallengeMessage::_internal_set_serverchallenge(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serverchallenge_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthServerChallengeMessage::_internal_mutable_serverchallenge() {
  _has_bits_[0] |= 0x00000001u;
  return serverchallenge_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthServerChallengeMessage::release_serverchallenge() {
  // @@protoc_insertion_point(field_release:AuthServerChallengeMessage.serverChallenge)
  if (!_internal_has_serverchallenge()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = serverchallenge_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serverchallenge_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serverchallenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthServerChallengeMessage::set_allocated_serverchallenge(std::string* serverchallenge) {
  if (serverchallenge != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serverchallenge_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverchallenge,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serverchallenge_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serverchallenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AuthServerChallengeMessage.serverChallenge)
}

// -------------------------------------------------------------------

// AuthClientResponseMessage

// required bytes clientResponse = 1;
inline bool AuthClientResponseMessage::_internal_has_clientresponse() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthClientResponseMessage::has_clientresponse() const {
  return _internal_has_clientresponse();
}
inline void AuthClientResponseMessage::clear_clientresponse() {
  clientresponse_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthClientResponseMessage::clientresponse() const {
  // @@protoc_insertion_point(field_get:AuthClientResponseMessage.clientResponse)
  return _internal_clientresponse();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthClientResponseMessage::set_clientresponse(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 clientresponse_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AuthClientResponseMessage.clientResponse)
}
inline std::string* AuthClientResponseMessage::mutable_clientresponse() {
  std::string* _s = _internal_mutable_clientresponse();
  // @@protoc_insertion_point(field_mutable:AuthClientResponseMessage.clientResponse)
  return _s;
}
inline const std::string& AuthClientResponseMessage::_internal_clientresponse() const {
  return clientresponse_.Get();
}
inline void AuthClientResponseMessage::_internal_set_clientresponse(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clientresponse_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthClientResponseMessage::_internal_mutable_clientresponse() {
  _has_bits_[0] |= 0x00000001u;
  return clientresponse_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthClientResponseMessage::release_clientresponse() {
  // @@protoc_insertion_point(field_release:AuthClientResponseMessage.clientResponse)
  if (!_internal_has_clientresponse()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = clientresponse_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientresponse_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientresponse_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthClientResponseMessage::set_allocated_clientresponse(std::string* clientresponse) {
  if (clientresponse != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clientresponse_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientresponse,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientresponse_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientresponse_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AuthClientResponseMessage.clientResponse)
}

// -------------------------------------------------------------------

// AuthServerVerificationMessage

// required bytes serverVerification = 1;
inline bool AuthServerVerificationMessage::_internal_has_serververification() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthServerVerificationMessage::has_serververification() const {
  return _internal_has_serververification();
}
inline void AuthServerVerificationMessage::clear_serververification() {
  serververification_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthServerVerificationMessage::serververification() const {
  // @@protoc_insertion_point(field_get:AuthServerVerificationMessage.serverVerification)
  return _internal_serververification();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthServerVerificationMessage::set_serververification(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serververification_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AuthServerVerificationMessage.serverVerification)
}
inline std::string* AuthServerVerificationMessage::mutable_serververification() {
  std::string* _s = _internal_mutable_serververification();
  // @@protoc_insertion_point(field_mutable:AuthServerVerificationMessage.serverVerification)
  return _s;
}
inline const std::string& AuthServerVerificationMessage::_internal_serververification() const {
  return serververification_.Get();
}
inline void AuthServerVerificationMessage::_internal_set_serververification(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serververification_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthServerVerificationMessage::_internal_mutable_serververification() {
  _has_bits_[0] |= 0x00000001u;
  return serververification_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthServerVerificationMessage::release_serververification() {
  // @@protoc_insertion_point(field_release:AuthServerVerificationMessage.serverVerification)
  if (!_internal_has_serververification()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = serververification_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serververification_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serververification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthServerVerificationMessage::set_allocated_serververification(std::string* serververification) {
  if (serververification != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serververification_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serververification,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serververification_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serververification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AuthServerVerificationMessage.serverVerification)
}

// -------------------------------------------------------------------

// InitAckMessage

// required bytes yourSessionId = 1;
inline bool InitAckMessage::_internal_has_yoursessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitAckMessage::has_yoursessionid() const {
  return _internal_has_yoursessionid();
}
inline void InitAckMessage::clear_yoursessionid() {
  yoursessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitAckMessage::yoursessionid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourSessionId)
  return _internal_yoursessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitAckMessage::set_yoursessionid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 yoursessionid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitAckMessage.yourSessionId)
}
inline std::string* InitAckMessage::mutable_yoursessionid() {
  std::string* _s = _internal_mutable_yoursessionid();
  // @@protoc_insertion_point(field_mutable:InitAckMessage.yourSessionId)
  return _s;
}
inline const std::string& InitAckMessage::_internal_yoursessionid() const {
  return yoursessionid_.Get();
}
inline void InitAckMessage::_internal_set_yoursessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  yoursessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitAckMessage::_internal_mutable_yoursessionid() {
  _has_bits_[0] |= 0x00000001u;
  return yoursessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitAckMessage::release_yoursessionid() {
  // @@protoc_insertion_point(field_release:InitAckMessage.yourSessionId)
  if (!_internal_has_yoursessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = yoursessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (yoursessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    yoursessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitAckMessage::set_allocated_yoursessionid(std::string* yoursessionid) {
  if (yoursessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  yoursessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), yoursessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (yoursessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    yoursessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitAckMessage.yourSessionId)
}

// required uint32 yourPlayerId = 2;
inline bool InitAckMessage::_internal_has_yourplayerid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InitAckMessage::has_yourplayerid() const {
  return _internal_has_yourplayerid();
}
inline void InitAckMessage::clear_yourplayerid() {
  yourplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t InitAckMessage::_internal_yourplayerid() const {
  return yourplayerid_;
}
inline uint32_t InitAckMessage::yourplayerid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourPlayerId)
  return _internal_yourplayerid();
}
inline void InitAckMessage::_internal_set_yourplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  yourplayerid_ = value;
}
inline void InitAckMessage::set_yourplayerid(uint32_t value) {
  _internal_set_yourplayerid(value);
  // @@protoc_insertion_point(field_set:InitAckMessage.yourPlayerId)
}

// optional bytes yourAvatarHash = 3;
inline bool InitAckMessage::_internal_has_youravatarhash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InitAckMessage::has_youravatarhash() const {
  return _internal_has_youravatarhash();
}
inline void InitAckMessage::clear_youravatarhash() {
  youravatarhash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InitAckMessage::youravatarhash() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourAvatarHash)
  return _internal_youravatarhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitAckMessage::set_youravatarhash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 youravatarhash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InitAckMessage.yourAvatarHash)
}
inline std::string* InitAckMessage::mutable_youravatarhash() {
  std::string* _s = _internal_mutable_youravatarhash();
  // @@protoc_insertion_point(field_mutable:InitAckMessage.yourAvatarHash)
  return _s;
}
inline const std::string& InitAckMessage::_internal_youravatarhash() const {
  return youravatarhash_.Get();
}
inline void InitAckMessage::_internal_set_youravatarhash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  youravatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitAckMessage::_internal_mutable_youravatarhash() {
  _has_bits_[0] |= 0x00000002u;
  return youravatarhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitAckMessage::release_youravatarhash() {
  // @@protoc_insertion_point(field_release:InitAckMessage.yourAvatarHash)
  if (!_internal_has_youravatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = youravatarhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (youravatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    youravatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitAckMessage::set_allocated_youravatarhash(std::string* youravatarhash) {
  if (youravatarhash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  youravatarhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), youravatarhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (youravatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    youravatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InitAckMessage.yourAvatarHash)
}

// optional uint32 rejoinGameId = 4;
inline bool InitAckMessage::_internal_has_rejoingameid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InitAckMessage::has_rejoingameid() const {
  return _internal_has_rejoingameid();
}
inline void InitAckMessage::clear_rejoingameid() {
  rejoingameid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t InitAckMessage::_internal_rejoingameid() const {
  return rejoingameid_;
}
inline uint32_t InitAckMessage::rejoingameid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.rejoinGameId)
  return _internal_rejoingameid();
}
inline void InitAckMessage::_internal_set_rejoingameid(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  rejoingameid_ = value;
}
inline void InitAckMessage::set_rejoingameid(uint32_t value) {
  _internal_set_rejoingameid(value);
  // @@protoc_insertion_point(field_set:InitAckMessage.rejoinGameId)
}

// -------------------------------------------------------------------

// AvatarRequestMessage

// required uint32 requestId = 1;
inline bool AvatarRequestMessage::_internal_has_requestid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AvatarRequestMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void AvatarRequestMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AvatarRequestMessage::_internal_requestid() const {
  return requestid_;
}
inline uint32_t AvatarRequestMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarRequestMessage.requestId)
  return _internal_requestid();
}
inline void AvatarRequestMessage::_internal_set_requestid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  requestid_ = value;
}
inline void AvatarRequestMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:AvatarRequestMessage.requestId)
}

// required bytes avatarHash = 2;
inline bool AvatarRequestMessage::_internal_has_avatarhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvatarRequestMessage::has_avatarhash() const {
  return _internal_has_avatarhash();
}
inline void AvatarRequestMessage::clear_avatarhash() {
  avatarhash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AvatarRequestMessage::avatarhash() const {
  // @@protoc_insertion_point(field_get:AvatarRequestMessage.avatarHash)
  return _internal_avatarhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvatarRequestMessage::set_avatarhash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 avatarhash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AvatarRequestMessage.avatarHash)
}
inline std::string* AvatarRequestMessage::mutable_avatarhash() {
  std::string* _s = _internal_mutable_avatarhash();
  // @@protoc_insertion_point(field_mutable:AvatarRequestMessage.avatarHash)
  return _s;
}
inline const std::string& AvatarRequestMessage::_internal_avatarhash() const {
  return avatarhash_.Get();
}
inline void AvatarRequestMessage::_internal_set_avatarhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AvatarRequestMessage::_internal_mutable_avatarhash() {
  _has_bits_[0] |= 0x00000001u;
  return avatarhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AvatarRequestMessage::release_avatarhash() {
  // @@protoc_insertion_point(field_release:AvatarRequestMessage.avatarHash)
  if (!_internal_has_avatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = avatarhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AvatarRequestMessage::set_allocated_avatarhash(std::string* avatarhash) {
  if (avatarhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatarhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatarhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AvatarRequestMessage.avatarHash)
}

// -------------------------------------------------------------------

// AvatarHeaderMessage

// required uint32 requestId = 1;
inline bool AvatarHeaderMessage::_internal_has_requestid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvatarHeaderMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void AvatarHeaderMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AvatarHeaderMessage::_internal_requestid() const {
  return requestid_;
}
inline uint32_t AvatarHeaderMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.requestId)
  return _internal_requestid();
}
inline void AvatarHeaderMessage::_internal_set_requestid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  requestid_ = value;
}
inline void AvatarHeaderMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.requestId)
}

// required .NetAvatarType avatarType = 2;
inline bool AvatarHeaderMessage::_internal_has_avatartype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AvatarHeaderMessage::has_avatartype() const {
  return _internal_has_avatartype();
}
inline void AvatarHeaderMessage::clear_avatartype() {
  avatartype_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetAvatarType AvatarHeaderMessage::_internal_avatartype() const {
  return static_cast< ::NetAvatarType >(avatartype_);
}
inline ::NetAvatarType AvatarHeaderMessage::avatartype() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.avatarType)
  return _internal_avatartype();
}
inline void AvatarHeaderMessage::_internal_set_avatartype(::NetAvatarType value) {
  assert(::NetAvatarType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  avatartype_ = value;
}
inline void AvatarHeaderMessage::set_avatartype(::NetAvatarType value) {
  _internal_set_avatartype(value);
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.avatarType)
}

// required uint32 avatarSize = 3;
inline bool AvatarHeaderMessage::_internal_has_avatarsize() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AvatarHeaderMessage::has_avatarsize() const {
  return _internal_has_avatarsize();
}
inline void AvatarHeaderMessage::clear_avatarsize() {
  avatarsize_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AvatarHeaderMessage::_internal_avatarsize() const {
  return avatarsize_;
}
inline uint32_t AvatarHeaderMessage::avatarsize() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.avatarSize)
  return _internal_avatarsize();
}
inline void AvatarHeaderMessage::_internal_set_avatarsize(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  avatarsize_ = value;
}
inline void AvatarHeaderMessage::set_avatarsize(uint32_t value) {
  _internal_set_avatarsize(value);
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.avatarSize)
}

// -------------------------------------------------------------------

// AvatarDataMessage

// required uint32 requestId = 1;
inline bool AvatarDataMessage::_internal_has_requestid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AvatarDataMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void AvatarDataMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AvatarDataMessage::_internal_requestid() const {
  return requestid_;
}
inline uint32_t AvatarDataMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarDataMessage.requestId)
  return _internal_requestid();
}
inline void AvatarDataMessage::_internal_set_requestid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  requestid_ = value;
}
inline void AvatarDataMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:AvatarDataMessage.requestId)
}

// required bytes avatarBlock = 2;
inline bool AvatarDataMessage::_internal_has_avatarblock() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvatarDataMessage::has_avatarblock() const {
  return _internal_has_avatarblock();
}
inline void AvatarDataMessage::clear_avatarblock() {
  avatarblock_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AvatarDataMessage::avatarblock() const {
  // @@protoc_insertion_point(field_get:AvatarDataMessage.avatarBlock)
  return _internal_avatarblock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvatarDataMessage::set_avatarblock(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 avatarblock_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AvatarDataMessage.avatarBlock)
}
inline std::string* AvatarDataMessage::mutable_avatarblock() {
  std::string* _s = _internal_mutable_avatarblock();
  // @@protoc_insertion_point(field_mutable:AvatarDataMessage.avatarBlock)
  return _s;
}
inline const std::string& AvatarDataMessage::_internal_avatarblock() const {
  return avatarblock_.Get();
}
inline void AvatarDataMessage::_internal_set_avatarblock(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarblock_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AvatarDataMessage::_internal_mutable_avatarblock() {
  _has_bits_[0] |= 0x00000001u;
  return avatarblock_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AvatarDataMessage::release_avatarblock() {
  // @@protoc_insertion_point(field_release:AvatarDataMessage.avatarBlock)
  if (!_internal_has_avatarblock()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = avatarblock_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarblock_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarblock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AvatarDataMessage::set_allocated_avatarblock(std::string* avatarblock) {
  if (avatarblock != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatarblock_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatarblock,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarblock_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarblock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AvatarDataMessage.avatarBlock)
}

// -------------------------------------------------------------------

// AvatarEndMessage

// required uint32 requestId = 1;
inline bool AvatarEndMessage::_internal_has_requestid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvatarEndMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void AvatarEndMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AvatarEndMessage::_internal_requestid() const {
  return requestid_;
}
inline uint32_t AvatarEndMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarEndMessage.requestId)
  return _internal_requestid();
}
inline void AvatarEndMessage::_internal_set_requestid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  requestid_ = value;
}
inline void AvatarEndMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:AvatarEndMessage.requestId)
}

// -------------------------------------------------------------------

// UnknownAvatarMessage

// required uint32 requestId = 1;
inline bool UnknownAvatarMessage::_internal_has_requestid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnknownAvatarMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void UnknownAvatarMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UnknownAvatarMessage::_internal_requestid() const {
  return requestid_;
}
inline uint32_t UnknownAvatarMessage::requestid() const {
  // @@protoc_insertion_point(field_get:UnknownAvatarMessage.requestId)
  return _internal_requestid();
}
inline void UnknownAvatarMessage::_internal_set_requestid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  requestid_ = value;
}
inline void UnknownAvatarMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:UnknownAvatarMessage.requestId)
}

// -------------------------------------------------------------------

// PlayerListMessage

// required uint32 playerId = 1;
inline bool PlayerListMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerListMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerListMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PlayerListMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t PlayerListMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerListMessage.playerId)
  return _internal_playerid();
}
inline void PlayerListMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
}
inline void PlayerListMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayerListMessage.playerId)
}

// required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
inline bool PlayerListMessage::_internal_has_playerlistnotification() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerListMessage::has_playerlistnotification() const {
  return _internal_has_playerlistnotification();
}
inline void PlayerListMessage::clear_playerlistnotification() {
  playerlistnotification_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PlayerListMessage_PlayerListNotification PlayerListMessage::_internal_playerlistnotification() const {
  return static_cast< ::PlayerListMessage_PlayerListNotification >(playerlistnotification_);
}
inline ::PlayerListMessage_PlayerListNotification PlayerListMessage::playerlistnotification() const {
  // @@protoc_insertion_point(field_get:PlayerListMessage.playerListNotification)
  return _internal_playerlistnotification();
}
inline void PlayerListMessage::_internal_set_playerlistnotification(::PlayerListMessage_PlayerListNotification value) {
  assert(::PlayerListMessage_PlayerListNotification_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  playerlistnotification_ = value;
}
inline void PlayerListMessage::set_playerlistnotification(::PlayerListMessage_PlayerListNotification value) {
  _internal_set_playerlistnotification(value);
  // @@protoc_insertion_point(field_set:PlayerListMessage.playerListNotification)
}

// -------------------------------------------------------------------

// GameListNewMessage

// required uint32 gameId = 1;
inline bool GameListNewMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListNewMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListNewMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameListNewMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListNewMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameId)
  return _internal_gameid();
}
inline void GameListNewMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
}
inline void GameListNewMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.gameId)
}

// required .NetGameMode gameMode = 2;
inline bool GameListNewMessage::_internal_has_gamemode() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GameListNewMessage::has_gamemode() const {
  return _internal_has_gamemode();
}
inline void GameListNewMessage::clear_gamemode() {
  gamemode_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::NetGameMode GameListNewMessage::_internal_gamemode() const {
  return static_cast< ::NetGameMode >(gamemode_);
}
inline ::NetGameMode GameListNewMessage::gamemode() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameMode)
  return _internal_gamemode();
}
inline void GameListNewMessage::_internal_set_gamemode(::NetGameMode value) {
  assert(::NetGameMode_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  gamemode_ = value;
}
inline void GameListNewMessage::set_gamemode(::NetGameMode value) {
  _internal_set_gamemode(value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.gameMode)
}

// required bool isPrivate = 3;
inline bool GameListNewMessage::_internal_has_isprivate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameListNewMessage::has_isprivate() const {
  return _internal_has_isprivate();
}
inline void GameListNewMessage::clear_isprivate() {
  isprivate_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GameListNewMessage::_internal_isprivate() const {
  return isprivate_;
}
inline bool GameListNewMessage::isprivate() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.isPrivate)
  return _internal_isprivate();
}
inline void GameListNewMessage::_internal_set_isprivate(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isprivate_ = value;
}
inline void GameListNewMessage::set_isprivate(bool value) {
  _internal_set_isprivate(value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.isPrivate)
}

// repeated uint32 playerIds = 4 [packed = true];
inline int GameListNewMessage::_internal_playerids_size() const {
  return playerids_.size();
}
inline int GameListNewMessage::playerids_size() const {
  return _internal_playerids_size();
}
inline void GameListNewMessage::clear_playerids() {
  playerids_.Clear();
}
inline uint32_t GameListNewMessage::_internal_playerids(int index) const {
  return playerids_.Get(index);
}
inline uint32_t GameListNewMessage::playerids(int index) const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.playerIds)
  return _internal_playerids(index);
}
inline void GameListNewMessage::set_playerids(int index, uint32_t value) {
  playerids_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.playerIds)
}
inline void GameListNewMessage::_internal_add_playerids(uint32_t value) {
  playerids_.Add(value);
}
inline void GameListNewMessage::add_playerids(uint32_t value) {
  _internal_add_playerids(value);
  // @@protoc_insertion_point(field_add:GameListNewMessage.playerIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameListNewMessage::_internal_playerids() const {
  return playerids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameListNewMessage::playerids() const {
  // @@protoc_insertion_point(field_list:GameListNewMessage.playerIds)
  return _internal_playerids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameListNewMessage::_internal_mutable_playerids() {
  return &playerids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameListNewMessage::mutable_playerids() {
  // @@protoc_insertion_point(field_mutable_list:GameListNewMessage.playerIds)
  return _internal_mutable_playerids();
}

// required uint32 adminPlayerId = 5;
inline bool GameListNewMessage::_internal_has_adminplayerid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameListNewMessage::has_adminplayerid() const {
  return _internal_has_adminplayerid();
}
inline void GameListNewMessage::clear_adminplayerid() {
  adminplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GameListNewMessage::_internal_adminplayerid() const {
  return adminplayerid_;
}
inline uint32_t GameListNewMessage::adminplayerid() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.adminPlayerId)
  return _internal_adminplayerid();
}
inline void GameListNewMessage::_internal_set_adminplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  adminplayerid_ = value;
}
inline void GameListNewMessage::set_adminplayerid(uint32_t value) {
  _internal_set_adminplayerid(value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.adminPlayerId)
}

// required .NetGameInfo gameInfo = 6;
inline bool GameListNewMessage::_internal_has_gameinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gameinfo_ != nullptr);
  return value;
}
inline bool GameListNewMessage::has_gameinfo() const {
  return _internal_has_gameinfo();
}
inline void GameListNewMessage::clear_gameinfo() {
  if (gameinfo_ != nullptr) gameinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::NetGameInfo& GameListNewMessage::_internal_gameinfo() const {
  const ::NetGameInfo* p = gameinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetGameInfo&>(
      ::_NetGameInfo_default_instance_);
}
inline const ::NetGameInfo& GameListNewMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameInfo)
  return _internal_gameinfo();
}
inline void GameListNewMessage::unsafe_arena_set_allocated_gameinfo(
    ::NetGameInfo* gameinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameinfo_);
  }
  gameinfo_ = gameinfo;
  if (gameinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameListNewMessage.gameInfo)
}
inline ::NetGameInfo* GameListNewMessage::release_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NetGameInfo* GameListNewMessage::unsafe_arena_release_gameinfo() {
  // @@protoc_insertion_point(field_release:GameListNewMessage.gameInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
  return temp;
}
inline ::NetGameInfo* GameListNewMessage::_internal_mutable_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetGameInfo>(GetArenaForAllocation());
    gameinfo_ = p;
  }
  return gameinfo_;
}
inline ::NetGameInfo* GameListNewMessage::mutable_gameinfo() {
  ::NetGameInfo* _msg = _internal_mutable_gameinfo();
  // @@protoc_insertion_point(field_mutable:GameListNewMessage.gameInfo)
  return _msg;
}
inline void GameListNewMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameinfo_;
  }
  if (gameinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::NetGameInfo>::GetOwningArena(gameinfo);
    if (message_arena != submessage_arena) {
      gameinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:GameListNewMessage.gameInfo)
}

// repeated uint32 spectatorIds = 7 [packed = true];
inline int GameListNewMessage::_internal_spectatorids_size() const {
  return spectatorids_.size();
}
inline int GameListNewMessage::spectatorids_size() const {
  return _internal_spectatorids_size();
}
inline void GameListNewMessage::clear_spectatorids() {
  spectatorids_.Clear();
}
inline uint32_t GameListNewMessage::_internal_spectatorids(int index) const {
  return spectatorids_.Get(index);
}
inline uint32_t GameListNewMessage::spectatorids(int index) const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.spectatorIds)
  return _internal_spectatorids(index);
}
inline void GameListNewMessage::set_spectatorids(int index, uint32_t value) {
  spectatorids_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.spectatorIds)
}
inline void GameListNewMessage::_internal_add_spectatorids(uint32_t value) {
  spectatorids_.Add(value);
}
inline void GameListNewMessage::add_spectatorids(uint32_t value) {
  _internal_add_spectatorids(value);
  // @@protoc_insertion_point(field_add:GameListNewMessage.spectatorIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameListNewMessage::_internal_spectatorids() const {
  return spectatorids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameListNewMessage::spectatorids() const {
  // @@protoc_insertion_point(field_list:GameListNewMessage.spectatorIds)
  return _internal_spectatorids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameListNewMessage::_internal_mutable_spectatorids() {
  return &spectatorids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameListNewMessage::mutable_spectatorids() {
  // @@protoc_insertion_point(field_mutable_list:GameListNewMessage.spectatorIds)
  return _internal_mutable_spectatorids();
}

// -------------------------------------------------------------------

// GameListUpdateMessage

// required uint32 gameId = 1;
inline bool GameListUpdateMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListUpdateMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameListUpdateMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListUpdateMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListUpdateMessage.gameId)
  return _internal_gameid();
}
inline void GameListUpdateMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameListUpdateMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListUpdateMessage.gameId)
}

// required .NetGameMode gameMode = 2;
inline bool GameListUpdateMessage::_internal_has_gamemode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListUpdateMessage::has_gamemode() const {
  return _internal_has_gamemode();
}
inline void GameListUpdateMessage::clear_gamemode() {
  gamemode_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::NetGameMode GameListUpdateMessage::_internal_gamemode() const {
  return static_cast< ::NetGameMode >(gamemode_);
}
inline ::NetGameMode GameListUpdateMessage::gamemode() const {
  // @@protoc_insertion_point(field_get:GameListUpdateMessage.gameMode)
  return _internal_gamemode();
}
inline void GameListUpdateMessage::_internal_set_gamemode(::NetGameMode value) {
  assert(::NetGameMode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  gamemode_ = value;
}
inline void GameListUpdateMessage::set_gamemode(::NetGameMode value) {
  _internal_set_gamemode(value);
  // @@protoc_insertion_point(field_set:GameListUpdateMessage.gameMode)
}

// -------------------------------------------------------------------

// GameListPlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GameListPlayerJoinedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListPlayerJoinedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListPlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameListPlayerJoinedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListPlayerJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerJoinedMessage.gameId)
  return _internal_gameid();
}
inline void GameListPlayerJoinedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameListPlayerJoinedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListPlayerJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListPlayerJoinedMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListPlayerJoinedMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameListPlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameListPlayerJoinedMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameListPlayerJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerJoinedMessage.playerId)
  return _internal_playerid();
}
inline void GameListPlayerJoinedMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GameListPlayerJoinedMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameListPlayerJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameListPlayerLeftMessage

// required uint32 gameId = 1;
inline bool GameListPlayerLeftMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListPlayerLeftMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListPlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameListPlayerLeftMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListPlayerLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerLeftMessage.gameId)
  return _internal_gameid();
}
inline void GameListPlayerLeftMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameListPlayerLeftMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListPlayerLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListPlayerLeftMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListPlayerLeftMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameListPlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameListPlayerLeftMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameListPlayerLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerLeftMessage.playerId)
  return _internal_playerid();
}
inline void GameListPlayerLeftMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GameListPlayerLeftMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameListPlayerLeftMessage.playerId)
}

// -------------------------------------------------------------------

// GameListSpectatorJoinedMessage

// required uint32 gameId = 1;
inline bool GameListSpectatorJoinedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListSpectatorJoinedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListSpectatorJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameListSpectatorJoinedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListSpectatorJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorJoinedMessage.gameId)
  return _internal_gameid();
}
inline void GameListSpectatorJoinedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameListSpectatorJoinedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListSpectatorJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListSpectatorJoinedMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListSpectatorJoinedMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameListSpectatorJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameListSpectatorJoinedMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameListSpectatorJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorJoinedMessage.playerId)
  return _internal_playerid();
}
inline void GameListSpectatorJoinedMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GameListSpectatorJoinedMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameListSpectatorJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameListSpectatorLeftMessage

// required uint32 gameId = 1;
inline bool GameListSpectatorLeftMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListSpectatorLeftMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListSpectatorLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameListSpectatorLeftMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListSpectatorLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorLeftMessage.gameId)
  return _internal_gameid();
}
inline void GameListSpectatorLeftMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameListSpectatorLeftMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListSpectatorLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListSpectatorLeftMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListSpectatorLeftMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameListSpectatorLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameListSpectatorLeftMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameListSpectatorLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorLeftMessage.playerId)
  return _internal_playerid();
}
inline void GameListSpectatorLeftMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GameListSpectatorLeftMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameListSpectatorLeftMessage.playerId)
}

// -------------------------------------------------------------------

// GameListAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameListAdminChangedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListAdminChangedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameListAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameListAdminChangedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameListAdminChangedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListAdminChangedMessage.gameId)
  return _internal_gameid();
}
inline void GameListAdminChangedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameListAdminChangedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameListAdminChangedMessage.gameId)
}

// required uint32 newAdminPlayerId = 2;
inline bool GameListAdminChangedMessage::_internal_has_newadminplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameListAdminChangedMessage::has_newadminplayerid() const {
  return _internal_has_newadminplayerid();
}
inline void GameListAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameListAdminChangedMessage::_internal_newadminplayerid() const {
  return newadminplayerid_;
}
inline uint32_t GameListAdminChangedMessage::newadminplayerid() const {
  // @@protoc_insertion_point(field_get:GameListAdminChangedMessage.newAdminPlayerId)
  return _internal_newadminplayerid();
}
inline void GameListAdminChangedMessage::_internal_set_newadminplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  newadminplayerid_ = value;
}
inline void GameListAdminChangedMessage::set_newadminplayerid(uint32_t value) {
  _internal_set_newadminplayerid(value);
  // @@protoc_insertion_point(field_set:GameListAdminChangedMessage.newAdminPlayerId)
}

// -------------------------------------------------------------------

// PlayerInfoRequestMessage

// repeated uint32 playerId = 1 [packed = true];
inline int PlayerInfoRequestMessage::_internal_playerid_size() const {
  return playerid_.size();
}
inline int PlayerInfoRequestMessage::playerid_size() const {
  return _internal_playerid_size();
}
inline void PlayerInfoRequestMessage::clear_playerid() {
  playerid_.Clear();
}
inline uint32_t PlayerInfoRequestMessage::_internal_playerid(int index) const {
  return playerid_.Get(index);
}
inline uint32_t PlayerInfoRequestMessage::playerid(int index) const {
  // @@protoc_insertion_point(field_get:PlayerInfoRequestMessage.playerId)
  return _internal_playerid(index);
}
inline void PlayerInfoRequestMessage::set_playerid(int index, uint32_t value) {
  playerid_.Set(index, value);
  // @@protoc_insertion_point(field_set:PlayerInfoRequestMessage.playerId)
}
inline void PlayerInfoRequestMessage::_internal_add_playerid(uint32_t value) {
  playerid_.Add(value);
}
inline void PlayerInfoRequestMessage::add_playerid(uint32_t value) {
  _internal_add_playerid(value);
  // @@protoc_insertion_point(field_add:PlayerInfoRequestMessage.playerId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerInfoRequestMessage::_internal_playerid() const {
  return playerid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerInfoRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_list:PlayerInfoRequestMessage.playerId)
  return _internal_playerid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerInfoRequestMessage::_internal_mutable_playerid() {
  return &playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerInfoRequestMessage::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable_list:PlayerInfoRequestMessage.playerId)
  return _internal_mutable_playerid();
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData_AvatarData

// required .NetAvatarType avatarType = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_has_avatartype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatartype() const {
  return _internal_has_avatartype();
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatartype() {
  avatartype_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::NetAvatarType PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_avatartype() const {
  return static_cast< ::NetAvatarType >(avatartype_);
}
inline ::NetAvatarType PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatartype() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarType)
  return _internal_avatartype();
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_set_avatartype(::NetAvatarType value) {
  assert(::NetAvatarType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  avatartype_ = value;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatartype(::NetAvatarType value) {
  _internal_set_avatartype(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarType)
}

// required bytes avatarHash = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_has_avatarhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatarhash() const {
  return _internal_has_avatarhash();
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatarhash() {
  avatarhash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatarhash() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  return _internal_avatarhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 avatarhash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::mutable_avatarhash() {
  std::string* _s = _internal_mutable_avatarhash();
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  return _s;
}
inline const std::string& PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_avatarhash() const {
  return avatarhash_.Get();
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_set_avatarhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::_internal_mutable_avatarhash() {
  _has_bits_[0] |= 0x00000001u;
  return avatarhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::release_avatarhash() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  if (!_internal_has_avatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = avatarhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_allocated_avatarhash(std::string* avatarhash) {
  if (avatarhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatarhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatarhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData

// required string playerName = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData::_internal_has_playername() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playername() const {
  return _internal_has_playername();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playername() {
  playername_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerInfoReplyMessage_PlayerInfoData::playername() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfoReplyMessage_PlayerInfoData::set_playername(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 playername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  return _s;
}
inline const std::string& PlayerInfoReplyMessage_PlayerInfoData::_internal_playername() const {
  return playername_.Get();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::_internal_set_playername(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData::_internal_mutable_playername() {
  _has_bits_[0] |= 0x00000001u;
  return playername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData::release_playername() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  if (!_internal_has_playername()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = playername_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (playername_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    playername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playername,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (playername_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    playername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}

// required bool isHuman = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData::_internal_has_ishuman() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_ishuman() const {
  return _internal_has_ishuman();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_ishuman() {
  ishuman_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::_internal_ishuman() const {
  return ishuman_;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::ishuman() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.isHuman)
  return _internal_ishuman();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::_internal_set_ishuman(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ishuman_ = value;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_ishuman(bool value) {
  _internal_set_ishuman(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.isHuman)
}

// required .NetPlayerInfoRights playerRights = 3;
inline bool PlayerInfoReplyMessage_PlayerInfoData::_internal_has_playerrights() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playerrights() const {
  return _internal_has_playerrights();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playerrights() {
  playerrights_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::NetPlayerInfoRights PlayerInfoReplyMessage_PlayerInfoData::_internal_playerrights() const {
  return static_cast< ::NetPlayerInfoRights >(playerrights_);
}
inline ::NetPlayerInfoRights PlayerInfoReplyMessage_PlayerInfoData::playerrights() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.playerRights)
  return _internal_playerrights();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::_internal_set_playerrights(::NetPlayerInfoRights value) {
  assert(::NetPlayerInfoRights_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  playerrights_ = value;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playerrights(::NetPlayerInfoRights value) {
  _internal_set_playerrights(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.playerRights)
}

// optional string countryCode = 4;
inline bool PlayerInfoReplyMessage_PlayerInfoData::_internal_has_countrycode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_countrycode() const {
  return _internal_has_countrycode();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_countrycode() {
  countrycode_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PlayerInfoReplyMessage_PlayerInfoData::countrycode() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  return _internal_countrycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 countrycode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_countrycode() {
  std::string* _s = _internal_mutable_countrycode();
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  return _s;
}
inline const std::string& PlayerInfoReplyMessage_PlayerInfoData::_internal_countrycode() const {
  return countrycode_.Get();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::_internal_set_countrycode(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  countrycode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData::_internal_mutable_countrycode() {
  _has_bits_[0] |= 0x00000002u;
  return countrycode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfoReplyMessage_PlayerInfoData::release_countrycode() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  if (!_internal_has_countrycode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = countrycode_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (countrycode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    countrycode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_countrycode(std::string* countrycode) {
  if (countrycode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  countrycode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), countrycode,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (countrycode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    countrycode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}

// optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
inline bool PlayerInfoReplyMessage_PlayerInfoData::_internal_has_avatardata() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || avatardata_ != nullptr);
  return value;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_avatardata() const {
  return _internal_has_avatardata();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_avatardata() {
  if (avatardata_ != nullptr) avatardata_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& PlayerInfoReplyMessage_PlayerInfoData::_internal_avatardata() const {
  const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* p = avatardata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData&>(
      ::_PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_);
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& PlayerInfoReplyMessage_PlayerInfoData::avatardata() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  return _internal_avatardata();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::unsafe_arena_set_allocated_avatardata(
    ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(avatardata_);
  }
  avatardata_ = avatardata;
  if (avatardata) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::release_avatardata() {
  _has_bits_[0] &= ~0x00000004u;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* temp = avatardata_;
  avatardata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::unsafe_arena_release_avatardata() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  _has_bits_[0] &= ~0x00000004u;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* temp = avatardata_;
  avatardata_ = nullptr;
  return temp;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::_internal_mutable_avatardata() {
  _has_bits_[0] |= 0x00000004u;
  if (avatardata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(GetArenaForAllocation());
    avatardata_ = p;
  }
  return avatardata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::mutable_avatardata() {
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* _msg = _internal_mutable_avatardata();
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  return _msg;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_avatardata(::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete avatardata_;
  }
  if (avatardata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerInfoReplyMessage_PlayerInfoData_AvatarData>::GetOwningArena(avatardata);
    if (message_arena != submessage_arena) {
      avatardata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avatardata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  avatardata_ = avatardata;
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage

// required uint32 playerId = 1;
inline bool PlayerInfoReplyMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerInfoReplyMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerInfoReplyMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PlayerInfoReplyMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t PlayerInfoReplyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.playerId)
  return _internal_playerid();
}
inline void PlayerInfoReplyMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void PlayerInfoReplyMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.playerId)
}

// optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
inline bool PlayerInfoReplyMessage::_internal_has_playerinfodata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || playerinfodata_ != nullptr);
  return value;
}
inline bool PlayerInfoReplyMessage::has_playerinfodata() const {
  return _internal_has_playerinfodata();
}
inline void PlayerInfoReplyMessage::clear_playerinfodata() {
  if (playerinfodata_ != nullptr) playerinfodata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData& PlayerInfoReplyMessage::_internal_playerinfodata() const {
  const ::PlayerInfoReplyMessage_PlayerInfoData* p = playerinfodata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoReplyMessage_PlayerInfoData&>(
      ::_PlayerInfoReplyMessage_PlayerInfoData_default_instance_);
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData& PlayerInfoReplyMessage::playerinfodata() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.playerInfoData)
  return _internal_playerinfodata();
}
inline void PlayerInfoReplyMessage::unsafe_arena_set_allocated_playerinfodata(
    ::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinfodata_);
  }
  playerinfodata_ = playerinfodata;
  if (playerinfodata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerInfoReplyMessage.playerInfoData)
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::release_playerinfodata() {
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoReplyMessage_PlayerInfoData* temp = playerinfodata_;
  playerinfodata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::unsafe_arena_release_playerinfodata() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.playerInfoData)
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoReplyMessage_PlayerInfoData* temp = playerinfodata_;
  playerinfodata_ = nullptr;
  return temp;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::_internal_mutable_playerinfodata() {
  _has_bits_[0] |= 0x00000001u;
  if (playerinfodata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData>(GetArenaForAllocation());
    playerinfodata_ = p;
  }
  return playerinfodata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::mutable_playerinfodata() {
  ::PlayerInfoReplyMessage_PlayerInfoData* _msg = _internal_mutable_playerinfodata();
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.playerInfoData)
  return _msg;
}
inline void PlayerInfoReplyMessage::set_allocated_playerinfodata(::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerinfodata_;
  }
  if (playerinfodata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerInfoReplyMessage_PlayerInfoData>::GetOwningArena(playerinfodata);
    if (message_arena != submessage_arena) {
      playerinfodata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinfodata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerinfodata_ = playerinfodata;
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.playerInfoData)
}

// -------------------------------------------------------------------

// SubscriptionRequestMessage

// required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
inline bool SubscriptionRequestMessage::_internal_has_subscriptionaction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscriptionRequestMessage::has_subscriptionaction() const {
  return _internal_has_subscriptionaction();
}
inline void SubscriptionRequestMessage::clear_subscriptionaction() {
  subscriptionaction_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::_internal_subscriptionaction() const {
  return static_cast< ::SubscriptionRequestMessage_SubscriptionAction >(subscriptionaction_);
}
inline ::SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::subscriptionaction() const {
  // @@protoc_insertion_point(field_get:SubscriptionRequestMessage.subscriptionAction)
  return _internal_subscriptionaction();
}
inline void SubscriptionRequestMessage::_internal_set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value) {
  assert(::SubscriptionRequestMessage_SubscriptionAction_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  subscriptionaction_ = value;
}
inline void SubscriptionRequestMessage::set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value) {
  _internal_set_subscriptionaction(value);
  // @@protoc_insertion_point(field_set:SubscriptionRequestMessage.subscriptionAction)
}

// -------------------------------------------------------------------

// JoinExistingGameMessage

// required uint32 gameId = 1;
inline bool JoinExistingGameMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinExistingGameMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void JoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t JoinExistingGameMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t JoinExistingGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.gameId)
  return _internal_gameid();
}
inline void JoinExistingGameMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
}
inline void JoinExistingGameMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.gameId)
}

// optional string password = 2;
inline bool JoinExistingGameMessage::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinExistingGameMessage::has_password() const {
  return _internal_has_password();
}
inline void JoinExistingGameMessage::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JoinExistingGameMessage::password() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinExistingGameMessage::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.password)
}
inline std::string* JoinExistingGameMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:JoinExistingGameMessage.password)
  return _s;
}
inline const std::string& JoinExistingGameMessage::_internal_password() const {
  return password_.Get();
}
inline void JoinExistingGameMessage::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinExistingGameMessage::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinExistingGameMessage::release_password() {
  // @@protoc_insertion_point(field_release:JoinExistingGameMessage.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinExistingGameMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JoinExistingGameMessage.password)
}

// optional bool autoLeave = 3 [default = false];
inline bool JoinExistingGameMessage::_internal_has_autoleave() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinExistingGameMessage::has_autoleave() const {
  return _internal_has_autoleave();
}
inline void JoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool JoinExistingGameMessage::_internal_autoleave() const {
  return autoleave_;
}
inline bool JoinExistingGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.autoLeave)
  return _internal_autoleave();
}
inline void JoinExistingGameMessage::_internal_set_autoleave(bool value) {
  _has_bits_[0] |= 0x00000004u;
  autoleave_ = value;
}
inline void JoinExistingGameMessage::set_autoleave(bool value) {
  _internal_set_autoleave(value);
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.autoLeave)
}

// optional bool spectateOnly = 4 [default = false];
inline bool JoinExistingGameMessage::_internal_has_spectateonly() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool JoinExistingGameMessage::has_spectateonly() const {
  return _internal_has_spectateonly();
}
inline void JoinExistingGameMessage::clear_spectateonly() {
  spectateonly_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool JoinExistingGameMessage::_internal_spectateonly() const {
  return spectateonly_;
}
inline bool JoinExistingGameMessage::spectateonly() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.spectateOnly)
  return _internal_spectateonly();
}
inline void JoinExistingGameMessage::_internal_set_spectateonly(bool value) {
  _has_bits_[0] |= 0x00000008u;
  spectateonly_ = value;
}
inline void JoinExistingGameMessage::set_spectateonly(bool value) {
  _internal_set_spectateonly(value);
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.spectateOnly)
}

// -------------------------------------------------------------------

// JoinNewGameMessage

// required .NetGameInfo gameInfo = 1;
inline bool JoinNewGameMessage::_internal_has_gameinfo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || gameinfo_ != nullptr);
  return value;
}
inline bool JoinNewGameMessage::has_gameinfo() const {
  return _internal_has_gameinfo();
}
inline void JoinNewGameMessage::clear_gameinfo() {
  if (gameinfo_ != nullptr) gameinfo_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::NetGameInfo& JoinNewGameMessage::_internal_gameinfo() const {
  const ::NetGameInfo* p = gameinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetGameInfo&>(
      ::_NetGameInfo_default_instance_);
}
inline const ::NetGameInfo& JoinNewGameMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.gameInfo)
  return _internal_gameinfo();
}
inline void JoinNewGameMessage::unsafe_arena_set_allocated_gameinfo(
    ::NetGameInfo* gameinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameinfo_);
  }
  gameinfo_ = gameinfo;
  if (gameinfo) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JoinNewGameMessage.gameInfo)
}
inline ::NetGameInfo* JoinNewGameMessage::release_gameinfo() {
  _has_bits_[0] &= ~0x00000002u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NetGameInfo* JoinNewGameMessage::unsafe_arena_release_gameinfo() {
  // @@protoc_insertion_point(field_release:JoinNewGameMessage.gameInfo)
  _has_bits_[0] &= ~0x00000002u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
  return temp;
}
inline ::NetGameInfo* JoinNewGameMessage::_internal_mutable_gameinfo() {
  _has_bits_[0] |= 0x00000002u;
  if (gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetGameInfo>(GetArenaForAllocation());
    gameinfo_ = p;
  }
  return gameinfo_;
}
inline ::NetGameInfo* JoinNewGameMessage::mutable_gameinfo() {
  ::NetGameInfo* _msg = _internal_mutable_gameinfo();
  // @@protoc_insertion_point(field_mutable:JoinNewGameMessage.gameInfo)
  return _msg;
}
inline void JoinNewGameMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameinfo_;
  }
  if (gameinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::NetGameInfo>::GetOwningArena(gameinfo);
    if (message_arena != submessage_arena) {
      gameinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:JoinNewGameMessage.gameInfo)
}

// optional string password = 2;
inline bool JoinNewGameMessage::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinNewGameMessage::has_password() const {
  return _internal_has_password();
}
inline void JoinNewGameMessage::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JoinNewGameMessage::password() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinNewGameMessage::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JoinNewGameMessage.password)
}
inline std::string* JoinNewGameMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:JoinNewGameMessage.password)
  return _s;
}
inline const std::string& JoinNewGameMessage::_internal_password() const {
  return password_.Get();
}
inline void JoinNewGameMessage::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinNewGameMessage::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinNewGameMessage::release_password() {
  // @@protoc_insertion_point(field_release:JoinNewGameMessage.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinNewGameMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JoinNewGameMessage.password)
}

// optional bool autoLeave = 3;
inline bool JoinNewGameMessage::_internal_has_autoleave() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinNewGameMessage::has_autoleave() const {
  return _internal_has_autoleave();
}
inline void JoinNewGameMessage::clear_autoleave() {
  autoleave_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool JoinNewGameMessage::_internal_autoleave() const {
  return autoleave_;
}
inline bool JoinNewGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.autoLeave)
  return _internal_autoleave();
}
inline void JoinNewGameMessage::_internal_set_autoleave(bool value) {
  _has_bits_[0] |= 0x00000004u;
  autoleave_ = value;
}
inline void JoinNewGameMessage::set_autoleave(bool value) {
  _internal_set_autoleave(value);
  // @@protoc_insertion_point(field_set:JoinNewGameMessage.autoLeave)
}

// -------------------------------------------------------------------

// RejoinExistingGameMessage

// required uint32 gameId = 1;
inline bool RejoinExistingGameMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RejoinExistingGameMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void RejoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RejoinExistingGameMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t RejoinExistingGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejoinExistingGameMessage.gameId)
  return _internal_gameid();
}
inline void RejoinExistingGameMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void RejoinExistingGameMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:RejoinExistingGameMessage.gameId)
}

// optional bool autoLeave = 2;
inline bool RejoinExistingGameMessage::_internal_has_autoleave() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RejoinExistingGameMessage::has_autoleave() const {
  return _internal_has_autoleave();
}
inline void RejoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RejoinExistingGameMessage::_internal_autoleave() const {
  return autoleave_;
}
inline bool RejoinExistingGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:RejoinExistingGameMessage.autoLeave)
  return _internal_autoleave();
}
inline void RejoinExistingGameMessage::_internal_set_autoleave(bool value) {
  _has_bits_[0] |= 0x00000002u;
  autoleave_ = value;
}
inline void RejoinExistingGameMessage::set_autoleave(bool value) {
  _internal_set_autoleave(value);
  // @@protoc_insertion_point(field_set:RejoinExistingGameMessage.autoLeave)
}

// -------------------------------------------------------------------

// JoinGameAckMessage

// required uint32 gameId = 1;
inline bool JoinGameAckMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinGameAckMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void JoinGameAckMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t JoinGameAckMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t JoinGameAckMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.gameId)
  return _internal_gameid();
}
inline void JoinGameAckMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
}
inline void JoinGameAckMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.gameId)
}

// required bool areYouGameAdmin = 2;
inline bool JoinGameAckMessage::_internal_has_areyougameadmin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinGameAckMessage::has_areyougameadmin() const {
  return _internal_has_areyougameadmin();
}
inline void JoinGameAckMessage::clear_areyougameadmin() {
  areyougameadmin_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool JoinGameAckMessage::_internal_areyougameadmin() const {
  return areyougameadmin_;
}
inline bool JoinGameAckMessage::areyougameadmin() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.areYouGameAdmin)
  return _internal_areyougameadmin();
}
inline void JoinGameAckMessage::_internal_set_areyougameadmin(bool value) {
  _has_bits_[0] |= 0x00000004u;
  areyougameadmin_ = value;
}
inline void JoinGameAckMessage::set_areyougameadmin(bool value) {
  _internal_set_areyougameadmin(value);
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.areYouGameAdmin)
}

// required .NetGameInfo gameInfo = 3;
inline bool JoinGameAckMessage::_internal_has_gameinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gameinfo_ != nullptr);
  return value;
}
inline bool JoinGameAckMessage::has_gameinfo() const {
  return _internal_has_gameinfo();
}
inline void JoinGameAckMessage::clear_gameinfo() {
  if (gameinfo_ != nullptr) gameinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::NetGameInfo& JoinGameAckMessage::_internal_gameinfo() const {
  const ::NetGameInfo* p = gameinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetGameInfo&>(
      ::_NetGameInfo_default_instance_);
}
inline const ::NetGameInfo& JoinGameAckMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.gameInfo)
  return _internal_gameinfo();
}
inline void JoinGameAckMessage::unsafe_arena_set_allocated_gameinfo(
    ::NetGameInfo* gameinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameinfo_);
  }
  gameinfo_ = gameinfo;
  if (gameinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JoinGameAckMessage.gameInfo)
}
inline ::NetGameInfo* JoinGameAckMessage::release_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NetGameInfo* JoinGameAckMessage::unsafe_arena_release_gameinfo() {
  // @@protoc_insertion_point(field_release:JoinGameAckMessage.gameInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
  return temp;
}
inline ::NetGameInfo* JoinGameAckMessage::_internal_mutable_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetGameInfo>(GetArenaForAllocation());
    gameinfo_ = p;
  }
  return gameinfo_;
}
inline ::NetGameInfo* JoinGameAckMessage::mutable_gameinfo() {
  ::NetGameInfo* _msg = _internal_mutable_gameinfo();
  // @@protoc_insertion_point(field_mutable:JoinGameAckMessage.gameInfo)
  return _msg;
}
inline void JoinGameAckMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameinfo_;
  }
  if (gameinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::NetGameInfo>::GetOwningArena(gameinfo);
    if (message_arena != submessage_arena) {
      gameinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:JoinGameAckMessage.gameInfo)
}

// optional bool spectateOnly = 4;
inline bool JoinGameAckMessage::_internal_has_spectateonly() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool JoinGameAckMessage::has_spectateonly() const {
  return _internal_has_spectateonly();
}
inline void JoinGameAckMessage::clear_spectateonly() {
  spectateonly_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool JoinGameAckMessage::_internal_spectateonly() const {
  return spectateonly_;
}
inline bool JoinGameAckMessage::spectateonly() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.spectateOnly)
  return _internal_spectateonly();
}
inline void JoinGameAckMessage::_internal_set_spectateonly(bool value) {
  _has_bits_[0] |= 0x00000008u;
  spectateonly_ = value;
}
inline void JoinGameAckMessage::set_spectateonly(bool value) {
  _internal_set_spectateonly(value);
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.spectateOnly)
}

// -------------------------------------------------------------------

// JoinGameFailedMessage

// required uint32 gameId = 1;
inline bool JoinGameFailedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinGameFailedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void JoinGameFailedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t JoinGameFailedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t JoinGameFailedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinGameFailedMessage.gameId)
  return _internal_gameid();
}
inline void JoinGameFailedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void JoinGameFailedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:JoinGameFailedMessage.gameId)
}

// required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
inline bool JoinGameFailedMessage::_internal_has_joingamefailurereason() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinGameFailedMessage::has_joingamefailurereason() const {
  return _internal_has_joingamefailurereason();
}
inline void JoinGameFailedMessage::clear_joingamefailurereason() {
  joingamefailurereason_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::_internal_joingamefailurereason() const {
  return static_cast< ::JoinGameFailedMessage_JoinGameFailureReason >(joingamefailurereason_);
}
inline ::JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::joingamefailurereason() const {
  // @@protoc_insertion_point(field_get:JoinGameFailedMessage.joinGameFailureReason)
  return _internal_joingamefailurereason();
}
inline void JoinGameFailedMessage::_internal_set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value) {
  assert(::JoinGameFailedMessage_JoinGameFailureReason_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  joingamefailurereason_ = value;
}
inline void JoinGameFailedMessage::set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value) {
  _internal_set_joingamefailurereason(value);
  // @@protoc_insertion_point(field_set:JoinGameFailedMessage.joinGameFailureReason)
}

// -------------------------------------------------------------------

// GamePlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GamePlayerJoinedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GamePlayerJoinedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GamePlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GamePlayerJoinedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GamePlayerJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.gameId)
  return _internal_gameid();
}
inline void GamePlayerJoinedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GamePlayerJoinedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GamePlayerJoinedMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GamePlayerJoinedMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GamePlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GamePlayerJoinedMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GamePlayerJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.playerId)
  return _internal_playerid();
}
inline void GamePlayerJoinedMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GamePlayerJoinedMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.playerId)
}

// required bool isGameAdmin = 3;
inline bool GamePlayerJoinedMessage::_internal_has_isgameadmin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GamePlayerJoinedMessage::has_isgameadmin() const {
  return _internal_has_isgameadmin();
}
inline void GamePlayerJoinedMessage::clear_isgameadmin() {
  isgameadmin_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GamePlayerJoinedMessage::_internal_isgameadmin() const {
  return isgameadmin_;
}
inline bool GamePlayerJoinedMessage::isgameadmin() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.isGameAdmin)
  return _internal_isgameadmin();
}
inline void GamePlayerJoinedMessage::_internal_set_isgameadmin(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isgameadmin_ = value;
}
inline void GamePlayerJoinedMessage::set_isgameadmin(bool value) {
  _internal_set_isgameadmin(value);
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.isGameAdmin)
}

// -------------------------------------------------------------------

// GamePlayerLeftMessage

// required uint32 gameId = 1;
inline bool GamePlayerLeftMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GamePlayerLeftMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GamePlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GamePlayerLeftMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GamePlayerLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.gameId)
  return _internal_gameid();
}
inline void GamePlayerLeftMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GamePlayerLeftMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GamePlayerLeftMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GamePlayerLeftMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GamePlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GamePlayerLeftMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GamePlayerLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.playerId)
  return _internal_playerid();
}
inline void GamePlayerLeftMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GamePlayerLeftMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.playerId)
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
inline bool GamePlayerLeftMessage::_internal_has_gameplayerleftreason() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GamePlayerLeftMessage::has_gameplayerleftreason() const {
  return _internal_has_gameplayerleftreason();
}
inline void GamePlayerLeftMessage::clear_gameplayerleftreason() {
  gameplayerleftreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::_internal_gameplayerleftreason() const {
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gameplayerleftreason_);
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::gameplayerleftreason() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.gamePlayerLeftReason)
  return _internal_gameplayerleftreason();
}
inline void GamePlayerLeftMessage::_internal_set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  assert(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gameplayerleftreason_ = value;
}
inline void GamePlayerLeftMessage::set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  _internal_set_gameplayerleftreason(value);
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.gamePlayerLeftReason)
}

// -------------------------------------------------------------------

// GameSpectatorJoinedMessage

// required uint32 gameId = 1;
inline bool GameSpectatorJoinedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameSpectatorJoinedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameSpectatorJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameSpectatorJoinedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameSpectatorJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorJoinedMessage.gameId)
  return _internal_gameid();
}
inline void GameSpectatorJoinedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameSpectatorJoinedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameSpectatorJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameSpectatorJoinedMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameSpectatorJoinedMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameSpectatorJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameSpectatorJoinedMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameSpectatorJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorJoinedMessage.playerId)
  return _internal_playerid();
}
inline void GameSpectatorJoinedMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GameSpectatorJoinedMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameSpectatorJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameSpectatorLeftMessage

// required uint32 gameId = 1;
inline bool GameSpectatorLeftMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameSpectatorLeftMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameSpectatorLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameSpectatorLeftMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameSpectatorLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.gameId)
  return _internal_gameid();
}
inline void GameSpectatorLeftMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameSpectatorLeftMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameSpectatorLeftMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameSpectatorLeftMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameSpectatorLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameSpectatorLeftMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameSpectatorLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.playerId)
  return _internal_playerid();
}
inline void GameSpectatorLeftMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void GameSpectatorLeftMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.playerId)
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
inline bool GameSpectatorLeftMessage::_internal_has_gamespectatorleftreason() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameSpectatorLeftMessage::has_gamespectatorleftreason() const {
  return _internal_has_gamespectatorleftreason();
}
inline void GameSpectatorLeftMessage::clear_gamespectatorleftreason() {
  gamespectatorleftreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GameSpectatorLeftMessage::_internal_gamespectatorleftreason() const {
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gamespectatorleftreason_);
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GameSpectatorLeftMessage::gamespectatorleftreason() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.gameSpectatorLeftReason)
  return _internal_gamespectatorleftreason();
}
inline void GameSpectatorLeftMessage::_internal_set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  assert(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamespectatorleftreason_ = value;
}
inline void GameSpectatorLeftMessage::set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  _internal_set_gamespectatorleftreason(value);
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.gameSpectatorLeftReason)
}

// -------------------------------------------------------------------

// GameAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameAdminChangedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameAdminChangedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameAdminChangedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameAdminChangedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameAdminChangedMessage.gameId)
  return _internal_gameid();
}
inline void GameAdminChangedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameAdminChangedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameAdminChangedMessage.gameId)
}

// required uint32 newAdminPlayerId = 2;
inline bool GameAdminChangedMessage::_internal_has_newadminplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameAdminChangedMessage::has_newadminplayerid() const {
  return _internal_has_newadminplayerid();
}
inline void GameAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameAdminChangedMessage::_internal_newadminplayerid() const {
  return newadminplayerid_;
}
inline uint32_t GameAdminChangedMessage::newadminplayerid() const {
  // @@protoc_insertion_point(field_get:GameAdminChangedMessage.newAdminPlayerId)
  return _internal_newadminplayerid();
}
inline void GameAdminChangedMessage::_internal_set_newadminplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  newadminplayerid_ = value;
}
inline void GameAdminChangedMessage::set_newadminplayerid(uint32_t value) {
  _internal_set_newadminplayerid(value);
  // @@protoc_insertion_point(field_set:GameAdminChangedMessage.newAdminPlayerId)
}

// -------------------------------------------------------------------

// RemovedFromGameMessage

// required uint32 gameId = 1;
inline bool RemovedFromGameMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemovedFromGameMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void RemovedFromGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RemovedFromGameMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t RemovedFromGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RemovedFromGameMessage.gameId)
  return _internal_gameid();
}
inline void RemovedFromGameMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void RemovedFromGameMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:RemovedFromGameMessage.gameId)
}

// required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
inline bool RemovedFromGameMessage::_internal_has_removedfromgamereason() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemovedFromGameMessage::has_removedfromgamereason() const {
  return _internal_has_removedfromgamereason();
}
inline void RemovedFromGameMessage::clear_removedfromgamereason() {
  removedfromgamereason_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::_internal_removedfromgamereason() const {
  return static_cast< ::RemovedFromGameMessage_RemovedFromGameReason >(removedfromgamereason_);
}
inline ::RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::removedfromgamereason() const {
  // @@protoc_insertion_point(field_get:RemovedFromGameMessage.removedFromGameReason)
  return _internal_removedfromgamereason();
}
inline void RemovedFromGameMessage::_internal_set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value) {
  assert(::RemovedFromGameMessage_RemovedFromGameReason_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  removedfromgamereason_ = value;
}
inline void RemovedFromGameMessage::set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value) {
  _internal_set_removedfromgamereason(value);
  // @@protoc_insertion_point(field_set:RemovedFromGameMessage.removedFromGameReason)
}

// -------------------------------------------------------------------

// KickPlayerRequestMessage

// required uint32 gameId = 1;
inline bool KickPlayerRequestMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickPlayerRequestMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void KickPlayerRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t KickPlayerRequestMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t KickPlayerRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:KickPlayerRequestMessage.gameId)
  return _internal_gameid();
}
inline void KickPlayerRequestMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void KickPlayerRequestMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:KickPlayerRequestMessage.gameId)
}

// required uint32 playerId = 2;
inline bool KickPlayerRequestMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KickPlayerRequestMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void KickPlayerRequestMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t KickPlayerRequestMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t KickPlayerRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_get:KickPlayerRequestMessage.playerId)
  return _internal_playerid();
}
inline void KickPlayerRequestMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void KickPlayerRequestMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:KickPlayerRequestMessage.playerId)
}

// -------------------------------------------------------------------

// LeaveGameRequestMessage

// required uint32 gameId = 1;
inline bool LeaveGameRequestMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LeaveGameRequestMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void LeaveGameRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t LeaveGameRequestMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t LeaveGameRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:LeaveGameRequestMessage.gameId)
  return _internal_gameid();
}
inline void LeaveGameRequestMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void LeaveGameRequestMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:LeaveGameRequestMessage.gameId)
}

// -------------------------------------------------------------------

// InvitePlayerToGameMessage

// required uint32 gameId = 1;
inline bool InvitePlayerToGameMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InvitePlayerToGameMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void InvitePlayerToGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t InvitePlayerToGameMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t InvitePlayerToGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:InvitePlayerToGameMessage.gameId)
  return _internal_gameid();
}
inline void InvitePlayerToGameMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void InvitePlayerToGameMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:InvitePlayerToGameMessage.gameId)
}

// required uint32 playerId = 2;
inline bool InvitePlayerToGameMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InvitePlayerToGameMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void InvitePlayerToGameMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t InvitePlayerToGameMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t InvitePlayerToGameMessage::playerid() const {
  // @@protoc_insertion_point(field_get:InvitePlayerToGameMessage.playerId)
  return _internal_playerid();
}
inline void InvitePlayerToGameMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void InvitePlayerToGameMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:InvitePlayerToGameMessage.playerId)
}

// -------------------------------------------------------------------

// InviteNotifyMessage

// required uint32 gameId = 1;
inline bool InviteNotifyMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InviteNotifyMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void InviteNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t InviteNotifyMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t InviteNotifyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.gameId)
  return _internal_gameid();
}
inline void InviteNotifyMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void InviteNotifyMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.gameId)
}

// required uint32 playerIdWho = 2;
inline bool InviteNotifyMessage::_internal_has_playeridwho() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InviteNotifyMessage::has_playeridwho() const {
  return _internal_has_playeridwho();
}
inline void InviteNotifyMessage::clear_playeridwho() {
  playeridwho_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t InviteNotifyMessage::_internal_playeridwho() const {
  return playeridwho_;
}
inline uint32_t InviteNotifyMessage::playeridwho() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.playerIdWho)
  return _internal_playeridwho();
}
inline void InviteNotifyMessage::_internal_set_playeridwho(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playeridwho_ = value;
}
inline void InviteNotifyMessage::set_playeridwho(uint32_t value) {
  _internal_set_playeridwho(value);
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.playerIdWho)
}

// required uint32 playerIdByWhom = 3;
inline bool InviteNotifyMessage::_internal_has_playeridbywhom() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InviteNotifyMessage::has_playeridbywhom() const {
  return _internal_has_playeridbywhom();
}
inline void InviteNotifyMessage::clear_playeridbywhom() {
  playeridbywhom_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t InviteNotifyMessage::_internal_playeridbywhom() const {
  return playeridbywhom_;
}
inline uint32_t InviteNotifyMessage::playeridbywhom() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.playerIdByWhom)
  return _internal_playeridbywhom();
}
inline void InviteNotifyMessage::_internal_set_playeridbywhom(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  playeridbywhom_ = value;
}
inline void InviteNotifyMessage::set_playeridbywhom(uint32_t value) {
  _internal_set_playeridbywhom(value);
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.playerIdByWhom)
}

// -------------------------------------------------------------------

// RejectGameInvitationMessage

// required uint32 gameId = 1;
inline bool RejectGameInvitationMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RejectGameInvitationMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void RejectGameInvitationMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RejectGameInvitationMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t RejectGameInvitationMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejectGameInvitationMessage.gameId)
  return _internal_gameid();
}
inline void RejectGameInvitationMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void RejectGameInvitationMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:RejectGameInvitationMessage.gameId)
}

// required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
inline bool RejectGameInvitationMessage::_internal_has_myrejectreason() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RejectGameInvitationMessage::has_myrejectreason() const {
  return _internal_has_myrejectreason();
}
inline void RejectGameInvitationMessage::clear_myrejectreason() {
  myrejectreason_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::_internal_myrejectreason() const {
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(myrejectreason_);
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::myrejectreason() const {
  // @@protoc_insertion_point(field_get:RejectGameInvitationMessage.myRejectReason)
  return _internal_myrejectreason();
}
inline void RejectGameInvitationMessage::_internal_set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  assert(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  myrejectreason_ = value;
}
inline void RejectGameInvitationMessage::set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  _internal_set_myrejectreason(value);
  // @@protoc_insertion_point(field_set:RejectGameInvitationMessage.myRejectReason)
}

// -------------------------------------------------------------------

// RejectInvNotifyMessage

// required uint32 gameId = 1;
inline bool RejectInvNotifyMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RejectInvNotifyMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void RejectInvNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RejectInvNotifyMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t RejectInvNotifyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.gameId)
  return _internal_gameid();
}
inline void RejectInvNotifyMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void RejectInvNotifyMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.gameId)
}

// required uint32 playerId = 2;
inline bool RejectInvNotifyMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RejectInvNotifyMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void RejectInvNotifyMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RejectInvNotifyMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t RejectInvNotifyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.playerId)
  return _internal_playerid();
}
inline void RejectInvNotifyMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void RejectInvNotifyMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.playerId)
}

// required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
inline bool RejectInvNotifyMessage::_internal_has_playerrejectreason() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RejectInvNotifyMessage::has_playerrejectreason() const {
  return _internal_has_playerrejectreason();
}
inline void RejectInvNotifyMessage::clear_playerrejectreason() {
  playerrejectreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectInvNotifyMessage::_internal_playerrejectreason() const {
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(playerrejectreason_);
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectInvNotifyMessage::playerrejectreason() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.playerRejectReason)
  return _internal_playerrejectreason();
}
inline void RejectInvNotifyMessage::_internal_set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  assert(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  playerrejectreason_ = value;
}
inline void RejectInvNotifyMessage::set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  _internal_set_playerrejectreason(value);
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.playerRejectReason)
}

// -------------------------------------------------------------------

// StartEventMessage

// required uint32 gameId = 1;
inline bool StartEventMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StartEventMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void StartEventMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StartEventMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t StartEventMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.gameId)
  return _internal_gameid();
}
inline void StartEventMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void StartEventMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:StartEventMessage.gameId)
}

// required .StartEventMessage.StartEventType startEventType = 2;
inline bool StartEventMessage::_internal_has_starteventtype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StartEventMessage::has_starteventtype() const {
  return _internal_has_starteventtype();
}
inline void StartEventMessage::clear_starteventtype() {
  starteventtype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::StartEventMessage_StartEventType StartEventMessage::_internal_starteventtype() const {
  return static_cast< ::StartEventMessage_StartEventType >(starteventtype_);
}
inline ::StartEventMessage_StartEventType StartEventMessage::starteventtype() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.startEventType)
  return _internal_starteventtype();
}
inline void StartEventMessage::_internal_set_starteventtype(::StartEventMessage_StartEventType value) {
  assert(::StartEventMessage_StartEventType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  starteventtype_ = value;
}
inline void StartEventMessage::set_starteventtype(::StartEventMessage_StartEventType value) {
  _internal_set_starteventtype(value);
  // @@protoc_insertion_point(field_set:StartEventMessage.startEventType)
}

// optional bool fillWithComputerPlayers = 3;
inline bool StartEventMessage::_internal_has_fillwithcomputerplayers() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StartEventMessage::has_fillwithcomputerplayers() const {
  return _internal_has_fillwithcomputerplayers();
}
inline void StartEventMessage::clear_fillwithcomputerplayers() {
  fillwithcomputerplayers_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StartEventMessage::_internal_fillwithcomputerplayers() const {
  return fillwithcomputerplayers_;
}
inline bool StartEventMessage::fillwithcomputerplayers() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.fillWithComputerPlayers)
  return _internal_fillwithcomputerplayers();
}
inline void StartEventMessage::_internal_set_fillwithcomputerplayers(bool value) {
  _has_bits_[0] |= 0x00000004u;
  fillwithcomputerplayers_ = value;
}
inline void StartEventMessage::set_fillwithcomputerplayers(bool value) {
  _internal_set_fillwithcomputerplayers(value);
  // @@protoc_insertion_point(field_set:StartEventMessage.fillWithComputerPlayers)
}

// -------------------------------------------------------------------

// StartEventAckMessage

// required uint32 gameId = 1;
inline bool StartEventAckMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StartEventAckMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void StartEventAckMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StartEventAckMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t StartEventAckMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartEventAckMessage.gameId)
  return _internal_gameid();
}
inline void StartEventAckMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void StartEventAckMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:StartEventAckMessage.gameId)
}

// -------------------------------------------------------------------

// GameStartInitialMessage

// required uint32 gameId = 1;
inline bool GameStartInitialMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameStartInitialMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameStartInitialMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameStartInitialMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameStartInitialMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.gameId)
  return _internal_gameid();
}
inline void GameStartInitialMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameStartInitialMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.gameId)
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartInitialMessage::_internal_has_startdealerplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameStartInitialMessage::has_startdealerplayerid() const {
  return _internal_has_startdealerplayerid();
}
inline void GameStartInitialMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameStartInitialMessage::_internal_startdealerplayerid() const {
  return startdealerplayerid_;
}
inline uint32_t GameStartInitialMessage::startdealerplayerid() const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.startDealerPlayerId)
  return _internal_startdealerplayerid();
}
inline void GameStartInitialMessage::_internal_set_startdealerplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  startdealerplayerid_ = value;
}
inline void GameStartInitialMessage::set_startdealerplayerid(uint32_t value) {
  _internal_set_startdealerplayerid(value);
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.startDealerPlayerId)
}

// repeated uint32 playerSeats = 3 [packed = true];
inline int GameStartInitialMessage::_internal_playerseats_size() const {
  return playerseats_.size();
}
inline int GameStartInitialMessage::playerseats_size() const {
  return _internal_playerseats_size();
}
inline void GameStartInitialMessage::clear_playerseats() {
  playerseats_.Clear();
}
inline uint32_t GameStartInitialMessage::_internal_playerseats(int index) const {
  return playerseats_.Get(index);
}
inline uint32_t GameStartInitialMessage::playerseats(int index) const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.playerSeats)
  return _internal_playerseats(index);
}
inline void GameStartInitialMessage::set_playerseats(int index, uint32_t value) {
  playerseats_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.playerSeats)
}
inline void GameStartInitialMessage::_internal_add_playerseats(uint32_t value) {
  playerseats_.Add(value);
}
inline void GameStartInitialMessage::add_playerseats(uint32_t value) {
  _internal_add_playerseats(value);
  // @@protoc_insertion_point(field_add:GameStartInitialMessage.playerSeats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameStartInitialMessage::_internal_playerseats() const {
  return playerseats_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameStartInitialMessage::playerseats() const {
  // @@protoc_insertion_point(field_list:GameStartInitialMessage.playerSeats)
  return _internal_playerseats();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameStartInitialMessage::_internal_mutable_playerseats() {
  return &playerseats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameStartInitialMessage::mutable_playerseats() {
  // @@protoc_insertion_point(field_mutable_list:GameStartInitialMessage.playerSeats)
  return _internal_mutable_playerseats();
}

// -------------------------------------------------------------------

// GameStartRejoinMessage_RejoinPlayerData

// required uint32 playerId = 1;
inline bool GameStartRejoinMessage_RejoinPlayerData::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameStartRejoinMessage_RejoinPlayerData::_internal_playerid() const {
  return playerid_;
}
inline uint32_t GameStartRejoinMessage_RejoinPlayerData::playerid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.RejoinPlayerData.playerId)
  return _internal_playerid();
}
inline void GameStartRejoinMessage_RejoinPlayerData::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.RejoinPlayerData.playerId)
}

// required uint32 playerMoney = 2;
inline bool GameStartRejoinMessage_RejoinPlayerData::_internal_has_playermoney() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playermoney() const {
  return _internal_has_playermoney();
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameStartRejoinMessage_RejoinPlayerData::_internal_playermoney() const {
  return playermoney_;
}
inline uint32_t GameStartRejoinMessage_RejoinPlayerData::playermoney() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.RejoinPlayerData.playerMoney)
  return _internal_playermoney();
}
inline void GameStartRejoinMessage_RejoinPlayerData::_internal_set_playermoney(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playermoney_ = value;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playermoney(uint32_t value) {
  _internal_set_playermoney(value);
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.RejoinPlayerData.playerMoney)
}

// -------------------------------------------------------------------

// GameStartRejoinMessage

// required uint32 gameId = 1;
inline bool GameStartRejoinMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameStartRejoinMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameStartRejoinMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GameStartRejoinMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t GameStartRejoinMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.gameId)
  return _internal_gameid();
}
inline void GameStartRejoinMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void GameStartRejoinMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.gameId)
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartRejoinMessage::_internal_has_startdealerplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameStartRejoinMessage::has_startdealerplayerid() const {
  return _internal_has_startdealerplayerid();
}
inline void GameStartRejoinMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GameStartRejoinMessage::_internal_startdealerplayerid() const {
  return startdealerplayerid_;
}
inline uint32_t GameStartRejoinMessage::startdealerplayerid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.startDealerPlayerId)
  return _internal_startdealerplayerid();
}
inline void GameStartRejoinMessage::_internal_set_startdealerplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  startdealerplayerid_ = value;
}
inline void GameStartRejoinMessage::set_startdealerplayerid(uint32_t value) {
  _internal_set_startdealerplayerid(value);
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.startDealerPlayerId)
}

// required uint32 handNum = 3;
inline bool GameStartRejoinMessage::_internal_has_handnum() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameStartRejoinMessage::has_handnum() const {
  return _internal_has_handnum();
}
inline void GameStartRejoinMessage::clear_handnum() {
  handnum_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GameStartRejoinMessage::_internal_handnum() const {
  return handnum_;
}
inline uint32_t GameStartRejoinMessage::handnum() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.handNum)
  return _internal_handnum();
}
inline void GameStartRejoinMessage::_internal_set_handnum(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  handnum_ = value;
}
inline void GameStartRejoinMessage::set_handnum(uint32_t value) {
  _internal_set_handnum(value);
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.handNum)
}

// repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
inline int GameStartRejoinMessage::_internal_rejoinplayerdata_size() const {
  return rejoinplayerdata_.size();
}
inline int GameStartRejoinMessage::rejoinplayerdata_size() const {
  return _internal_rejoinplayerdata_size();
}
inline void GameStartRejoinMessage::clear_rejoinplayerdata() {
  rejoinplayerdata_.Clear();
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::mutable_rejoinplayerdata(int index) {
  // @@protoc_insertion_point(field_mutable:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
GameStartRejoinMessage::mutable_rejoinplayerdata() {
  // @@protoc_insertion_point(field_mutable_list:GameStartRejoinMessage.rejoinPlayerData)
  return &rejoinplayerdata_;
}
inline const ::GameStartRejoinMessage_RejoinPlayerData& GameStartRejoinMessage::_internal_rejoinplayerdata(int index) const {
  return rejoinplayerdata_.Get(index);
}
inline const ::GameStartRejoinMessage_RejoinPlayerData& GameStartRejoinMessage::rejoinplayerdata(int index) const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.rejoinPlayerData)
  return _internal_rejoinplayerdata(index);
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::_internal_add_rejoinplayerdata() {
  return rejoinplayerdata_.Add();
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::add_rejoinplayerdata() {
  ::GameStartRejoinMessage_RejoinPlayerData* _add = _internal_add_rejoinplayerdata();
  // @@protoc_insertion_point(field_add:GameStartRejoinMessage.rejoinPlayerData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
GameStartRejoinMessage::rejoinplayerdata() const {
  // @@protoc_insertion_point(field_list:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_;
}

// -------------------------------------------------------------------

// HandStartMessage_PlainCards

// required uint32 plainCard1 = 1;
inline bool HandStartMessage_PlainCards::_internal_has_plaincard1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandStartMessage_PlainCards::has_plaincard1() const {
  return _internal_has_plaincard1();
}
inline void HandStartMessage_PlainCards::clear_plaincard1() {
  plaincard1_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HandStartMessage_PlainCards::_internal_plaincard1() const {
  return plaincard1_;
}
inline uint32_t HandStartMessage_PlainCards::plaincard1() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.PlainCards.plainCard1)
  return _internal_plaincard1();
}
inline void HandStartMessage_PlainCards::_internal_set_plaincard1(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  plaincard1_ = value;
}
inline void HandStartMessage_PlainCards::set_plaincard1(uint32_t value) {
  _internal_set_plaincard1(value);
  // @@protoc_insertion_point(field_set:HandStartMessage.PlainCards.plainCard1)
}

// required uint32 plainCard2 = 2;
inline bool HandStartMessage_PlainCards::_internal_has_plaincard2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HandStartMessage_PlainCards::has_plaincard2() const {
  return _internal_has_plaincard2();
}
inline void HandStartMessage_PlainCards::clear_plaincard2() {
  plaincard2_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t HandStartMessage_PlainCards::_internal_plaincard2() const {
  return plaincard2_;
}
inline uint32_t HandStartMessage_PlainCards::plaincard2() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.PlainCards.plainCard2)
  return _internal_plaincard2();
}
inline void HandStartMessage_PlainCards::_internal_set_plaincard2(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  plaincard2_ = value;
}
inline void HandStartMessage_PlainCards::set_plaincard2(uint32_t value) {
  _internal_set_plaincard2(value);
  // @@protoc_insertion_point(field_set:HandStartMessage.PlainCards.plainCard2)
}

// -------------------------------------------------------------------

// HandStartMessage

// required uint32 gameId = 1;
inline bool HandStartMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HandStartMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void HandStartMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t HandStartMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t HandStartMessage::gameid() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.gameId)
  return _internal_gameid();
}
inline void HandStartMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  gameid_ = value;
}
inline void HandStartMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:HandStartMessage.gameId)
}

// optional .HandStartMessage.PlainCards plainCards = 2;
inline bool HandStartMessage::_internal_has_plaincards() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || plaincards_ != nullptr);
  return value;
}
inline bool HandStartMessage::has_plaincards() const {
  return _internal_has_plaincards();
}
inline void HandStartMessage::clear_plaincards() {
  if (plaincards_ != nullptr) plaincards_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::HandStartMessage_PlainCards& HandStartMessage::_internal_plaincards() const {
  const ::HandStartMessage_PlainCards* p = plaincards_;
  return p != nullptr ? *p : reinterpret_cast<const ::HandStartMessage_PlainCards&>(
      ::_HandStartMessage_PlainCards_default_instance_);
}
inline const ::HandStartMessage_PlainCards& HandStartMessage::plaincards() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.plainCards)
  return _internal_plaincards();
}
inline void HandStartMessage::unsafe_arena_set_allocated_plaincards(
    ::HandStartMessage_PlainCards* plaincards) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plaincards_);
  }
  plaincards_ = plaincards;
  if (plaincards) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HandStartMessage.plainCards)
}
inline ::HandStartMessage_PlainCards* HandStartMessage::release_plaincards() {
  _has_bits_[0] &= ~0x00000002u;
  ::HandStartMessage_PlainCards* temp = plaincards_;
  plaincards_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::unsafe_arena_release_plaincards() {
  // @@protoc_insertion_point(field_release:HandStartMessage.plainCards)
  _has_bits_[0] &= ~0x00000002u;
  ::HandStartMessage_PlainCards* temp = plaincards_;
  plaincards_ = nullptr;
  return temp;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::_internal_mutable_plaincards() {
  _has_bits_[0] |= 0x00000002u;
  if (plaincards_ == nullptr) {
    auto* p = CreateMaybeMessage<::HandStartMessage_PlainCards>(GetArenaForAllocation());
    plaincards_ = p;
  }
  return plaincards_;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::mutable_plaincards() {
  ::HandStartMessage_PlainCards* _msg = _internal_mutable_plaincards();
  // @@protoc_insertion_point(field_mutable:HandStartMessage.plainCards)
  return _msg;
}
inline void HandStartMessage::set_allocated_plaincards(::HandStartMessage_PlainCards* plaincards) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plaincards_;
  }
  if (plaincards) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HandStartMessage_PlainCards>::GetOwningArena(plaincards);
    if (message_arena != submessage_arena) {
      plaincards = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plaincards, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  plaincards_ = plaincards;
  // @@protoc_insertion_point(field_set_allocated:HandStartMessage.plainCards)
}

// optional bytes encryptedCards = 3;
inline bool HandStartMessage::_internal_has_encryptedcards() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandStartMessage::has_encryptedcards() const {
  return _internal_has_encryptedcards();
}
inline void HandStartMessage::clear_encryptedcards() {
  encryptedcards_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandStartMessage::encryptedcards() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.encryptedCards)
  return _internal_encryptedcards();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandStartMessage::set_encryptedcards(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 encryptedcards_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HandStartMessage.encryptedCards)
}
inline std::string* HandStartMessage::mutable_encryptedcards() {
  std::string* _s = _internal_mutable_encryptedcards();
  // @@protoc_insertion_point(field_mutable:HandStartMessage.encryptedCards)
  return _s;
}
inline const std::string& HandStartMessage::_internal_encryptedcards() const {
  return encryptedcards_.Get();
}
inline void HandStartMessage::_internal_set_encryptedcards(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encryptedcards_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HandStartMessage::_internal_mutable_encryptedcards() {
  _has_bits_[0] |= 0x00000001u;
  return encryptedcards_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HandStartMessage::release_encryptedcards() {
  // @@protoc_insertion_point(field_release:HandStartMessage.encryptedCards)
  if (!_internal_has_encryptedcards()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = encryptedcards_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryptedcards_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryptedcards_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandStartMessage::set_allocated_encryptedcards(std::string* encryptedcards) {
  if (encryptedcards != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encryptedcards_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryptedcards,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryptedcards_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryptedcards_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HandStartMessage.encryptedCards)
}

// required uint32 smallBlind = 4;
inline bool HandStartMessage::_internal_has_smallblind() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HandStartMessage::has_smallblind() const {
  return _internal_has_smallblind();
}
inline void HandStartMessage::clear_smallblind() {
  smallblind_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t HandStartMessage::_internal_smallblind() const {
  return smallblind_;
}
inline uint32_t HandStartMessage::smallblind() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.smallBlind)
  return _internal_smallblind();
}
inline void HandStartMessage::_internal_set_smallblind(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  smallblind_ = value;
}
inline void HandStartMessage::set_smallblind(uint32_t value) {
  _internal_set_smallblind(value);
  // @@protoc_insertion_point(field_set:HandStartMessage.smallBlind)
}

// repeated .NetPlayerState seatStates = 5;
inline int HandStartMessage::_internal_seatstates_size() const {
  return seatstates_.size();
}
inline int HandStartMessage::seatstates_size() const {
  return _internal_seatstates_size();
}
inline void HandStartMessage::clear_seatstates() {
  seatstates_.Clear();
}
inline ::NetPlayerState HandStartMessage::_internal_seatstates(int index) const {
  return static_cast< ::NetPlayerState >(seatstates_.Get(index));
}
inline ::NetPlayerState HandStartMessage::seatstates(int index) const {
  // @@protoc_insertion_point(field_get:HandStartMessage.seatStates)
  return _internal_seatstates(index);
}
inline void HandStartMessage::set_seatstates(int index, ::NetPlayerState value) {
  assert(::NetPlayerState_IsValid(value));
  seatstates_.Set(index, value);
  // @@protoc_insertion_point(field_set:HandStartMessage.seatStates)
}
inline void HandStartMessage::_internal_add_seatstates(::NetPlayerState value) {
  assert(::NetPlayerState_IsValid(value));
  seatstates_.Add(value);
}
inline void HandStartMessage::add_seatstates(::NetPlayerState value) {
  _internal_add_seatstates(value);
  // @@protoc_insertion_point(field_add:HandStartMessage.seatStates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
HandStartMessage::seatstates() const {
  // @@protoc_insertion_point(field_list:HandStartMessage.seatStates)
  return seatstates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandStartMessage::_internal_mutable_seatstates() {
  return &seatstates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandStartMessage::mutable_seatstates() {
  // @@protoc_insertion_point(field_mutable_list:HandStartMessage.seatStates)
  return _internal_mutable_seatstates();
}

// optional uint32 dealerPlayerId = 6;
inline bool HandStartMessage::_internal_has_dealerplayerid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HandStartMessage::has_dealerplayerid() const {
  return _internal_has_dealerplayerid();
}
inline void HandStartMessage::clear_dealerplayerid() {
  dealerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t HandStartMessage::_internal_dealerplayerid() const {
  return dealerplayerid_;
}
inline uint32_t HandStartMessage::dealerplayerid() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.dealerPlayerId)
  return _internal_dealerplayerid();
}
inline void HandStartMessage::_internal_set_dealerplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  dealerplayerid_ = value;
}
inline void HandStartMessage::set_dealerplayerid(uint32_t value) {
  _internal_set_dealerplayerid(value);
  // @@protoc_insertion_point(field_set:HandStartMessage.dealerPlayerId)
}

// -------------------------------------------------------------------

// PlayersTurnMessage

// required uint32 gameId = 1;
inline bool PlayersTurnMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayersTurnMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void PlayersTurnMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PlayersTurnMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t PlayersTurnMessage::gameid() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.gameId)
  return _internal_gameid();
}
inline void PlayersTurnMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void PlayersTurnMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.gameId)
}

// required uint32 playerId = 2;
inline bool PlayersTurnMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayersTurnMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayersTurnMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PlayersTurnMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t PlayersTurnMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.playerId)
  return _internal_playerid();
}
inline void PlayersTurnMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void PlayersTurnMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.playerId)
}

// required .NetGameState gameState = 3;
inline bool PlayersTurnMessage::_internal_has_gamestate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayersTurnMessage::has_gamestate() const {
  return _internal_has_gamestate();
}
inline void PlayersTurnMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetGameState PlayersTurnMessage::_internal_gamestate() const {
  return static_cast< ::NetGameState >(gamestate_);
}
inline ::NetGameState PlayersTurnMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.gameState)
  return _internal_gamestate();
}
inline void PlayersTurnMessage::_internal_set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamestate_ = value;
}
inline void PlayersTurnMessage::set_gamestate(::NetGameState value) {
  _internal_set_gamestate(value);
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.gameState)
}

// -------------------------------------------------------------------

// MyActionRequestMessage

// required uint32 gameId = 1;
inline bool MyActionRequestMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MyActionRequestMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void MyActionRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MyActionRequestMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t MyActionRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.gameId)
  return _internal_gameid();
}
inline void MyActionRequestMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void MyActionRequestMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.gameId)
}

// required uint32 handNum = 2;
inline bool MyActionRequestMessage::_internal_has_handnum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MyActionRequestMessage::has_handnum() const {
  return _internal_has_handnum();
}
inline void MyActionRequestMessage::clear_handnum() {
  handnum_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MyActionRequestMessage::_internal_handnum() const {
  return handnum_;
}
inline uint32_t MyActionRequestMessage::handnum() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.handNum)
  return _internal_handnum();
}
inline void MyActionRequestMessage::_internal_set_handnum(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  handnum_ = value;
}
inline void MyActionRequestMessage::set_handnum(uint32_t value) {
  _internal_set_handnum(value);
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.handNum)
}

// required .NetGameState gameState = 3;
inline bool MyActionRequestMessage::_internal_has_gamestate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MyActionRequestMessage::has_gamestate() const {
  return _internal_has_gamestate();
}
inline void MyActionRequestMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetGameState MyActionRequestMessage::_internal_gamestate() const {
  return static_cast< ::NetGameState >(gamestate_);
}
inline ::NetGameState MyActionRequestMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.gameState)
  return _internal_gamestate();
}
inline void MyActionRequestMessage::_internal_set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamestate_ = value;
}
inline void MyActionRequestMessage::set_gamestate(::NetGameState value) {
  _internal_set_gamestate(value);
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.gameState)
}

// required .NetPlayerAction myAction = 4;
inline bool MyActionRequestMessage::_internal_has_myaction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MyActionRequestMessage::has_myaction() const {
  return _internal_has_myaction();
}
inline void MyActionRequestMessage::clear_myaction() {
  myaction_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::NetPlayerAction MyActionRequestMessage::_internal_myaction() const {
  return static_cast< ::NetPlayerAction >(myaction_);
}
inline ::NetPlayerAction MyActionRequestMessage::myaction() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.myAction)
  return _internal_myaction();
}
inline void MyActionRequestMessage::_internal_set_myaction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  myaction_ = value;
}
inline void MyActionRequestMessage::set_myaction(::NetPlayerAction value) {
  _internal_set_myaction(value);
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.myAction)
}

// required uint32 myRelativeBet = 5;
inline bool MyActionRequestMessage::_internal_has_myrelativebet() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MyActionRequestMessage::has_myrelativebet() const {
  return _internal_has_myrelativebet();
}
inline void MyActionRequestMessage::clear_myrelativebet() {
  myrelativebet_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MyActionRequestMessage::_internal_myrelativebet() const {
  return myrelativebet_;
}
inline uint32_t MyActionRequestMessage::myrelativebet() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.myRelativeBet)
  return _internal_myrelativebet();
}
inline void MyActionRequestMessage::_internal_set_myrelativebet(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  myrelativebet_ = value;
}
inline void MyActionRequestMessage::set_myrelativebet(uint32_t value) {
  _internal_set_myrelativebet(value);
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.myRelativeBet)
}

// -------------------------------------------------------------------

// YourActionRejectedMessage

// required uint32 gameId = 1;
inline bool YourActionRejectedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool YourActionRejectedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void YourActionRejectedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t YourActionRejectedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t YourActionRejectedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.gameId)
  return _internal_gameid();
}
inline void YourActionRejectedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void YourActionRejectedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.gameId)
}

// required .NetGameState gameState = 2;
inline bool YourActionRejectedMessage::_internal_has_gamestate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool YourActionRejectedMessage::has_gamestate() const {
  return _internal_has_gamestate();
}
inline void YourActionRejectedMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::NetGameState YourActionRejectedMessage::_internal_gamestate() const {
  return static_cast< ::NetGameState >(gamestate_);
}
inline ::NetGameState YourActionRejectedMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.gameState)
  return _internal_gamestate();
}
inline void YourActionRejectedMessage::_internal_set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  gamestate_ = value;
}
inline void YourActionRejectedMessage::set_gamestate(::NetGameState value) {
  _internal_set_gamestate(value);
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.gameState)
}

// required .NetPlayerAction yourAction = 3;
inline bool YourActionRejectedMessage::_internal_has_youraction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool YourActionRejectedMessage::has_youraction() const {
  return _internal_has_youraction();
}
inline void YourActionRejectedMessage::clear_youraction() {
  youraction_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetPlayerAction YourActionRejectedMessage::_internal_youraction() const {
  return static_cast< ::NetPlayerAction >(youraction_);
}
inline ::NetPlayerAction YourActionRejectedMessage::youraction() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.yourAction)
  return _internal_youraction();
}
inline void YourActionRejectedMessage::_internal_set_youraction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  youraction_ = value;
}
inline void YourActionRejectedMessage::set_youraction(::NetPlayerAction value) {
  _internal_set_youraction(value);
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.yourAction)
}

// required uint32 yourRelativeBet = 4;
inline bool YourActionRejectedMessage::_internal_has_yourrelativebet() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool YourActionRejectedMessage::has_yourrelativebet() const {
  return _internal_has_yourrelativebet();
}
inline void YourActionRejectedMessage::clear_yourrelativebet() {
  yourrelativebet_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t YourActionRejectedMessage::_internal_yourrelativebet() const {
  return yourrelativebet_;
}
inline uint32_t YourActionRejectedMessage::yourrelativebet() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.yourRelativeBet)
  return _internal_yourrelativebet();
}
inline void YourActionRejectedMessage::_internal_set_yourrelativebet(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  yourrelativebet_ = value;
}
inline void YourActionRejectedMessage::set_yourrelativebet(uint32_t value) {
  _internal_set_yourrelativebet(value);
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.yourRelativeBet)
}

// required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
inline bool YourActionRejectedMessage::_internal_has_rejectionreason() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool YourActionRejectedMessage::has_rejectionreason() const {
  return _internal_has_rejectionreason();
}
inline void YourActionRejectedMessage::clear_rejectionreason() {
  rejectionreason_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::_internal_rejectionreason() const {
  return static_cast< ::YourActionRejectedMessage_RejectionReason >(rejectionreason_);
}
inline ::YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectionreason() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.rejectionReason)
  return _internal_rejectionreason();
}
inline void YourActionRejectedMessage::_internal_set_rejectionreason(::YourActionRejectedMessage_RejectionReason value) {
  assert(::YourActionRejectedMessage_RejectionReason_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  rejectionreason_ = value;
}
inline void YourActionRejectedMessage::set_rejectionreason(::YourActionRejectedMessage_RejectionReason value) {
  _internal_set_rejectionreason(value);
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.rejectionReason)
}

// -------------------------------------------------------------------

// PlayersActionDoneMessage

// required uint32 gameId = 1;
inline bool PlayersActionDoneMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void PlayersActionDoneMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PlayersActionDoneMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t PlayersActionDoneMessage::gameid() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.gameId)
  return _internal_gameid();
}
inline void PlayersActionDoneMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void PlayersActionDoneMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.gameId)
}

// required uint32 playerId = 2;
inline bool PlayersActionDoneMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayersActionDoneMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PlayersActionDoneMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t PlayersActionDoneMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerId)
  return _internal_playerid();
}
inline void PlayersActionDoneMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void PlayersActionDoneMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerId)
}

// required .NetGameState gameState = 3;
inline bool PlayersActionDoneMessage::_internal_has_gamestate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_gamestate() const {
  return _internal_has_gamestate();
}
inline void PlayersActionDoneMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetGameState PlayersActionDoneMessage::_internal_gamestate() const {
  return static_cast< ::NetGameState >(gamestate_);
}
inline ::NetGameState PlayersActionDoneMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.gameState)
  return _internal_gamestate();
}
inline void PlayersActionDoneMessage::_internal_set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamestate_ = value;
}
inline void PlayersActionDoneMessage::set_gamestate(::NetGameState value) {
  _internal_set_gamestate(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.gameState)
}

// required .NetPlayerAction playerAction = 4;
inline bool PlayersActionDoneMessage::_internal_has_playeraction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_playeraction() const {
  return _internal_has_playeraction();
}
inline void PlayersActionDoneMessage::clear_playeraction() {
  playeraction_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::NetPlayerAction PlayersActionDoneMessage::_internal_playeraction() const {
  return static_cast< ::NetPlayerAction >(playeraction_);
}
inline ::NetPlayerAction PlayersActionDoneMessage::playeraction() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerAction)
  return _internal_playeraction();
}
inline void PlayersActionDoneMessage::_internal_set_playeraction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  playeraction_ = value;
}
inline void PlayersActionDoneMessage::set_playeraction(::NetPlayerAction value) {
  _internal_set_playeraction(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerAction)
}

// required uint32 totalPlayerBet = 5;
inline bool PlayersActionDoneMessage::_internal_has_totalplayerbet() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_totalplayerbet() const {
  return _internal_has_totalplayerbet();
}
inline void PlayersActionDoneMessage::clear_totalplayerbet() {
  totalplayerbet_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PlayersActionDoneMessage::_internal_totalplayerbet() const {
  return totalplayerbet_;
}
inline uint32_t PlayersActionDoneMessage::totalplayerbet() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.totalPlayerBet)
  return _internal_totalplayerbet();
}
inline void PlayersActionDoneMessage::_internal_set_totalplayerbet(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  totalplayerbet_ = value;
}
inline void PlayersActionDoneMessage::set_totalplayerbet(uint32_t value) {
  _internal_set_totalplayerbet(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.totalPlayerBet)
}

// required uint32 playerMoney = 6;
inline bool PlayersActionDoneMessage::_internal_has_playermoney() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_playermoney() const {
  return _internal_has_playermoney();
}
inline void PlayersActionDoneMessage::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t PlayersActionDoneMessage::_internal_playermoney() const {
  return playermoney_;
}
inline uint32_t PlayersActionDoneMessage::playermoney() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerMoney)
  return _internal_playermoney();
}
inline void PlayersActionDoneMessage::_internal_set_playermoney(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  playermoney_ = value;
}
inline void PlayersActionDoneMessage::set_playermoney(uint32_t value) {
  _internal_set_playermoney(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerMoney)
}

// required uint32 highestSet = 7;
inline bool PlayersActionDoneMessage::_internal_has_highestset() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_highestset() const {
  return _internal_has_highestset();
}
inline void PlayersActionDoneMessage::clear_highestset() {
  highestset_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t PlayersActionDoneMessage::_internal_highestset() const {
  return highestset_;
}
inline uint32_t PlayersActionDoneMessage::highestset() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.highestSet)
  return _internal_highestset();
}
inline void PlayersActionDoneMessage::_internal_set_highestset(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  highestset_ = value;
}
inline void PlayersActionDoneMessage::set_highestset(uint32_t value) {
  _internal_set_highestset(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.highestSet)
}

// required uint32 minimumRaise = 8;
inline bool PlayersActionDoneMessage::_internal_has_minimumraise() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PlayersActionDoneMessage::has_minimumraise() const {
  return _internal_has_minimumraise();
}
inline void PlayersActionDoneMessage::clear_minimumraise() {
  minimumraise_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t PlayersActionDoneMessage::_internal_minimumraise() const {
  return minimumraise_;
}
inline uint32_t PlayersActionDoneMessage::minimumraise() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.minimumRaise)
  return _internal_minimumraise();
}
inline void PlayersActionDoneMessage::_internal_set_minimumraise(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  minimumraise_ = value;
}
inline void PlayersActionDoneMessage::set_minimumraise(uint32_t value) {
  _internal_set_minimumraise(value);
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.minimumRaise)
}

// -------------------------------------------------------------------

// DealFlopCardsMessage

// required uint32 gameId = 1;
inline bool DealFlopCardsMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DealFlopCardsMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void DealFlopCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DealFlopCardsMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t DealFlopCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.gameId)
  return _internal_gameid();
}
inline void DealFlopCardsMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void DealFlopCardsMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.gameId)
}

// required uint32 flopCard1 = 2;
inline bool DealFlopCardsMessage::_internal_has_flopcard1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DealFlopCardsMessage::has_flopcard1() const {
  return _internal_has_flopcard1();
}
inline void DealFlopCardsMessage::clear_flopcard1() {
  flopcard1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DealFlopCardsMessage::_internal_flopcard1() const {
  return flopcard1_;
}
inline uint32_t DealFlopCardsMessage::flopcard1() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard1)
  return _internal_flopcard1();
}
inline void DealFlopCardsMessage::_internal_set_flopcard1(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  flopcard1_ = value;
}
inline void DealFlopCardsMessage::set_flopcard1(uint32_t value) {
  _internal_set_flopcard1(value);
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard1)
}

// required uint32 flopCard2 = 3;
inline bool DealFlopCardsMessage::_internal_has_flopcard2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DealFlopCardsMessage::has_flopcard2() const {
  return _internal_has_flopcard2();
}
inline void DealFlopCardsMessage::clear_flopcard2() {
  flopcard2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DealFlopCardsMessage::_internal_flopcard2() const {
  return flopcard2_;
}
inline uint32_t DealFlopCardsMessage::flopcard2() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard2)
  return _internal_flopcard2();
}
inline void DealFlopCardsMessage::_internal_set_flopcard2(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  flopcard2_ = value;
}
inline void DealFlopCardsMessage::set_flopcard2(uint32_t value) {
  _internal_set_flopcard2(value);
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard2)
}

// required uint32 flopCard3 = 4;
inline bool DealFlopCardsMessage::_internal_has_flopcard3() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DealFlopCardsMessage::has_flopcard3() const {
  return _internal_has_flopcard3();
}
inline void DealFlopCardsMessage::clear_flopcard3() {
  flopcard3_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DealFlopCardsMessage::_internal_flopcard3() const {
  return flopcard3_;
}
inline uint32_t DealFlopCardsMessage::flopcard3() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard3)
  return _internal_flopcard3();
}
inline void DealFlopCardsMessage::_internal_set_flopcard3(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  flopcard3_ = value;
}
inline void DealFlopCardsMessage::set_flopcard3(uint32_t value) {
  _internal_set_flopcard3(value);
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard3)
}

// -------------------------------------------------------------------

// DealTurnCardMessage

// required uint32 gameId = 1;
inline bool DealTurnCardMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DealTurnCardMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void DealTurnCardMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DealTurnCardMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t DealTurnCardMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealTurnCardMessage.gameId)
  return _internal_gameid();
}
inline void DealTurnCardMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void DealTurnCardMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:DealTurnCardMessage.gameId)
}

// required uint32 turnCard = 2;
inline bool DealTurnCardMessage::_internal_has_turncard() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DealTurnCardMessage::has_turncard() const {
  return _internal_has_turncard();
}
inline void DealTurnCardMessage::clear_turncard() {
  turncard_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DealTurnCardMessage::_internal_turncard() const {
  return turncard_;
}
inline uint32_t DealTurnCardMessage::turncard() const {
  // @@protoc_insertion_point(field_get:DealTurnCardMessage.turnCard)
  return _internal_turncard();
}
inline void DealTurnCardMessage::_internal_set_turncard(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  turncard_ = value;
}
inline void DealTurnCardMessage::set_turncard(uint32_t value) {
  _internal_set_turncard(value);
  // @@protoc_insertion_point(field_set:DealTurnCardMessage.turnCard)
}

// -------------------------------------------------------------------

// DealRiverCardMessage

// required uint32 gameId = 1;
inline bool DealRiverCardMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DealRiverCardMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void DealRiverCardMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DealRiverCardMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t DealRiverCardMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealRiverCardMessage.gameId)
  return _internal_gameid();
}
inline void DealRiverCardMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void DealRiverCardMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:DealRiverCardMessage.gameId)
}

// required uint32 riverCard = 2;
inline bool DealRiverCardMessage::_internal_has_rivercard() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DealRiverCardMessage::has_rivercard() const {
  return _internal_has_rivercard();
}
inline void DealRiverCardMessage::clear_rivercard() {
  rivercard_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DealRiverCardMessage::_internal_rivercard() const {
  return rivercard_;
}
inline uint32_t DealRiverCardMessage::rivercard() const {
  // @@protoc_insertion_point(field_get:DealRiverCardMessage.riverCard)
  return _internal_rivercard();
}
inline void DealRiverCardMessage::_internal_set_rivercard(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  rivercard_ = value;
}
inline void DealRiverCardMessage::set_rivercard(uint32_t value) {
  _internal_set_rivercard(value);
  // @@protoc_insertion_point(field_set:DealRiverCardMessage.riverCard)
}

// -------------------------------------------------------------------

// AllInShowCardsMessage_PlayerAllIn

// required uint32 playerId = 1;
inline bool AllInShowCardsMessage_PlayerAllIn::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllInShowCardsMessage_PlayerAllIn::has_playerid() const {
  return _internal_has_playerid();
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AllInShowCardsMessage_PlayerAllIn::_internal_playerid() const {
  return playerid_;
}
inline uint32_t AllInShowCardsMessage_PlayerAllIn::playerid() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.playerId)
  return _internal_playerid();
}
inline void AllInShowCardsMessage_PlayerAllIn::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.playerId)
}

// required uint32 allInCard1 = 2;
inline bool AllInShowCardsMessage_PlayerAllIn::_internal_has_allincard1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard1() const {
  return _internal_has_allincard1();
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard1() {
  allincard1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AllInShowCardsMessage_PlayerAllIn::_internal_allincard1() const {
  return allincard1_;
}
inline uint32_t AllInShowCardsMessage_PlayerAllIn::allincard1() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.allInCard1)
  return _internal_allincard1();
}
inline void AllInShowCardsMessage_PlayerAllIn::_internal_set_allincard1(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  allincard1_ = value;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard1(uint32_t value) {
  _internal_set_allincard1(value);
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.allInCard1)
}

// required uint32 allInCard2 = 3;
inline bool AllInShowCardsMessage_PlayerAllIn::_internal_has_allincard2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard2() const {
  return _internal_has_allincard2();
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard2() {
  allincard2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AllInShowCardsMessage_PlayerAllIn::_internal_allincard2() const {
  return allincard2_;
}
inline uint32_t AllInShowCardsMessage_PlayerAllIn::allincard2() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.allInCard2)
  return _internal_allincard2();
}
inline void AllInShowCardsMessage_PlayerAllIn::_internal_set_allincard2(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  allincard2_ = value;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard2(uint32_t value) {
  _internal_set_allincard2(value);
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.allInCard2)
}

// -------------------------------------------------------------------

// AllInShowCardsMessage

// required uint32 gameId = 1;
inline bool AllInShowCardsMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllInShowCardsMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void AllInShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AllInShowCardsMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t AllInShowCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.gameId)
  return _internal_gameid();
}
inline void AllInShowCardsMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void AllInShowCardsMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.gameId)
}

// repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
inline int AllInShowCardsMessage::_internal_playersallin_size() const {
  return playersallin_.size();
}
inline int AllInShowCardsMessage::playersallin_size() const {
  return _internal_playersallin_size();
}
inline void AllInShowCardsMessage::clear_playersallin() {
  playersallin_.Clear();
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::mutable_playersallin(int index) {
  // @@protoc_insertion_point(field_mutable:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
AllInShowCardsMessage::mutable_playersallin() {
  // @@protoc_insertion_point(field_mutable_list:AllInShowCardsMessage.playersAllIn)
  return &playersallin_;
}
inline const ::AllInShowCardsMessage_PlayerAllIn& AllInShowCardsMessage::_internal_playersallin(int index) const {
  return playersallin_.Get(index);
}
inline const ::AllInShowCardsMessage_PlayerAllIn& AllInShowCardsMessage::playersallin(int index) const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.playersAllIn)
  return _internal_playersallin(index);
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::_internal_add_playersallin() {
  return playersallin_.Add();
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::add_playersallin() {
  ::AllInShowCardsMessage_PlayerAllIn* _add = _internal_add_playersallin();
  // @@protoc_insertion_point(field_add:AllInShowCardsMessage.playersAllIn)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
AllInShowCardsMessage::playersallin() const {
  // @@protoc_insertion_point(field_list:AllInShowCardsMessage.playersAllIn)
  return playersallin_;
}

// -------------------------------------------------------------------

// EndOfHandShowCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandShowCardsMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EndOfHandShowCardsMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void EndOfHandShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t EndOfHandShowCardsMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t EndOfHandShowCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfHandShowCardsMessage.gameId)
  return _internal_gameid();
}
inline void EndOfHandShowCardsMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void EndOfHandShowCardsMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:EndOfHandShowCardsMessage.gameId)
}

// repeated .PlayerResult playerResults = 2;
inline int EndOfHandShowCardsMessage::_internal_playerresults_size() const {
  return playerresults_.size();
}
inline int EndOfHandShowCardsMessage::playerresults_size() const {
  return _internal_playerresults_size();
}
inline void EndOfHandShowCardsMessage::clear_playerresults() {
  playerresults_.Clear();
}
inline ::PlayerResult* EndOfHandShowCardsMessage::mutable_playerresults(int index) {
  // @@protoc_insertion_point(field_mutable:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerResult >*
EndOfHandShowCardsMessage::mutable_playerresults() {
  // @@protoc_insertion_point(field_mutable_list:EndOfHandShowCardsMessage.playerResults)
  return &playerresults_;
}
inline const ::PlayerResult& EndOfHandShowCardsMessage::_internal_playerresults(int index) const {
  return playerresults_.Get(index);
}
inline const ::PlayerResult& EndOfHandShowCardsMessage::playerresults(int index) const {
  // @@protoc_insertion_point(field_get:EndOfHandShowCardsMessage.playerResults)
  return _internal_playerresults(index);
}
inline ::PlayerResult* EndOfHandShowCardsMessage::_internal_add_playerresults() {
  return playerresults_.Add();
}
inline ::PlayerResult* EndOfHandShowCardsMessage::add_playerresults() {
  ::PlayerResult* _add = _internal_add_playerresults();
  // @@protoc_insertion_point(field_add:EndOfHandShowCardsMessage.playerResults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerResult >&
EndOfHandShowCardsMessage::playerresults() const {
  // @@protoc_insertion_point(field_list:EndOfHandShowCardsMessage.playerResults)
  return playerresults_;
}

// -------------------------------------------------------------------

// EndOfHandHideCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandHideCardsMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EndOfHandHideCardsMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void EndOfHandHideCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t EndOfHandHideCardsMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t EndOfHandHideCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.gameId)
  return _internal_gameid();
}
inline void EndOfHandHideCardsMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void EndOfHandHideCardsMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.gameId)
}

// required uint32 playerId = 2;
inline bool EndOfHandHideCardsMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EndOfHandHideCardsMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void EndOfHandHideCardsMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t EndOfHandHideCardsMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t EndOfHandHideCardsMessage::playerid() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.playerId)
  return _internal_playerid();
}
inline void EndOfHandHideCardsMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void EndOfHandHideCardsMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.playerId)
}

// required uint32 moneyWon = 3;
inline bool EndOfHandHideCardsMessage::_internal_has_moneywon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EndOfHandHideCardsMessage::has_moneywon() const {
  return _internal_has_moneywon();
}
inline void EndOfHandHideCardsMessage::clear_moneywon() {
  moneywon_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t EndOfHandHideCardsMessage::_internal_moneywon() const {
  return moneywon_;
}
inline uint32_t EndOfHandHideCardsMessage::moneywon() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.moneyWon)
  return _internal_moneywon();
}
inline void EndOfHandHideCardsMessage::_internal_set_moneywon(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  moneywon_ = value;
}
inline void EndOfHandHideCardsMessage::set_moneywon(uint32_t value) {
  _internal_set_moneywon(value);
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.moneyWon)
}

// required uint32 playerMoney = 4;
inline bool EndOfHandHideCardsMessage::_internal_has_playermoney() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EndOfHandHideCardsMessage::has_playermoney() const {
  return _internal_has_playermoney();
}
inline void EndOfHandHideCardsMessage::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t EndOfHandHideCardsMessage::_internal_playermoney() const {
  return playermoney_;
}
inline uint32_t EndOfHandHideCardsMessage::playermoney() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.playerMoney)
  return _internal_playermoney();
}
inline void EndOfHandHideCardsMessage::_internal_set_playermoney(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  playermoney_ = value;
}
inline void EndOfHandHideCardsMessage::set_playermoney(uint32_t value) {
  _internal_set_playermoney(value);
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.playerMoney)
}

// -------------------------------------------------------------------

// ShowMyCardsRequestMessage

// -------------------------------------------------------------------

// AfterHandShowCardsMessage

// required .PlayerResult playerResult = 1;
inline bool AfterHandShowCardsMessage::_internal_has_playerresult() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || playerresult_ != nullptr);
  return value;
}
inline bool AfterHandShowCardsMessage::has_playerresult() const {
  return _internal_has_playerresult();
}
inline void AfterHandShowCardsMessage::clear_playerresult() {
  if (playerresult_ != nullptr) playerresult_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerResult& AfterHandShowCardsMessage::_internal_playerresult() const {
  const ::PlayerResult* p = playerresult_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerResult&>(
      ::_PlayerResult_default_instance_);
}
inline const ::PlayerResult& AfterHandShowCardsMessage::playerresult() const {
  // @@protoc_insertion_point(field_get:AfterHandShowCardsMessage.playerResult)
  return _internal_playerresult();
}
inline void AfterHandShowCardsMessage::unsafe_arena_set_allocated_playerresult(
    ::PlayerResult* playerresult) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerresult_);
  }
  playerresult_ = playerresult;
  if (playerresult) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AfterHandShowCardsMessage.playerResult)
}
inline ::PlayerResult* AfterHandShowCardsMessage::release_playerresult() {
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerResult* temp = playerresult_;
  playerresult_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerResult* AfterHandShowCardsMessage::unsafe_arena_release_playerresult() {
  // @@protoc_insertion_point(field_release:AfterHandShowCardsMessage.playerResult)
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerResult* temp = playerresult_;
  playerresult_ = nullptr;
  return temp;
}
inline ::PlayerResult* AfterHandShowCardsMessage::_internal_mutable_playerresult() {
  _has_bits_[0] |= 0x00000001u;
  if (playerresult_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerResult>(GetArenaForAllocation());
    playerresult_ = p;
  }
  return playerresult_;
}
inline ::PlayerResult* AfterHandShowCardsMessage::mutable_playerresult() {
  ::PlayerResult* _msg = _internal_mutable_playerresult();
  // @@protoc_insertion_point(field_mutable:AfterHandShowCardsMessage.playerResult)
  return _msg;
}
inline void AfterHandShowCardsMessage::set_allocated_playerresult(::PlayerResult* playerresult) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerresult_;
  }
  if (playerresult) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerResult>::GetOwningArena(playerresult);
    if (message_arena != submessage_arena) {
      playerresult = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerresult, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerresult_ = playerresult;
  // @@protoc_insertion_point(field_set_allocated:AfterHandShowCardsMessage.playerResult)
}

// -------------------------------------------------------------------

// EndOfGameMessage

// required uint32 gameId = 1;
inline bool EndOfGameMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EndOfGameMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void EndOfGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t EndOfGameMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t EndOfGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfGameMessage.gameId)
  return _internal_gameid();
}
inline void EndOfGameMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void EndOfGameMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:EndOfGameMessage.gameId)
}

// required uint32 winnerPlayerId = 2;
inline bool EndOfGameMessage::_internal_has_winnerplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EndOfGameMessage::has_winnerplayerid() const {
  return _internal_has_winnerplayerid();
}
inline void EndOfGameMessage::clear_winnerplayerid() {
  winnerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t EndOfGameMessage::_internal_winnerplayerid() const {
  return winnerplayerid_;
}
inline uint32_t EndOfGameMessage::winnerplayerid() const {
  // @@protoc_insertion_point(field_get:EndOfGameMessage.winnerPlayerId)
  return _internal_winnerplayerid();
}
inline void EndOfGameMessage::_internal_set_winnerplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  winnerplayerid_ = value;
}
inline void EndOfGameMessage::set_winnerplayerid(uint32_t value) {
  _internal_set_winnerplayerid(value);
  // @@protoc_insertion_point(field_set:EndOfGameMessage.winnerPlayerId)
}

// -------------------------------------------------------------------

// PlayerIdChangedMessage

// required uint32 oldPlayerId = 1;
inline bool PlayerIdChangedMessage::_internal_has_oldplayerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerIdChangedMessage::has_oldplayerid() const {
  return _internal_has_oldplayerid();
}
inline void PlayerIdChangedMessage::clear_oldplayerid() {
  oldplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PlayerIdChangedMessage::_internal_oldplayerid() const {
  return oldplayerid_;
}
inline uint32_t PlayerIdChangedMessage::oldplayerid() const {
  // @@protoc_insertion_point(field_get:PlayerIdChangedMessage.oldPlayerId)
  return _internal_oldplayerid();
}
inline void PlayerIdChangedMessage::_internal_set_oldplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  oldplayerid_ = value;
}
inline void PlayerIdChangedMessage::set_oldplayerid(uint32_t value) {
  _internal_set_oldplayerid(value);
  // @@protoc_insertion_point(field_set:PlayerIdChangedMessage.oldPlayerId)
}

// required uint32 newPlayerId = 2;
inline bool PlayerIdChangedMessage::_internal_has_newplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerIdChangedMessage::has_newplayerid() const {
  return _internal_has_newplayerid();
}
inline void PlayerIdChangedMessage::clear_newplayerid() {
  newplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PlayerIdChangedMessage::_internal_newplayerid() const {
  return newplayerid_;
}
inline uint32_t PlayerIdChangedMessage::newplayerid() const {
  // @@protoc_insertion_point(field_get:PlayerIdChangedMessage.newPlayerId)
  return _internal_newplayerid();
}
inline void PlayerIdChangedMessage::_internal_set_newplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  newplayerid_ = value;
}
inline void PlayerIdChangedMessage::set_newplayerid(uint32_t value) {
  _internal_set_newplayerid(value);
  // @@protoc_insertion_point(field_set:PlayerIdChangedMessage.newPlayerId)
}

// -------------------------------------------------------------------

// AskKickPlayerMessage

// required uint32 gameId = 1;
inline bool AskKickPlayerMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AskKickPlayerMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void AskKickPlayerMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AskKickPlayerMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t AskKickPlayerMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AskKickPlayerMessage.gameId)
  return _internal_gameid();
}
inline void AskKickPlayerMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void AskKickPlayerMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:AskKickPlayerMessage.gameId)
}

// required uint32 playerId = 2;
inline bool AskKickPlayerMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AskKickPlayerMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void AskKickPlayerMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AskKickPlayerMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t AskKickPlayerMessage::playerid() const {
  // @@protoc_insertion_point(field_get:AskKickPlayerMessage.playerId)
  return _internal_playerid();
}
inline void AskKickPlayerMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void AskKickPlayerMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:AskKickPlayerMessage.playerId)
}

// -------------------------------------------------------------------

// AskKickDeniedMessage

// required uint32 gameId = 1;
inline bool AskKickDeniedMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AskKickDeniedMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void AskKickDeniedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AskKickDeniedMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t AskKickDeniedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.gameId)
  return _internal_gameid();
}
inline void AskKickDeniedMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void AskKickDeniedMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool AskKickDeniedMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AskKickDeniedMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void AskKickDeniedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AskKickDeniedMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t AskKickDeniedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.playerId)
  return _internal_playerid();
}
inline void AskKickDeniedMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
}
inline void AskKickDeniedMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.playerId)
}

// required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
inline bool AskKickDeniedMessage::_internal_has_kickdeniedreason() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AskKickDeniedMessage::has_kickdeniedreason() const {
  return _internal_has_kickdeniedreason();
}
inline void AskKickDeniedMessage::clear_kickdeniedreason() {
  kickdeniedreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::_internal_kickdeniedreason() const {
  return static_cast< ::AskKickDeniedMessage_KickDeniedReason >(kickdeniedreason_);
}
inline ::AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickdeniedreason() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.kickDeniedReason)
  return _internal_kickdeniedreason();
}
inline void AskKickDeniedMessage::_internal_set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value) {
  assert(::AskKickDeniedMessage_KickDeniedReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  kickdeniedreason_ = value;
}
inline void AskKickDeniedMessage::set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value) {
  _internal_set_kickdeniedreason(value);
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.kickDeniedReason)
}

// -------------------------------------------------------------------

// StartKickPetitionMessage

// required uint32 gameId = 1;
inline bool StartKickPetitionMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StartKickPetitionMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void StartKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StartKickPetitionMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t StartKickPetitionMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.gameId)
  return _internal_gameid();
}
inline void StartKickPetitionMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void StartKickPetitionMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool StartKickPetitionMessage::_internal_has_petitionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StartKickPetitionMessage::has_petitionid() const {
  return _internal_has_petitionid();
}
inline void StartKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StartKickPetitionMessage::_internal_petitionid() const {
  return petitionid_;
}
inline uint32_t StartKickPetitionMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.petitionId)
  return _internal_petitionid();
}
inline void StartKickPetitionMessage::_internal_set_petitionid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
}
inline void StartKickPetitionMessage::set_petitionid(uint32_t value) {
  _internal_set_petitionid(value);
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.petitionId)
}

// required uint32 proposingPlayerId = 3;
inline bool StartKickPetitionMessage::_internal_has_proposingplayerid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StartKickPetitionMessage::has_proposingplayerid() const {
  return _internal_has_proposingplayerid();
}
inline void StartKickPetitionMessage::clear_proposingplayerid() {
  proposingplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StartKickPetitionMessage::_internal_proposingplayerid() const {
  return proposingplayerid_;
}
inline uint32_t StartKickPetitionMessage::proposingplayerid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.proposingPlayerId)
  return _internal_proposingplayerid();
}
inline void StartKickPetitionMessage::_internal_set_proposingplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  proposingplayerid_ = value;
}
inline void StartKickPetitionMessage::set_proposingplayerid(uint32_t value) {
  _internal_set_proposingplayerid(value);
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.proposingPlayerId)
}

// required uint32 kickPlayerId = 4;
inline bool StartKickPetitionMessage::_internal_has_kickplayerid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StartKickPetitionMessage::has_kickplayerid() const {
  return _internal_has_kickplayerid();
}
inline void StartKickPetitionMessage::clear_kickplayerid() {
  kickplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t StartKickPetitionMessage::_internal_kickplayerid() const {
  return kickplayerid_;
}
inline uint32_t StartKickPetitionMessage::kickplayerid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.kickPlayerId)
  return _internal_kickplayerid();
}
inline void StartKickPetitionMessage::_internal_set_kickplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  kickplayerid_ = value;
}
inline void StartKickPetitionMessage::set_kickplayerid(uint32_t value) {
  _internal_set_kickplayerid(value);
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.kickPlayerId)
}

// required uint32 kickTimeoutSec = 5;
inline bool StartKickPetitionMessage::_internal_has_kicktimeoutsec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StartKickPetitionMessage::has_kicktimeoutsec() const {
  return _internal_has_kicktimeoutsec();
}
inline void StartKickPetitionMessage::clear_kicktimeoutsec() {
  kicktimeoutsec_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t StartKickPetitionMessage::_internal_kicktimeoutsec() const {
  return kicktimeoutsec_;
}
inline uint32_t StartKickPetitionMessage::kicktimeoutsec() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.kickTimeoutSec)
  return _internal_kicktimeoutsec();
}
inline void StartKickPetitionMessage::_internal_set_kicktimeoutsec(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  kicktimeoutsec_ = value;
}
inline void StartKickPetitionMessage::set_kicktimeoutsec(uint32_t value) {
  _internal_set_kicktimeoutsec(value);
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.kickTimeoutSec)
}

// required uint32 numVotesNeededToKick = 6;
inline bool StartKickPetitionMessage::_internal_has_numvotesneededtokick() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StartKickPetitionMessage::has_numvotesneededtokick() const {
  return _internal_has_numvotesneededtokick();
}
inline void StartKickPetitionMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t StartKickPetitionMessage::_internal_numvotesneededtokick() const {
  return numvotesneededtokick_;
}
inline uint32_t StartKickPetitionMessage::numvotesneededtokick() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.numVotesNeededToKick)
  return _internal_numvotesneededtokick();
}
inline void StartKickPetitionMessage::_internal_set_numvotesneededtokick(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  numvotesneededtokick_ = value;
}
inline void StartKickPetitionMessage::set_numvotesneededtokick(uint32_t value) {
  _internal_set_numvotesneededtokick(value);
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.numVotesNeededToKick)
}

// -------------------------------------------------------------------

// VoteKickRequestMessage

// required uint32 gameId = 1;
inline bool VoteKickRequestMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoteKickRequestMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void VoteKickRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t VoteKickRequestMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t VoteKickRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.gameId)
  return _internal_gameid();
}
inline void VoteKickRequestMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void VoteKickRequestMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool VoteKickRequestMessage::_internal_has_petitionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VoteKickRequestMessage::has_petitionid() const {
  return _internal_has_petitionid();
}
inline void VoteKickRequestMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t VoteKickRequestMessage::_internal_petitionid() const {
  return petitionid_;
}
inline uint32_t VoteKickRequestMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.petitionId)
  return _internal_petitionid();
}
inline void VoteKickRequestMessage::_internal_set_petitionid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
}
inline void VoteKickRequestMessage::set_petitionid(uint32_t value) {
  _internal_set_petitionid(value);
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.petitionId)
}

// required bool voteKick = 3;
inline bool VoteKickRequestMessage::_internal_has_votekick() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VoteKickRequestMessage::has_votekick() const {
  return _internal_has_votekick();
}
inline void VoteKickRequestMessage::clear_votekick() {
  votekick_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool VoteKickRequestMessage::_internal_votekick() const {
  return votekick_;
}
inline bool VoteKickRequestMessage::votekick() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.voteKick)
  return _internal_votekick();
}
inline void VoteKickRequestMessage::_internal_set_votekick(bool value) {
  _has_bits_[0] |= 0x00000004u;
  votekick_ = value;
}
inline void VoteKickRequestMessage::set_votekick(bool value) {
  _internal_set_votekick(value);
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.voteKick)
}

// -------------------------------------------------------------------

// VoteKickReplyMessage

// required uint32 gameId = 1;
inline bool VoteKickReplyMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoteKickReplyMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void VoteKickReplyMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t VoteKickReplyMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t VoteKickReplyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.gameId)
  return _internal_gameid();
}
inline void VoteKickReplyMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void VoteKickReplyMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool VoteKickReplyMessage::_internal_has_petitionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VoteKickReplyMessage::has_petitionid() const {
  return _internal_has_petitionid();
}
inline void VoteKickReplyMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t VoteKickReplyMessage::_internal_petitionid() const {
  return petitionid_;
}
inline uint32_t VoteKickReplyMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.petitionId)
  return _internal_petitionid();
}
inline void VoteKickReplyMessage::_internal_set_petitionid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
}
inline void VoteKickReplyMessage::set_petitionid(uint32_t value) {
  _internal_set_petitionid(value);
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.petitionId)
}

// required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
inline bool VoteKickReplyMessage::_internal_has_votekickreplytype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VoteKickReplyMessage::has_votekickreplytype() const {
  return _internal_has_votekickreplytype();
}
inline void VoteKickReplyMessage::clear_votekickreplytype() {
  votekickreplytype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::_internal_votekickreplytype() const {
  return static_cast< ::VoteKickReplyMessage_VoteKickReplyType >(votekickreplytype_);
}
inline ::VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::votekickreplytype() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.voteKickReplyType)
  return _internal_votekickreplytype();
}
inline void VoteKickReplyMessage::_internal_set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value) {
  assert(::VoteKickReplyMessage_VoteKickReplyType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  votekickreplytype_ = value;
}
inline void VoteKickReplyMessage::set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value) {
  _internal_set_votekickreplytype(value);
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.voteKickReplyType)
}

// -------------------------------------------------------------------

// KickPetitionUpdateMessage

// required uint32 gameId = 1;
inline bool KickPetitionUpdateMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickPetitionUpdateMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void KickPetitionUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t KickPetitionUpdateMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t KickPetitionUpdateMessage::gameid() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.gameId)
  return _internal_gameid();
}
inline void KickPetitionUpdateMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void KickPetitionUpdateMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool KickPetitionUpdateMessage::_internal_has_petitionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KickPetitionUpdateMessage::has_petitionid() const {
  return _internal_has_petitionid();
}
inline void KickPetitionUpdateMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t KickPetitionUpdateMessage::_internal_petitionid() const {
  return petitionid_;
}
inline uint32_t KickPetitionUpdateMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.petitionId)
  return _internal_petitionid();
}
inline void KickPetitionUpdateMessage::_internal_set_petitionid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
}
inline void KickPetitionUpdateMessage::set_petitionid(uint32_t value) {
  _internal_set_petitionid(value);
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.petitionId)
}

// required uint32 numVotesAgainstKicking = 3;
inline bool KickPetitionUpdateMessage::_internal_has_numvotesagainstkicking() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KickPetitionUpdateMessage::has_numvotesagainstkicking() const {
  return _internal_has_numvotesagainstkicking();
}
inline void KickPetitionUpdateMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t KickPetitionUpdateMessage::_internal_numvotesagainstkicking() const {
  return numvotesagainstkicking_;
}
inline uint32_t KickPetitionUpdateMessage::numvotesagainstkicking() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesAgainstKicking)
  return _internal_numvotesagainstkicking();
}
inline void KickPetitionUpdateMessage::_internal_set_numvotesagainstkicking(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  numvotesagainstkicking_ = value;
}
inline void KickPetitionUpdateMessage::set_numvotesagainstkicking(uint32_t value) {
  _internal_set_numvotesagainstkicking(value);
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesAgainstKicking)
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool KickPetitionUpdateMessage::_internal_has_numvotesinfavourofkicking() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KickPetitionUpdateMessage::has_numvotesinfavourofkicking() const {
  return _internal_has_numvotesinfavourofkicking();
}
inline void KickPetitionUpdateMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t KickPetitionUpdateMessage::_internal_numvotesinfavourofkicking() const {
  return numvotesinfavourofkicking_;
}
inline uint32_t KickPetitionUpdateMessage::numvotesinfavourofkicking() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesInFavourOfKicking)
  return _internal_numvotesinfavourofkicking();
}
inline void KickPetitionUpdateMessage::_internal_set_numvotesinfavourofkicking(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  numvotesinfavourofkicking_ = value;
}
inline void KickPetitionUpdateMessage::set_numvotesinfavourofkicking(uint32_t value) {
  _internal_set_numvotesinfavourofkicking(value);
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesInFavourOfKicking)
}

// required uint32 numVotesNeededToKick = 5;
inline bool KickPetitionUpdateMessage::_internal_has_numvotesneededtokick() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool KickPetitionUpdateMessage::has_numvotesneededtokick() const {
  return _internal_has_numvotesneededtokick();
}
inline void KickPetitionUpdateMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t KickPetitionUpdateMessage::_internal_numvotesneededtokick() const {
  return numvotesneededtokick_;
}
inline uint32_t KickPetitionUpdateMessage::numvotesneededtokick() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesNeededToKick)
  return _internal_numvotesneededtokick();
}
inline void KickPetitionUpdateMessage::_internal_set_numvotesneededtokick(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  numvotesneededtokick_ = value;
}
inline void KickPetitionUpdateMessage::set_numvotesneededtokick(uint32_t value) {
  _internal_set_numvotesneededtokick(value);
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesNeededToKick)
}

// -------------------------------------------------------------------

// EndKickPetitionMessage

// required uint32 gameId = 1;
inline bool EndKickPetitionMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EndKickPetitionMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void EndKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t EndKickPetitionMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t EndKickPetitionMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.gameId)
  return _internal_gameid();
}
inline void EndKickPetitionMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
}
inline void EndKickPetitionMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool EndKickPetitionMessage::_internal_has_petitionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EndKickPetitionMessage::has_petitionid() const {
  return _internal_has_petitionid();
}
inline void EndKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t EndKickPetitionMessage::_internal_petitionid() const {
  return petitionid_;
}
inline uint32_t EndKickPetitionMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.petitionId)
  return _internal_petitionid();
}
inline void EndKickPetitionMessage::_internal_set_petitionid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
}
inline void EndKickPetitionMessage::set_petitionid(uint32_t value) {
  _internal_set_petitionid(value);
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.petitionId)
}

// required uint32 numVotesAgainstKicking = 3;
inline bool EndKickPetitionMessage::_internal_has_numvotesagainstkicking() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EndKickPetitionMessage::has_numvotesagainstkicking() const {
  return _internal_has_numvotesagainstkicking();
}
inline void EndKickPetitionMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t EndKickPetitionMessage::_internal_numvotesagainstkicking() const {
  return numvotesagainstkicking_;
}
inline uint32_t EndKickPetitionMessage::numvotesagainstkicking() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.numVotesAgainstKicking)
  return _internal_numvotesagainstkicking();
}
inline void EndKickPetitionMessage::_internal_set_numvotesagainstkicking(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  numvotesagainstkicking_ = value;
}
inline void EndKickPetitionMessage::set_numvotesagainstkicking(uint32_t value) {
  _internal_set_numvotesagainstkicking(value);
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.numVotesAgainstKicking)
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool EndKickPetitionMessage::_internal_has_numvotesinfavourofkicking() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EndKickPetitionMessage::has_numvotesinfavourofkicking() const {
  return _internal_has_numvotesinfavourofkicking();
}
inline void EndKickPetitionMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t EndKickPetitionMessage::_internal_numvotesinfavourofkicking() const {
  return numvotesinfavourofkicking_;
}
inline uint32_t EndKickPetitionMessage::numvotesinfavourofkicking() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.numVotesInFavourOfKicking)
  return _internal_numvotesinfavourofkicking();
}
inline void EndKickPetitionMessage::_internal_set_numvotesinfavourofkicking(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  numvotesinfavourofkicking_ = value;
}
inline void EndKickPetitionMessage::set_numvotesinfavourofkicking(uint32_t value) {
  _internal_set_numvotesinfavourofkicking(value);
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.numVotesInFavourOfKicking)
}

// required uint32 resultPlayerKicked = 5;
inline bool EndKickPetitionMessage::_internal_has_resultplayerkicked() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EndKickPetitionMessage::has_resultplayerkicked() const {
  return _internal_has_resultplayerkicked();
}
inline void EndKickPetitionMessage::clear_resultplayerkicked() {
  resultplayerkicked_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t EndKickPetitionMessage::_internal_resultplayerkicked() const {
  return resultplayerkicked_;
}
inline uint32_t EndKickPetitionMessage::resultplayerkicked() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.resultPlayerKicked)
  return _internal_resultplayerkicked();
}
inline void EndKickPetitionMessage::_internal_set_resultplayerkicked(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  resultplayerkicked_ = value;
}
inline void EndKickPetitionMessage::set_resultplayerkicked(uint32_t value) {
  _internal_set_resultplayerkicked(value);
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.resultPlayerKicked)
}

// required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
inline bool EndKickPetitionMessage::_internal_has_petitionendreason() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EndKickPetitionMessage::has_petitionendreason() const {
  return _internal_has_petitionendreason();
}
inline void EndKickPetitionMessage::clear_petitionendreason() {
  petitionendreason_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::_internal_petitionendreason() const {
  return static_cast< ::EndKickPetitionMessage_PetitionEndReason >(petitionendreason_);
}
inline ::EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionendreason() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.petitionEndReason)
  return _internal_petitionendreason();
}
inline void EndKickPetitionMessage::_internal_set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value) {
  assert(::EndKickPetitionMessage_PetitionEndReason_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  petitionendreason_ = value;
}
inline void EndKickPetitionMessage::set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value) {
  _internal_set_petitionendreason(value);
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.petitionEndReason)
}

// -------------------------------------------------------------------

// StatisticsMessage_StatisticsData

// required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
inline bool StatisticsMessage_StatisticsData::_internal_has_statisticstype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatisticsMessage_StatisticsData::has_statisticstype() const {
  return _internal_has_statisticstype();
}
inline void StatisticsMessage_StatisticsData::clear_statisticstype() {
  statisticstype_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::_internal_statisticstype() const {
  return static_cast< ::StatisticsMessage_StatisticsData_StatisticsType >(statisticstype_);
}
inline ::StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::statisticstype() const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.StatisticsData.statisticsType)
  return _internal_statisticstype();
}
inline void StatisticsMessage_StatisticsData::_internal_set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value) {
  assert(::StatisticsMessage_StatisticsData_StatisticsType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  statisticstype_ = value;
}
inline void StatisticsMessage_StatisticsData::set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value) {
  _internal_set_statisticstype(value);
  // @@protoc_insertion_point(field_set:StatisticsMessage.StatisticsData.statisticsType)
}

// required uint32 statisticsValue = 2;
inline bool StatisticsMessage_StatisticsData::_internal_has_statisticsvalue() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatisticsMessage_StatisticsData::has_statisticsvalue() const {
  return _internal_has_statisticsvalue();
}
inline void StatisticsMessage_StatisticsData::clear_statisticsvalue() {
  statisticsvalue_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StatisticsMessage_StatisticsData::_internal_statisticsvalue() const {
  return statisticsvalue_;
}
inline uint32_t StatisticsMessage_StatisticsData::statisticsvalue() const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.StatisticsData.statisticsValue)
  return _internal_statisticsvalue();
}
inline void StatisticsMessage_StatisticsData::_internal_set_statisticsvalue(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  statisticsvalue_ = value;
}
inline void StatisticsMessage_StatisticsData::set_statisticsvalue(uint32_t value) {
  _internal_set_statisticsvalue(value);
  // @@protoc_insertion_point(field_set:StatisticsMessage.StatisticsData.statisticsValue)
}

// -------------------------------------------------------------------

// StatisticsMessage

// repeated .StatisticsMessage.StatisticsData statisticsData = 1;
inline int StatisticsMessage::_internal_statisticsdata_size() const {
  return statisticsdata_.size();
}
inline int StatisticsMessage::statisticsdata_size() const {
  return _internal_statisticsdata_size();
}
inline void StatisticsMessage::clear_statisticsdata() {
  statisticsdata_.Clear();
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::mutable_statisticsdata(int index) {
  // @@protoc_insertion_point(field_mutable:StatisticsMessage.statisticsData)
  return statisticsdata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
StatisticsMessage::mutable_statisticsdata() {
  // @@protoc_insertion_point(field_mutable_list:StatisticsMessage.statisticsData)
  return &statisticsdata_;
}
inline const ::StatisticsMessage_StatisticsData& StatisticsMessage::_internal_statisticsdata(int index) const {
  return statisticsdata_.Get(index);
}
inline const ::StatisticsMessage_StatisticsData& StatisticsMessage::statisticsdata(int index) const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.statisticsData)
  return _internal_statisticsdata(index);
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::_internal_add_statisticsdata() {
  return statisticsdata_.Add();
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::add_statisticsdata() {
  ::StatisticsMessage_StatisticsData* _add = _internal_add_statisticsdata();
  // @@protoc_insertion_point(field_add:StatisticsMessage.statisticsData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
StatisticsMessage::statisticsdata() const {
  // @@protoc_insertion_point(field_list:StatisticsMessage.statisticsData)
  return statisticsdata_;
}

// -------------------------------------------------------------------

// ChatRequestMessage

// optional uint32 targetGameId = 1;
inline bool ChatRequestMessage::_internal_has_targetgameid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatRequestMessage::has_targetgameid() const {
  return _internal_has_targetgameid();
}
inline void ChatRequestMessage::clear_targetgameid() {
  targetgameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChatRequestMessage::_internal_targetgameid() const {
  return targetgameid_;
}
inline uint32_t ChatRequestMessage::targetgameid() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.targetGameId)
  return _internal_targetgameid();
}
inline void ChatRequestMessage::_internal_set_targetgameid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  targetgameid_ = value;
}
inline void ChatRequestMessage::set_targetgameid(uint32_t value) {
  _internal_set_targetgameid(value);
  // @@protoc_insertion_point(field_set:ChatRequestMessage.targetGameId)
}

// optional uint32 targetPlayerId = 2;
inline bool ChatRequestMessage::_internal_has_targetplayerid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChatRequestMessage::has_targetplayerid() const {
  return _internal_has_targetplayerid();
}
inline void ChatRequestMessage::clear_targetplayerid() {
  targetplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChatRequestMessage::_internal_targetplayerid() const {
  return targetplayerid_;
}
inline uint32_t ChatRequestMessage::targetplayerid() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.targetPlayerId)
  return _internal_targetplayerid();
}
inline void ChatRequestMessage::_internal_set_targetplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  targetplayerid_ = value;
}
inline void ChatRequestMessage::set_targetplayerid(uint32_t value) {
  _internal_set_targetplayerid(value);
  // @@protoc_insertion_point(field_set:ChatRequestMessage.targetPlayerId)
}

// required string chatText = 3;
inline bool ChatRequestMessage::_internal_has_chattext() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatRequestMessage::has_chattext() const {
  return _internal_has_chattext();
}
inline void ChatRequestMessage::clear_chattext() {
  chattext_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatRequestMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.chatText)
  return _internal_chattext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatRequestMessage::set_chattext(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatRequestMessage.chatText)
}
inline std::string* ChatRequestMessage::mutable_chattext() {
  std::string* _s = _internal_mutable_chattext();
  // @@protoc_insertion_point(field_mutable:ChatRequestMessage.chatText)
  return _s;
}
inline const std::string& ChatRequestMessage::_internal_chattext() const {
  return chattext_.Get();
}
inline void ChatRequestMessage::_internal_set_chattext(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatRequestMessage::_internal_mutable_chattext() {
  _has_bits_[0] |= 0x00000001u;
  return chattext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatRequestMessage::release_chattext() {
  // @@protoc_insertion_point(field_release:ChatRequestMessage.chatText)
  if (!_internal_has_chattext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = chattext_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatRequestMessage::set_allocated_chattext(std::string* chattext) {
  if (chattext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chattext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chattext,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatRequestMessage.chatText)
}

// -------------------------------------------------------------------

// ChatMessage

// optional uint32 gameId = 1;
inline bool ChatMessage::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void ChatMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChatMessage::_internal_gameid() const {
  return gameid_;
}
inline uint32_t ChatMessage::gameid() const {
  // @@protoc_insertion_point(field_get:ChatMessage.gameId)
  return _internal_gameid();
}
inline void ChatMessage::_internal_set_gameid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
}
inline void ChatMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:ChatMessage.gameId)
}

// optional uint32 playerId = 2;
inline bool ChatMessage::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChatMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void ChatMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChatMessage::_internal_playerid() const {
  return playerid_;
}
inline uint32_t ChatMessage::playerid() const {
  // @@protoc_insertion_point(field_get:ChatMessage.playerId)
  return _internal_playerid();
}
inline void ChatMessage::_internal_set_playerid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  playerid_ = value;
}
inline void ChatMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:ChatMessage.playerId)
}

// required .ChatMessage.ChatType chatType = 3;
inline bool ChatMessage::_internal_has_chattype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChatMessage::has_chattype() const {
  return _internal_has_chattype();
}
inline void ChatMessage::clear_chattype() {
  chattype_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ChatMessage_ChatType ChatMessage::_internal_chattype() const {
  return static_cast< ::ChatMessage_ChatType >(chattype_);
}
inline ::ChatMessage_ChatType ChatMessage::chattype() const {
  // @@protoc_insertion_point(field_get:ChatMessage.chatType)
  return _internal_chattype();
}
inline void ChatMessage::_internal_set_chattype(::ChatMessage_ChatType value) {
  assert(::ChatMessage_ChatType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  chattype_ = value;
}
inline void ChatMessage::set_chattype(::ChatMessage_ChatType value) {
  _internal_set_chattype(value);
  // @@protoc_insertion_point(field_set:ChatMessage.chatType)
}

// required string chatText = 4;
inline bool ChatMessage::_internal_has_chattext() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatMessage::has_chattext() const {
  return _internal_has_chattext();
}
inline void ChatMessage::clear_chattext() {
  chattext_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatMessage.chatText)
  return _internal_chattext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_chattext(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatMessage.chatText)
}
inline std::string* ChatMessage::mutable_chattext() {
  std::string* _s = _internal_mutable_chattext();
  // @@protoc_insertion_point(field_mutable:ChatMessage.chatText)
  return _s;
}
inline const std::string& ChatMessage::_internal_chattext() const {
  return chattext_.Get();
}
inline void ChatMessage::_internal_set_chattext(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_chattext() {
  _has_bits_[0] |= 0x00000001u;
  return chattext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_chattext() {
  // @@protoc_insertion_point(field_release:ChatMessage.chatText)
  if (!_internal_has_chattext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = chattext_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatMessage::set_allocated_chattext(std::string* chattext) {
  if (chattext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chattext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chattext,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.chatText)
}

// -------------------------------------------------------------------

// ChatRejectMessage

// required string chatText = 1;
inline bool ChatRejectMessage::_internal_has_chattext() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatRejectMessage::has_chattext() const {
  return _internal_has_chattext();
}
inline void ChatRejectMessage::clear_chattext() {
  chattext_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatRejectMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatRejectMessage.chatText)
  return _internal_chattext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatRejectMessage::set_chattext(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatRejectMessage.chatText)
}
inline std::string* ChatRejectMessage::mutable_chattext() {
  std::string* _s = _internal_mutable_chattext();
  // @@protoc_insertion_point(field_mutable:ChatRejectMessage.chatText)
  return _s;
}
inline const std::string& ChatRejectMessage::_internal_chattext() const {
  return chattext_.Get();
}
inline void ChatRejectMessage::_internal_set_chattext(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatRejectMessage::_internal_mutable_chattext() {
  _has_bits_[0] |= 0x00000001u;
  return chattext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatRejectMessage::release_chattext() {
  // @@protoc_insertion_point(field_release:ChatRejectMessage.chatText)
  if (!_internal_has_chattext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = chattext_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatRejectMessage::set_allocated_chattext(std::string* chattext) {
  if (chattext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chattext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chattext,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatRejectMessage.chatText)
}

// -------------------------------------------------------------------

// DialogMessage

// required string notificationText = 1;
inline bool DialogMessage::_internal_has_notificationtext() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DialogMessage::has_notificationtext() const {
  return _internal_has_notificationtext();
}
inline void DialogMessage::clear_notificationtext() {
  notificationtext_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DialogMessage::notificationtext() const {
  // @@protoc_insertion_point(field_get:DialogMessage.notificationText)
  return _internal_notificationtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DialogMessage::set_notificationtext(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 notificationtext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DialogMessage.notificationText)
}
inline std::string* DialogMessage::mutable_notificationtext() {
  std::string* _s = _internal_mutable_notificationtext();
  // @@protoc_insertion_point(field_mutable:DialogMessage.notificationText)
  return _s;
}
inline const std::string& DialogMessage::_internal_notificationtext() const {
  return notificationtext_.Get();
}
inline void DialogMessage::_internal_set_notificationtext(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  notificationtext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DialogMessage::_internal_mutable_notificationtext() {
  _has_bits_[0] |= 0x00000001u;
  return notificationtext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DialogMessage::release_notificationtext() {
  // @@protoc_insertion_point(field_release:DialogMessage.notificationText)
  if (!_internal_has_notificationtext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = notificationtext_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (notificationtext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    notificationtext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DialogMessage::set_allocated_notificationtext(std::string* notificationtext) {
  if (notificationtext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  notificationtext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), notificationtext,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (notificationtext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    notificationtext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DialogMessage.notificationText)
}

// -------------------------------------------------------------------

// TimeoutWarningMessage

// required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
inline bool TimeoutWarningMessage::_internal_has_timeoutreason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimeoutWarningMessage::has_timeoutreason() const {
  return _internal_has_timeoutreason();
}
inline void TimeoutWarningMessage::clear_timeoutreason() {
  timeoutreason_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::_internal_timeoutreason() const {
  return static_cast< ::TimeoutWarningMessage_TimeoutReason >(timeoutreason_);
}
inline ::TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutreason() const {
  // @@protoc_insertion_point(field_get:TimeoutWarningMessage.timeoutReason)
  return _internal_timeoutreason();
}
inline void TimeoutWarningMessage::_internal_set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value) {
  assert(::TimeoutWarningMessage_TimeoutReason_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  timeoutreason_ = value;
}
inline void TimeoutWarningMessage::set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value) {
  _internal_set_timeoutreason(value);
  // @@protoc_insertion_point(field_set:TimeoutWarningMessage.timeoutReason)
}

// required uint32 remainingSeconds = 2;
inline bool TimeoutWarningMessage::_internal_has_remainingseconds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimeoutWarningMessage::has_remainingseconds() const {
  return _internal_has_remainingseconds();
}
inline void TimeoutWarningMessage::clear_remainingseconds() {
  remainingseconds_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TimeoutWarningMessage::_internal_remainingseconds() const {
  return remainingseconds_;
}
inline uint32_t TimeoutWarningMessage::remainingseconds() const {
  // @@protoc_insertion_point(field_get:TimeoutWarningMessage.remainingSeconds)
  return _internal_remainingseconds();
}
inline void TimeoutWarningMessage::_internal_set_remainingseconds(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  remainingseconds_ = value;
}
inline void TimeoutWarningMessage::set_remainingseconds(uint32_t value) {
  _internal_set_remainingseconds(value);
  // @@protoc_insertion_point(field_set:TimeoutWarningMessage.remainingSeconds)
}

// -------------------------------------------------------------------

// ResetTimeoutMessage

// -------------------------------------------------------------------

// ReportAvatarMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarMessage::_internal_has_reportedplayerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReportAvatarMessage::has_reportedplayerid() const {
  return _internal_has_reportedplayerid();
}
inline void ReportAvatarMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ReportAvatarMessage::_internal_reportedplayerid() const {
  return reportedplayerid_;
}
inline uint32_t ReportAvatarMessage::reportedplayerid() const {
  // @@protoc_insertion_point(field_get:ReportAvatarMessage.reportedPlayerId)
  return _internal_reportedplayerid();
}
inline void ReportAvatarMessage::_internal_set_reportedplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  reportedplayerid_ = value;
}
inline void ReportAvatarMessage::set_reportedplayerid(uint32_t value) {
  _internal_set_reportedplayerid(value);
  // @@protoc_insertion_point(field_set:ReportAvatarMessage.reportedPlayerId)
}

// required bytes reportedAvatarHash = 2;
inline bool ReportAvatarMessage::_internal_has_reportedavatarhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReportAvatarMessage::has_reportedavatarhash() const {
  return _internal_has_reportedavatarhash();
}
inline void ReportAvatarMessage::clear_reportedavatarhash() {
  reportedavatarhash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReportAvatarMessage::reportedavatarhash() const {
  // @@protoc_insertion_point(field_get:ReportAvatarMessage.reportedAvatarHash)
  return _internal_reportedavatarhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportAvatarMessage::set_reportedavatarhash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reportedavatarhash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReportAvatarMessage.reportedAvatarHash)
}
inline std::string* ReportAvatarMessage::mutable_reportedavatarhash() {
  std::string* _s = _internal_mutable_reportedavatarhash();
  // @@protoc_insertion_point(field_mutable:ReportAvatarMessage.reportedAvatarHash)
  return _s;
}
inline const std::string& ReportAvatarMessage::_internal_reportedavatarhash() const {
  return reportedavatarhash_.Get();
}
inline void ReportAvatarMessage::_internal_set_reportedavatarhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reportedavatarhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReportAvatarMessage::_internal_mutable_reportedavatarhash() {
  _has_bits_[0] |= 0x00000001u;
  return reportedavatarhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReportAvatarMessage::release_reportedavatarhash() {
  // @@protoc_insertion_point(field_release:ReportAvatarMessage.reportedAvatarHash)
  if (!_internal_has_reportedavatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = reportedavatarhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reportedavatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reportedavatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReportAvatarMessage::set_allocated_reportedavatarhash(std::string* reportedavatarhash) {
  if (reportedavatarhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reportedavatarhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reportedavatarhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reportedavatarhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reportedavatarhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReportAvatarMessage.reportedAvatarHash)
}

// -------------------------------------------------------------------

// ReportAvatarAckMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarAckMessage::_internal_has_reportedplayerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReportAvatarAckMessage::has_reportedplayerid() const {
  return _internal_has_reportedplayerid();
}
inline void ReportAvatarAckMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ReportAvatarAckMessage::_internal_reportedplayerid() const {
  return reportedplayerid_;
}
inline uint32_t ReportAvatarAckMessage::reportedplayerid() const {
  // @@protoc_insertion_point(field_get:ReportAvatarAckMessage.reportedPlayerId)
  return _internal_reportedplayerid();
}
inline void ReportAvatarAckMessage::_internal_set_reportedplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  reportedplayerid_ = value;
}
inline void ReportAvatarAckMessage::set_reportedplayerid(uint32_t value) {
  _internal_set_reportedplayerid(value);
  // @@protoc_insertion_point(field_set:ReportAvatarAckMessage.reportedPlayerId)
}

// required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
inline bool ReportAvatarAckMessage::_internal_has_reportavatarresult() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReportAvatarAckMessage::has_reportavatarresult() const {
  return _internal_has_reportavatarresult();
}
inline void ReportAvatarAckMessage::clear_reportavatarresult() {
  reportavatarresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::_internal_reportavatarresult() const {
  return static_cast< ::ReportAvatarAckMessage_ReportAvatarResult >(reportavatarresult_);
}
inline ::ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::reportavatarresult() const {
  // @@protoc_insertion_point(field_get:ReportAvatarAckMessage.reportAvatarResult)
  return _internal_reportavatarresult();
}
inline void ReportAvatarAckMessage::_internal_set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value) {
  assert(::ReportAvatarAckMessage_ReportAvatarResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  reportavatarresult_ = value;
}
inline void ReportAvatarAckMessage::set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value) {
  _internal_set_reportavatarresult(value);
  // @@protoc_insertion_point(field_set:ReportAvatarAckMessage.reportAvatarResult)
}

// -------------------------------------------------------------------

// ReportGameMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameMessage::_internal_has_reportedgameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReportGameMessage::has_reportedgameid() const {
  return _internal_has_reportedgameid();
}
inline void ReportGameMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ReportGameMessage::_internal_reportedgameid() const {
  return reportedgameid_;
}
inline uint32_t ReportGameMessage::reportedgameid() const {
  // @@protoc_insertion_point(field_get:ReportGameMessage.reportedGameId)
  return _internal_reportedgameid();
}
inline void ReportGameMessage::_internal_set_reportedgameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  reportedgameid_ = value;
}
inline void ReportGameMessage::set_reportedgameid(uint32_t value) {
  _internal_set_reportedgameid(value);
  // @@protoc_insertion_point(field_set:ReportGameMessage.reportedGameId)
}

// -------------------------------------------------------------------

// ReportGameAckMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameAckMessage::_internal_has_reportedgameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReportGameAckMessage::has_reportedgameid() const {
  return _internal_has_reportedgameid();
}
inline void ReportGameAckMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ReportGameAckMessage::_internal_reportedgameid() const {
  return reportedgameid_;
}
inline uint32_t ReportGameAckMessage::reportedgameid() const {
  // @@protoc_insertion_point(field_get:ReportGameAckMessage.reportedGameId)
  return _internal_reportedgameid();
}
inline void ReportGameAckMessage::_internal_set_reportedgameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  reportedgameid_ = value;
}
inline void ReportGameAckMessage::set_reportedgameid(uint32_t value) {
  _internal_set_reportedgameid(value);
  // @@protoc_insertion_point(field_set:ReportGameAckMessage.reportedGameId)
}

// required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
inline bool ReportGameAckMessage::_internal_has_reportgameresult() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReportGameAckMessage::has_reportgameresult() const {
  return _internal_has_reportgameresult();
}
inline void ReportGameAckMessage::clear_reportgameresult() {
  reportgameresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ReportGameAckMessage_ReportGameResult ReportGameAckMessage::_internal_reportgameresult() const {
  return static_cast< ::ReportGameAckMessage_ReportGameResult >(reportgameresult_);
}
inline ::ReportGameAckMessage_ReportGameResult ReportGameAckMessage::reportgameresult() const {
  // @@protoc_insertion_point(field_get:ReportGameAckMessage.reportGameResult)
  return _internal_reportgameresult();
}
inline void ReportGameAckMessage::_internal_set_reportgameresult(::ReportGameAckMessage_ReportGameResult value) {
  assert(::ReportGameAckMessage_ReportGameResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  reportgameresult_ = value;
}
inline void ReportGameAckMessage::set_reportgameresult(::ReportGameAckMessage_ReportGameResult value) {
  _internal_set_reportgameresult(value);
  // @@protoc_insertion_point(field_set:ReportGameAckMessage.reportGameResult)
}

// -------------------------------------------------------------------

// ErrorMessage

// required .ErrorMessage.ErrorReason errorReason = 1;
inline bool ErrorMessage::_internal_has_errorreason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorMessage::has_errorreason() const {
  return _internal_has_errorreason();
}
inline void ErrorMessage::clear_errorreason() {
  errorreason_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ErrorMessage_ErrorReason ErrorMessage::_internal_errorreason() const {
  return static_cast< ::ErrorMessage_ErrorReason >(errorreason_);
}
inline ::ErrorMessage_ErrorReason ErrorMessage::errorreason() const {
  // @@protoc_insertion_point(field_get:ErrorMessage.errorReason)
  return _internal_errorreason();
}
inline void ErrorMessage::_internal_set_errorreason(::ErrorMessage_ErrorReason value) {
  assert(::ErrorMessage_ErrorReason_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  errorreason_ = value;
}
inline void ErrorMessage::set_errorreason(::ErrorMessage_ErrorReason value) {
  _internal_set_errorreason(value);
  // @@protoc_insertion_point(field_set:ErrorMessage.errorReason)
}

// -------------------------------------------------------------------

// AdminRemoveGameMessage

// required uint32 removeGameId = 1;
inline bool AdminRemoveGameMessage::_internal_has_removegameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdminRemoveGameMessage::has_removegameid() const {
  return _internal_has_removegameid();
}
inline void AdminRemoveGameMessage::clear_removegameid() {
  removegameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AdminRemoveGameMessage::_internal_removegameid() const {
  return removegameid_;
}
inline uint32_t AdminRemoveGameMessage::removegameid() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameMessage.removeGameId)
  return _internal_removegameid();
}
inline void AdminRemoveGameMessage::_internal_set_removegameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  removegameid_ = value;
}
inline void AdminRemoveGameMessage::set_removegameid(uint32_t value) {
  _internal_set_removegameid(value);
  // @@protoc_insertion_point(field_set:AdminRemoveGameMessage.removeGameId)
}

// -------------------------------------------------------------------

// AdminRemoveGameAckMessage

// required uint32 removeGameId = 1;
inline bool AdminRemoveGameAckMessage::_internal_has_removegameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdminRemoveGameAckMessage::has_removegameid() const {
  return _internal_has_removegameid();
}
inline void AdminRemoveGameAckMessage::clear_removegameid() {
  removegameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AdminRemoveGameAckMessage::_internal_removegameid() const {
  return removegameid_;
}
inline uint32_t AdminRemoveGameAckMessage::removegameid() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameAckMessage.removeGameId)
  return _internal_removegameid();
}
inline void AdminRemoveGameAckMessage::_internal_set_removegameid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  removegameid_ = value;
}
inline void AdminRemoveGameAckMessage::set_removegameid(uint32_t value) {
  _internal_set_removegameid(value);
  // @@protoc_insertion_point(field_set:AdminRemoveGameAckMessage.removeGameId)
}

// required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
inline bool AdminRemoveGameAckMessage::_internal_has_removegameresult() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdminRemoveGameAckMessage::has_removegameresult() const {
  return _internal_has_removegameresult();
}
inline void AdminRemoveGameAckMessage::clear_removegameresult() {
  removegameresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::_internal_removegameresult() const {
  return static_cast< ::AdminRemoveGameAckMessage_AdminRemoveGameResult >(removegameresult_);
}
inline ::AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::removegameresult() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameAckMessage.removeGameResult)
  return _internal_removegameresult();
}
inline void AdminRemoveGameAckMessage::_internal_set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value) {
  assert(::AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  removegameresult_ = value;
}
inline void AdminRemoveGameAckMessage::set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value) {
  _internal_set_removegameresult(value);
  // @@protoc_insertion_point(field_set:AdminRemoveGameAckMessage.removeGameResult)
}

// -------------------------------------------------------------------

// AdminBanPlayerMessage

// required uint32 banPlayerId = 1;
inline bool AdminBanPlayerMessage::_internal_has_banplayerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdminBanPlayerMessage::has_banplayerid() const {
  return _internal_has_banplayerid();
}
inline void AdminBanPlayerMessage::clear_banplayerid() {
  banplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AdminBanPlayerMessage::_internal_banplayerid() const {
  return banplayerid_;
}
inline uint32_t AdminBanPlayerMessage::banplayerid() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerMessage.banPlayerId)
  return _internal_banplayerid();
}
inline void AdminBanPlayerMessage::_internal_set_banplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  banplayerid_ = value;
}
inline void AdminBanPlayerMessage::set_banplayerid(uint32_t value) {
  _internal_set_banplayerid(value);
  // @@protoc_insertion_point(field_set:AdminBanPlayerMessage.banPlayerId)
}

// -------------------------------------------------------------------

// AdminBanPlayerAckMessage

// required uint32 banPlayerId = 1;
inline bool AdminBanPlayerAckMessage::_internal_has_banplayerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdminBanPlayerAckMessage::has_banplayerid() const {
  return _internal_has_banplayerid();
}
inline void AdminBanPlayerAckMessage::clear_banplayerid() {
  banplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AdminBanPlayerAckMessage::_internal_banplayerid() const {
  return banplayerid_;
}
inline uint32_t AdminBanPlayerAckMessage::banplayerid() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerAckMessage.banPlayerId)
  return _internal_banplayerid();
}
inline void AdminBanPlayerAckMessage::_internal_set_banplayerid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  banplayerid_ = value;
}
inline void AdminBanPlayerAckMessage::set_banplayerid(uint32_t value) {
  _internal_set_banplayerid(value);
  // @@protoc_insertion_point(field_set:AdminBanPlayerAckMessage.banPlayerId)
}

// required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
inline bool AdminBanPlayerAckMessage::_internal_has_banplayerresult() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdminBanPlayerAckMessage::has_banplayerresult() const {
  return _internal_has_banplayerresult();
}
inline void AdminBanPlayerAckMessage::clear_banplayerresult() {
  banplayerresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::_internal_banplayerresult() const {
  return static_cast< ::AdminBanPlayerAckMessage_AdminBanPlayerResult >(banplayerresult_);
}
inline ::AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banplayerresult() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerAckMessage.banPlayerResult)
  return _internal_banplayerresult();
}
inline void AdminBanPlayerAckMessage::_internal_set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value) {
  assert(::AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  banplayerresult_ = value;
}
inline void AdminBanPlayerAckMessage::set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value) {
  _internal_set_banplayerresult(value);
  // @@protoc_insertion_point(field_set:AdminBanPlayerAckMessage.banPlayerResult)
}

// -------------------------------------------------------------------

// PokerTHMessage

// required .PokerTHMessage.PokerTHMessageType messageType = 1;
inline bool PokerTHMessage::_internal_has_messagetype() const {
  bool value = (_has_bits_[2] & 0x00020000u) != 0;
  return value;
}
inline bool PokerTHMessage::has_messagetype() const {
  return _internal_has_messagetype();
}
inline void PokerTHMessage::clear_messagetype() {
  messagetype_ = 1;
  _has_bits_[2] &= ~0x00020000u;
}
inline ::PokerTHMessage_PokerTHMessageType PokerTHMessage::_internal_messagetype() const {
  return static_cast< ::PokerTHMessage_PokerTHMessageType >(messagetype_);
}
inline ::PokerTHMessage_PokerTHMessageType PokerTHMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.messageType)
  return _internal_messagetype();
}
inline void PokerTHMessage::_internal_set_messagetype(::PokerTHMessage_PokerTHMessageType value) {
  assert(::PokerTHMessage_PokerTHMessageType_IsValid(value));
  _has_bits_[2] |= 0x00020000u;
  messagetype_ = value;
}
inline void PokerTHMessage::set_messagetype(::PokerTHMessage_PokerTHMessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:PokerTHMessage.messageType)
}

// optional .AnnounceMessage announceMessage = 2;
inline bool PokerTHMessage::_internal_has_announcemessage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || announcemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_announcemessage() const {
  return _internal_has_announcemessage();
}
inline void PokerTHMessage::clear_announcemessage() {
  if (announcemessage_ != nullptr) announcemessage_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::AnnounceMessage& PokerTHMessage::_internal_announcemessage() const {
  const ::AnnounceMessage* p = announcemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AnnounceMessage&>(
      ::_AnnounceMessage_default_instance_);
}
inline const ::AnnounceMessage& PokerTHMessage::announcemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.announceMessage)
  return _internal_announcemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_announcemessage(
    ::AnnounceMessage* announcemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(announcemessage_);
  }
  announcemessage_ = announcemessage;
  if (announcemessage) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.announceMessage)
}
inline ::AnnounceMessage* PokerTHMessage::release_announcemessage() {
  _has_bits_[0] &= ~0x00000001u;
  ::AnnounceMessage* temp = announcemessage_;
  announcemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AnnounceMessage* PokerTHMessage::unsafe_arena_release_announcemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.announceMessage)
  _has_bits_[0] &= ~0x00000001u;
  ::AnnounceMessage* temp = announcemessage_;
  announcemessage_ = nullptr;
  return temp;
}
inline ::AnnounceMessage* PokerTHMessage::_internal_mutable_announcemessage() {
  _has_bits_[0] |= 0x00000001u;
  if (announcemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage>(GetArenaForAllocation());
    announcemessage_ = p;
  }
  return announcemessage_;
}
inline ::AnnounceMessage* PokerTHMessage::mutable_announcemessage() {
  ::AnnounceMessage* _msg = _internal_mutable_announcemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.announceMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_announcemessage(::AnnounceMessage* announcemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete announcemessage_;
  }
  if (announcemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AnnounceMessage>::GetOwningArena(announcemessage);
    if (message_arena != submessage_arena) {
      announcemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, announcemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  announcemessage_ = announcemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.announceMessage)
}

// optional .InitMessage initMessage = 3;
inline bool PokerTHMessage::_internal_has_initmessage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || initmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_initmessage() const {
  return _internal_has_initmessage();
}
inline void PokerTHMessage::clear_initmessage() {
  if (initmessage_ != nullptr) initmessage_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::InitMessage& PokerTHMessage::_internal_initmessage() const {
  const ::InitMessage* p = initmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::InitMessage&>(
      ::_InitMessage_default_instance_);
}
inline const ::InitMessage& PokerTHMessage::initmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.initMessage)
  return _internal_initmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_initmessage(
    ::InitMessage* initmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initmessage_);
  }
  initmessage_ = initmessage;
  if (initmessage) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.initMessage)
}
inline ::InitMessage* PokerTHMessage::release_initmessage() {
  _has_bits_[0] &= ~0x00000002u;
  ::InitMessage* temp = initmessage_;
  initmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::InitMessage* PokerTHMessage::unsafe_arena_release_initmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.initMessage)
  _has_bits_[0] &= ~0x00000002u;
  ::InitMessage* temp = initmessage_;
  initmessage_ = nullptr;
  return temp;
}
inline ::InitMessage* PokerTHMessage::_internal_mutable_initmessage() {
  _has_bits_[0] |= 0x00000002u;
  if (initmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InitMessage>(GetArenaForAllocation());
    initmessage_ = p;
  }
  return initmessage_;
}
inline ::InitMessage* PokerTHMessage::mutable_initmessage() {
  ::InitMessage* _msg = _internal_mutable_initmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.initMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_initmessage(::InitMessage* initmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete initmessage_;
  }
  if (initmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::InitMessage>::GetOwningArena(initmessage);
    if (message_arena != submessage_arena) {
      initmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  initmessage_ = initmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.initMessage)
}

// optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
inline bool PokerTHMessage::_internal_has_authserverchallengemessage() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || authserverchallengemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_authserverchallengemessage() const {
  return _internal_has_authserverchallengemessage();
}
inline void PokerTHMessage::clear_authserverchallengemessage() {
  if (authserverchallengemessage_ != nullptr) authserverchallengemessage_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::AuthServerChallengeMessage& PokerTHMessage::_internal_authserverchallengemessage() const {
  const ::AuthServerChallengeMessage* p = authserverchallengemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AuthServerChallengeMessage&>(
      ::_AuthServerChallengeMessage_default_instance_);
}
inline const ::AuthServerChallengeMessage& PokerTHMessage::authserverchallengemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.authServerChallengeMessage)
  return _internal_authserverchallengemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_authserverchallengemessage(
    ::AuthServerChallengeMessage* authserverchallengemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authserverchallengemessage_);
  }
  authserverchallengemessage_ = authserverchallengemessage;
  if (authserverchallengemessage) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.authServerChallengeMessage)
}
inline ::AuthServerChallengeMessage* PokerTHMessage::release_authserverchallengemessage() {
  _has_bits_[0] &= ~0x00000004u;
  ::AuthServerChallengeMessage* temp = authserverchallengemessage_;
  authserverchallengemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::unsafe_arena_release_authserverchallengemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.authServerChallengeMessage)
  _has_bits_[0] &= ~0x00000004u;
  ::AuthServerChallengeMessage* temp = authserverchallengemessage_;
  authserverchallengemessage_ = nullptr;
  return temp;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::_internal_mutable_authserverchallengemessage() {
  _has_bits_[0] |= 0x00000004u;
  if (authserverchallengemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AuthServerChallengeMessage>(GetArenaForAllocation());
    authserverchallengemessage_ = p;
  }
  return authserverchallengemessage_;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::mutable_authserverchallengemessage() {
  ::AuthServerChallengeMessage* _msg = _internal_mutable_authserverchallengemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authServerChallengeMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_authserverchallengemessage(::AuthServerChallengeMessage* authserverchallengemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authserverchallengemessage_;
  }
  if (authserverchallengemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AuthServerChallengeMessage>::GetOwningArena(authserverchallengemessage);
    if (message_arena != submessage_arena) {
      authserverchallengemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authserverchallengemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  authserverchallengemessage_ = authserverchallengemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authServerChallengeMessage)
}

// optional .AuthClientResponseMessage authClientResponseMessage = 5;
inline bool PokerTHMessage::_internal_has_authclientresponsemessage() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || authclientresponsemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_authclientresponsemessage() const {
  return _internal_has_authclientresponsemessage();
}
inline void PokerTHMessage::clear_authclientresponsemessage() {
  if (authclientresponsemessage_ != nullptr) authclientresponsemessage_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::AuthClientResponseMessage& PokerTHMessage::_internal_authclientresponsemessage() const {
  const ::AuthClientResponseMessage* p = authclientresponsemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AuthClientResponseMessage&>(
      ::_AuthClientResponseMessage_default_instance_);
}
inline const ::AuthClientResponseMessage& PokerTHMessage::authclientresponsemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.authClientResponseMessage)
  return _internal_authclientresponsemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_authclientresponsemessage(
    ::AuthClientResponseMessage* authclientresponsemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authclientresponsemessage_);
  }
  authclientresponsemessage_ = authclientresponsemessage;
  if (authclientresponsemessage) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.authClientResponseMessage)
}
inline ::AuthClientResponseMessage* PokerTHMessage::release_authclientresponsemessage() {
  _has_bits_[0] &= ~0x00000008u;
  ::AuthClientResponseMessage* temp = authclientresponsemessage_;
  authclientresponsemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AuthClientResponseMessage* PokerTHMessage::unsafe_arena_release_authclientresponsemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.authClientResponseMessage)
  _has_bits_[0] &= ~0x00000008u;
  ::AuthClientResponseMessage* temp = authclientresponsemessage_;
  authclientresponsemessage_ = nullptr;
  return temp;
}
inline ::AuthClientResponseMessage* PokerTHMessage::_internal_mutable_authclientresponsemessage() {
  _has_bits_[0] |= 0x00000008u;
  if (authclientresponsemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AuthClientResponseMessage>(GetArenaForAllocation());
    authclientresponsemessage_ = p;
  }
  return authclientresponsemessage_;
}
inline ::AuthClientResponseMessage* PokerTHMessage::mutable_authclientresponsemessage() {
  ::AuthClientResponseMessage* _msg = _internal_mutable_authclientresponsemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authClientResponseMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_authclientresponsemessage(::AuthClientResponseMessage* authclientresponsemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authclientresponsemessage_;
  }
  if (authclientresponsemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AuthClientResponseMessage>::GetOwningArena(authclientresponsemessage);
    if (message_arena != submessage_arena) {
      authclientresponsemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authclientresponsemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  authclientresponsemessage_ = authclientresponsemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authClientResponseMessage)
}

// optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
inline bool PokerTHMessage::_internal_has_authserververificationmessage() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || authserververificationmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_authserververificationmessage() const {
  return _internal_has_authserververificationmessage();
}
inline void PokerTHMessage::clear_authserververificationmessage() {
  if (authserververificationmessage_ != nullptr) authserververificationmessage_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::AuthServerVerificationMessage& PokerTHMessage::_internal_authserververificationmessage() const {
  const ::AuthServerVerificationMessage* p = authserververificationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AuthServerVerificationMessage&>(
      ::_AuthServerVerificationMessage_default_instance_);
}
inline const ::AuthServerVerificationMessage& PokerTHMessage::authserververificationmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.authServerVerificationMessage)
  return _internal_authserververificationmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_authserververificationmessage(
    ::AuthServerVerificationMessage* authserververificationmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authserververificationmessage_);
  }
  authserververificationmessage_ = authserververificationmessage;
  if (authserververificationmessage) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.authServerVerificationMessage)
}
inline ::AuthServerVerificationMessage* PokerTHMessage::release_authserververificationmessage() {
  _has_bits_[0] &= ~0x00000010u;
  ::AuthServerVerificationMessage* temp = authserververificationmessage_;
  authserververificationmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::unsafe_arena_release_authserververificationmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.authServerVerificationMessage)
  _has_bits_[0] &= ~0x00000010u;
  ::AuthServerVerificationMessage* temp = authserververificationmessage_;
  authserververificationmessage_ = nullptr;
  return temp;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::_internal_mutable_authserververificationmessage() {
  _has_bits_[0] |= 0x00000010u;
  if (authserververificationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AuthServerVerificationMessage>(GetArenaForAllocation());
    authserververificationmessage_ = p;
  }
  return authserververificationmessage_;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::mutable_authserververificationmessage() {
  ::AuthServerVerificationMessage* _msg = _internal_mutable_authserververificationmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authServerVerificationMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_authserververificationmessage(::AuthServerVerificationMessage* authserververificationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authserververificationmessage_;
  }
  if (authserververificationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AuthServerVerificationMessage>::GetOwningArena(authserververificationmessage);
    if (message_arena != submessage_arena) {
      authserververificationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authserververificationmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  authserververificationmessage_ = authserververificationmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authServerVerificationMessage)
}

// optional .InitAckMessage initAckMessage = 7;
inline bool PokerTHMessage::_internal_has_initackmessage() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || initackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_initackmessage() const {
  return _internal_has_initackmessage();
}
inline void PokerTHMessage::clear_initackmessage() {
  if (initackmessage_ != nullptr) initackmessage_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::InitAckMessage& PokerTHMessage::_internal_initackmessage() const {
  const ::InitAckMessage* p = initackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::InitAckMessage&>(
      ::_InitAckMessage_default_instance_);
}
inline const ::InitAckMessage& PokerTHMessage::initackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.initAckMessage)
  return _internal_initackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_initackmessage(
    ::InitAckMessage* initackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initackmessage_);
  }
  initackmessage_ = initackmessage;
  if (initackmessage) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.initAckMessage)
}
inline ::InitAckMessage* PokerTHMessage::release_initackmessage() {
  _has_bits_[0] &= ~0x00000020u;
  ::InitAckMessage* temp = initackmessage_;
  initackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::InitAckMessage* PokerTHMessage::unsafe_arena_release_initackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.initAckMessage)
  _has_bits_[0] &= ~0x00000020u;
  ::InitAckMessage* temp = initackmessage_;
  initackmessage_ = nullptr;
  return temp;
}
inline ::InitAckMessage* PokerTHMessage::_internal_mutable_initackmessage() {
  _has_bits_[0] |= 0x00000020u;
  if (initackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InitAckMessage>(GetArenaForAllocation());
    initackmessage_ = p;
  }
  return initackmessage_;
}
inline ::InitAckMessage* PokerTHMessage::mutable_initackmessage() {
  ::InitAckMessage* _msg = _internal_mutable_initackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.initAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_initackmessage(::InitAckMessage* initackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete initackmessage_;
  }
  if (initackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::InitAckMessage>::GetOwningArena(initackmessage);
    if (message_arena != submessage_arena) {
      initackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initackmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  initackmessage_ = initackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.initAckMessage)
}

// optional .AvatarRequestMessage avatarRequestMessage = 8;
inline bool PokerTHMessage::_internal_has_avatarrequestmessage() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || avatarrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_avatarrequestmessage() const {
  return _internal_has_avatarrequestmessage();
}
inline void PokerTHMessage::clear_avatarrequestmessage() {
  if (avatarrequestmessage_ != nullptr) avatarrequestmessage_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::AvatarRequestMessage& PokerTHMessage::_internal_avatarrequestmessage() const {
  const ::AvatarRequestMessage* p = avatarrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AvatarRequestMessage&>(
      ::_AvatarRequestMessage_default_instance_);
}
inline const ::AvatarRequestMessage& PokerTHMessage::avatarrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarRequestMessage)
  return _internal_avatarrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_avatarrequestmessage(
    ::AvatarRequestMessage* avatarrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(avatarrequestmessage_);
  }
  avatarrequestmessage_ = avatarrequestmessage;
  if (avatarrequestmessage) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.avatarRequestMessage)
}
inline ::AvatarRequestMessage* PokerTHMessage::release_avatarrequestmessage() {
  _has_bits_[0] &= ~0x00000040u;
  ::AvatarRequestMessage* temp = avatarrequestmessage_;
  avatarrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AvatarRequestMessage* PokerTHMessage::unsafe_arena_release_avatarrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarRequestMessage)
  _has_bits_[0] &= ~0x00000040u;
  ::AvatarRequestMessage* temp = avatarrequestmessage_;
  avatarrequestmessage_ = nullptr;
  return temp;
}
inline ::AvatarRequestMessage* PokerTHMessage::_internal_mutable_avatarrequestmessage() {
  _has_bits_[0] |= 0x00000040u;
  if (avatarrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarRequestMessage>(GetArenaForAllocation());
    avatarrequestmessage_ = p;
  }
  return avatarrequestmessage_;
}
inline ::AvatarRequestMessage* PokerTHMessage::mutable_avatarrequestmessage() {
  ::AvatarRequestMessage* _msg = _internal_mutable_avatarrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_avatarrequestmessage(::AvatarRequestMessage* avatarrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete avatarrequestmessage_;
  }
  if (avatarrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AvatarRequestMessage>::GetOwningArena(avatarrequestmessage);
    if (message_arena != submessage_arena) {
      avatarrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avatarrequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  avatarrequestmessage_ = avatarrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarRequestMessage)
}

// optional .AvatarHeaderMessage avatarHeaderMessage = 9;
inline bool PokerTHMessage::_internal_has_avatarheadermessage() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || avatarheadermessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_avatarheadermessage() const {
  return _internal_has_avatarheadermessage();
}
inline void PokerTHMessage::clear_avatarheadermessage() {
  if (avatarheadermessage_ != nullptr) avatarheadermessage_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::AvatarHeaderMessage& PokerTHMessage::_internal_avatarheadermessage() const {
  const ::AvatarHeaderMessage* p = avatarheadermessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AvatarHeaderMessage&>(
      ::_AvatarHeaderMessage_default_instance_);
}
inline const ::AvatarHeaderMessage& PokerTHMessage::avatarheadermessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarHeaderMessage)
  return _internal_avatarheadermessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_avatarheadermessage(
    ::AvatarHeaderMessage* avatarheadermessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(avatarheadermessage_);
  }
  avatarheadermessage_ = avatarheadermessage;
  if (avatarheadermessage) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.avatarHeaderMessage)
}
inline ::AvatarHeaderMessage* PokerTHMessage::release_avatarheadermessage() {
  _has_bits_[0] &= ~0x00000080u;
  ::AvatarHeaderMessage* temp = avatarheadermessage_;
  avatarheadermessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AvatarHeaderMessage* PokerTHMessage::unsafe_arena_release_avatarheadermessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarHeaderMessage)
  _has_bits_[0] &= ~0x00000080u;
  ::AvatarHeaderMessage* temp = avatarheadermessage_;
  avatarheadermessage_ = nullptr;
  return temp;
}
inline ::AvatarHeaderMessage* PokerTHMessage::_internal_mutable_avatarheadermessage() {
  _has_bits_[0] |= 0x00000080u;
  if (avatarheadermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarHeaderMessage>(GetArenaForAllocation());
    avatarheadermessage_ = p;
  }
  return avatarheadermessage_;
}
inline ::AvatarHeaderMessage* PokerTHMessage::mutable_avatarheadermessage() {
  ::AvatarHeaderMessage* _msg = _internal_mutable_avatarheadermessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarHeaderMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_avatarheadermessage(::AvatarHeaderMessage* avatarheadermessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete avatarheadermessage_;
  }
  if (avatarheadermessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AvatarHeaderMessage>::GetOwningArena(avatarheadermessage);
    if (message_arena != submessage_arena) {
      avatarheadermessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avatarheadermessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  avatarheadermessage_ = avatarheadermessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarHeaderMessage)
}

// optional .AvatarDataMessage avatarDataMessage = 10;
inline bool PokerTHMessage::_internal_has_avatardatamessage() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || avatardatamessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_avatardatamessage() const {
  return _internal_has_avatardatamessage();
}
inline void PokerTHMessage::clear_avatardatamessage() {
  if (avatardatamessage_ != nullptr) avatardatamessage_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::AvatarDataMessage& PokerTHMessage::_internal_avatardatamessage() const {
  const ::AvatarDataMessage* p = avatardatamessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AvatarDataMessage&>(
      ::_AvatarDataMessage_default_instance_);
}
inline const ::AvatarDataMessage& PokerTHMessage::avatardatamessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarDataMessage)
  return _internal_avatardatamessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_avatardatamessage(
    ::AvatarDataMessage* avatardatamessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(avatardatamessage_);
  }
  avatardatamessage_ = avatardatamessage;
  if (avatardatamessage) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.avatarDataMessage)
}
inline ::AvatarDataMessage* PokerTHMessage::release_avatardatamessage() {
  _has_bits_[0] &= ~0x00000100u;
  ::AvatarDataMessage* temp = avatardatamessage_;
  avatardatamessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AvatarDataMessage* PokerTHMessage::unsafe_arena_release_avatardatamessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarDataMessage)
  _has_bits_[0] &= ~0x00000100u;
  ::AvatarDataMessage* temp = avatardatamessage_;
  avatardatamessage_ = nullptr;
  return temp;
}
inline ::AvatarDataMessage* PokerTHMessage::_internal_mutable_avatardatamessage() {
  _has_bits_[0] |= 0x00000100u;
  if (avatardatamessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarDataMessage>(GetArenaForAllocation());
    avatardatamessage_ = p;
  }
  return avatardatamessage_;
}
inline ::AvatarDataMessage* PokerTHMessage::mutable_avatardatamessage() {
  ::AvatarDataMessage* _msg = _internal_mutable_avatardatamessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarDataMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_avatardatamessage(::AvatarDataMessage* avatardatamessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete avatardatamessage_;
  }
  if (avatardatamessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AvatarDataMessage>::GetOwningArena(avatardatamessage);
    if (message_arena != submessage_arena) {
      avatardatamessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avatardatamessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  avatardatamessage_ = avatardatamessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarDataMessage)
}

// optional .AvatarEndMessage avatarEndMessage = 11;
inline bool PokerTHMessage::_internal_has_avatarendmessage() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || avatarendmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_avatarendmessage() const {
  return _internal_has_avatarendmessage();
}
inline void PokerTHMessage::clear_avatarendmessage() {
  if (avatarendmessage_ != nullptr) avatarendmessage_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::AvatarEndMessage& PokerTHMessage::_internal_avatarendmessage() const {
  const ::AvatarEndMessage* p = avatarendmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AvatarEndMessage&>(
      ::_AvatarEndMessage_default_instance_);
}
inline const ::AvatarEndMessage& PokerTHMessage::avatarendmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarEndMessage)
  return _internal_avatarendmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_avatarendmessage(
    ::AvatarEndMessage* avatarendmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(avatarendmessage_);
  }
  avatarendmessage_ = avatarendmessage;
  if (avatarendmessage) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.avatarEndMessage)
}
inline ::AvatarEndMessage* PokerTHMessage::release_avatarendmessage() {
  _has_bits_[0] &= ~0x00000200u;
  ::AvatarEndMessage* temp = avatarendmessage_;
  avatarendmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AvatarEndMessage* PokerTHMessage::unsafe_arena_release_avatarendmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarEndMessage)
  _has_bits_[0] &= ~0x00000200u;
  ::AvatarEndMessage* temp = avatarendmessage_;
  avatarendmessage_ = nullptr;
  return temp;
}
inline ::AvatarEndMessage* PokerTHMessage::_internal_mutable_avatarendmessage() {
  _has_bits_[0] |= 0x00000200u;
  if (avatarendmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarEndMessage>(GetArenaForAllocation());
    avatarendmessage_ = p;
  }
  return avatarendmessage_;
}
inline ::AvatarEndMessage* PokerTHMessage::mutable_avatarendmessage() {
  ::AvatarEndMessage* _msg = _internal_mutable_avatarendmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarEndMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_avatarendmessage(::AvatarEndMessage* avatarendmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete avatarendmessage_;
  }
  if (avatarendmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AvatarEndMessage>::GetOwningArena(avatarendmessage);
    if (message_arena != submessage_arena) {
      avatarendmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avatarendmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  avatarendmessage_ = avatarendmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarEndMessage)
}

// optional .UnknownAvatarMessage unknownAvatarMessage = 12;
inline bool PokerTHMessage::_internal_has_unknownavatarmessage() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || unknownavatarmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_unknownavatarmessage() const {
  return _internal_has_unknownavatarmessage();
}
inline void PokerTHMessage::clear_unknownavatarmessage() {
  if (unknownavatarmessage_ != nullptr) unknownavatarmessage_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::UnknownAvatarMessage& PokerTHMessage::_internal_unknownavatarmessage() const {
  const ::UnknownAvatarMessage* p = unknownavatarmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::UnknownAvatarMessage&>(
      ::_UnknownAvatarMessage_default_instance_);
}
inline const ::UnknownAvatarMessage& PokerTHMessage::unknownavatarmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.unknownAvatarMessage)
  return _internal_unknownavatarmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_unknownavatarmessage(
    ::UnknownAvatarMessage* unknownavatarmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unknownavatarmessage_);
  }
  unknownavatarmessage_ = unknownavatarmessage;
  if (unknownavatarmessage) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.unknownAvatarMessage)
}
inline ::UnknownAvatarMessage* PokerTHMessage::release_unknownavatarmessage() {
  _has_bits_[0] &= ~0x00000400u;
  ::UnknownAvatarMessage* temp = unknownavatarmessage_;
  unknownavatarmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UnknownAvatarMessage* PokerTHMessage::unsafe_arena_release_unknownavatarmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.unknownAvatarMessage)
  _has_bits_[0] &= ~0x00000400u;
  ::UnknownAvatarMessage* temp = unknownavatarmessage_;
  unknownavatarmessage_ = nullptr;
  return temp;
}
inline ::UnknownAvatarMessage* PokerTHMessage::_internal_mutable_unknownavatarmessage() {
  _has_bits_[0] |= 0x00000400u;
  if (unknownavatarmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::UnknownAvatarMessage>(GetArenaForAllocation());
    unknownavatarmessage_ = p;
  }
  return unknownavatarmessage_;
}
inline ::UnknownAvatarMessage* PokerTHMessage::mutable_unknownavatarmessage() {
  ::UnknownAvatarMessage* _msg = _internal_mutable_unknownavatarmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.unknownAvatarMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_unknownavatarmessage(::UnknownAvatarMessage* unknownavatarmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unknownavatarmessage_;
  }
  if (unknownavatarmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::UnknownAvatarMessage>::GetOwningArena(unknownavatarmessage);
    if (message_arena != submessage_arena) {
      unknownavatarmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unknownavatarmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  unknownavatarmessage_ = unknownavatarmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.unknownAvatarMessage)
}

// optional .PlayerListMessage playerListMessage = 13;
inline bool PokerTHMessage::_internal_has_playerlistmessage() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || playerlistmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_playerlistmessage() const {
  return _internal_has_playerlistmessage();
}
inline void PokerTHMessage::clear_playerlistmessage() {
  if (playerlistmessage_ != nullptr) playerlistmessage_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::PlayerListMessage& PokerTHMessage::_internal_playerlistmessage() const {
  const ::PlayerListMessage* p = playerlistmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerListMessage&>(
      ::_PlayerListMessage_default_instance_);
}
inline const ::PlayerListMessage& PokerTHMessage::playerlistmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerListMessage)
  return _internal_playerlistmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_playerlistmessage(
    ::PlayerListMessage* playerlistmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerlistmessage_);
  }
  playerlistmessage_ = playerlistmessage;
  if (playerlistmessage) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.playerListMessage)
}
inline ::PlayerListMessage* PokerTHMessage::release_playerlistmessage() {
  _has_bits_[0] &= ~0x00000800u;
  ::PlayerListMessage* temp = playerlistmessage_;
  playerlistmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerListMessage* PokerTHMessage::unsafe_arena_release_playerlistmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerListMessage)
  _has_bits_[0] &= ~0x00000800u;
  ::PlayerListMessage* temp = playerlistmessage_;
  playerlistmessage_ = nullptr;
  return temp;
}
inline ::PlayerListMessage* PokerTHMessage::_internal_mutable_playerlistmessage() {
  _has_bits_[0] |= 0x00000800u;
  if (playerlistmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerListMessage>(GetArenaForAllocation());
    playerlistmessage_ = p;
  }
  return playerlistmessage_;
}
inline ::PlayerListMessage* PokerTHMessage::mutable_playerlistmessage() {
  ::PlayerListMessage* _msg = _internal_mutable_playerlistmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerListMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_playerlistmessage(::PlayerListMessage* playerlistmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerlistmessage_;
  }
  if (playerlistmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerListMessage>::GetOwningArena(playerlistmessage);
    if (message_arena != submessage_arena) {
      playerlistmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerlistmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  playerlistmessage_ = playerlistmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerListMessage)
}

// optional .GameListNewMessage gameListNewMessage = 14;
inline bool PokerTHMessage::_internal_has_gamelistnewmessage() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistnewmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistnewmessage() const {
  return _internal_has_gamelistnewmessage();
}
inline void PokerTHMessage::clear_gamelistnewmessage() {
  if (gamelistnewmessage_ != nullptr) gamelistnewmessage_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::GameListNewMessage& PokerTHMessage::_internal_gamelistnewmessage() const {
  const ::GameListNewMessage* p = gamelistnewmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListNewMessage&>(
      ::_GameListNewMessage_default_instance_);
}
inline const ::GameListNewMessage& PokerTHMessage::gamelistnewmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListNewMessage)
  return _internal_gamelistnewmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistnewmessage(
    ::GameListNewMessage* gamelistnewmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistnewmessage_);
  }
  gamelistnewmessage_ = gamelistnewmessage;
  if (gamelistnewmessage) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListNewMessage)
}
inline ::GameListNewMessage* PokerTHMessage::release_gamelistnewmessage() {
  _has_bits_[0] &= ~0x00001000u;
  ::GameListNewMessage* temp = gamelistnewmessage_;
  gamelistnewmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListNewMessage* PokerTHMessage::unsafe_arena_release_gamelistnewmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListNewMessage)
  _has_bits_[0] &= ~0x00001000u;
  ::GameListNewMessage* temp = gamelistnewmessage_;
  gamelistnewmessage_ = nullptr;
  return temp;
}
inline ::GameListNewMessage* PokerTHMessage::_internal_mutable_gamelistnewmessage() {
  _has_bits_[0] |= 0x00001000u;
  if (gamelistnewmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListNewMessage>(GetArenaForAllocation());
    gamelistnewmessage_ = p;
  }
  return gamelistnewmessage_;
}
inline ::GameListNewMessage* PokerTHMessage::mutable_gamelistnewmessage() {
  ::GameListNewMessage* _msg = _internal_mutable_gamelistnewmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListNewMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistnewmessage(::GameListNewMessage* gamelistnewmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistnewmessage_;
  }
  if (gamelistnewmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListNewMessage>::GetOwningArena(gamelistnewmessage);
    if (message_arena != submessage_arena) {
      gamelistnewmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistnewmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  gamelistnewmessage_ = gamelistnewmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListNewMessage)
}

// optional .GameListUpdateMessage gameListUpdateMessage = 15;
inline bool PokerTHMessage::_internal_has_gamelistupdatemessage() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistupdatemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistupdatemessage() const {
  return _internal_has_gamelistupdatemessage();
}
inline void PokerTHMessage::clear_gamelistupdatemessage() {
  if (gamelistupdatemessage_ != nullptr) gamelistupdatemessage_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::GameListUpdateMessage& PokerTHMessage::_internal_gamelistupdatemessage() const {
  const ::GameListUpdateMessage* p = gamelistupdatemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListUpdateMessage&>(
      ::_GameListUpdateMessage_default_instance_);
}
inline const ::GameListUpdateMessage& PokerTHMessage::gamelistupdatemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListUpdateMessage)
  return _internal_gamelistupdatemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistupdatemessage(
    ::GameListUpdateMessage* gamelistupdatemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistupdatemessage_);
  }
  gamelistupdatemessage_ = gamelistupdatemessage;
  if (gamelistupdatemessage) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListUpdateMessage)
}
inline ::GameListUpdateMessage* PokerTHMessage::release_gamelistupdatemessage() {
  _has_bits_[0] &= ~0x00002000u;
  ::GameListUpdateMessage* temp = gamelistupdatemessage_;
  gamelistupdatemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListUpdateMessage* PokerTHMessage::unsafe_arena_release_gamelistupdatemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListUpdateMessage)
  _has_bits_[0] &= ~0x00002000u;
  ::GameListUpdateMessage* temp = gamelistupdatemessage_;
  gamelistupdatemessage_ = nullptr;
  return temp;
}
inline ::GameListUpdateMessage* PokerTHMessage::_internal_mutable_gamelistupdatemessage() {
  _has_bits_[0] |= 0x00002000u;
  if (gamelistupdatemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListUpdateMessage>(GetArenaForAllocation());
    gamelistupdatemessage_ = p;
  }
  return gamelistupdatemessage_;
}
inline ::GameListUpdateMessage* PokerTHMessage::mutable_gamelistupdatemessage() {
  ::GameListUpdateMessage* _msg = _internal_mutable_gamelistupdatemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListUpdateMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistupdatemessage(::GameListUpdateMessage* gamelistupdatemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistupdatemessage_;
  }
  if (gamelistupdatemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListUpdateMessage>::GetOwningArena(gamelistupdatemessage);
    if (message_arena != submessage_arena) {
      gamelistupdatemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistupdatemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  gamelistupdatemessage_ = gamelistupdatemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListUpdateMessage)
}

// optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
inline bool PokerTHMessage::_internal_has_gamelistplayerjoinedmessage() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistplayerjoinedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistplayerjoinedmessage() const {
  return _internal_has_gamelistplayerjoinedmessage();
}
inline void PokerTHMessage::clear_gamelistplayerjoinedmessage() {
  if (gamelistplayerjoinedmessage_ != nullptr) gamelistplayerjoinedmessage_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::GameListPlayerJoinedMessage& PokerTHMessage::_internal_gamelistplayerjoinedmessage() const {
  const ::GameListPlayerJoinedMessage* p = gamelistplayerjoinedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListPlayerJoinedMessage&>(
      ::_GameListPlayerJoinedMessage_default_instance_);
}
inline const ::GameListPlayerJoinedMessage& PokerTHMessage::gamelistplayerjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListPlayerJoinedMessage)
  return _internal_gamelistplayerjoinedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistplayerjoinedmessage(
    ::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistplayerjoinedmessage_);
  }
  gamelistplayerjoinedmessage_ = gamelistplayerjoinedmessage;
  if (gamelistplayerjoinedmessage) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListPlayerJoinedMessage)
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::release_gamelistplayerjoinedmessage() {
  _has_bits_[0] &= ~0x00004000u;
  ::GameListPlayerJoinedMessage* temp = gamelistplayerjoinedmessage_;
  gamelistplayerjoinedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::unsafe_arena_release_gamelistplayerjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListPlayerJoinedMessage)
  _has_bits_[0] &= ~0x00004000u;
  ::GameListPlayerJoinedMessage* temp = gamelistplayerjoinedmessage_;
  gamelistplayerjoinedmessage_ = nullptr;
  return temp;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::_internal_mutable_gamelistplayerjoinedmessage() {
  _has_bits_[0] |= 0x00004000u;
  if (gamelistplayerjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListPlayerJoinedMessage>(GetArenaForAllocation());
    gamelistplayerjoinedmessage_ = p;
  }
  return gamelistplayerjoinedmessage_;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::mutable_gamelistplayerjoinedmessage() {
  ::GameListPlayerJoinedMessage* _msg = _internal_mutable_gamelistplayerjoinedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListPlayerJoinedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistplayerjoinedmessage(::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistplayerjoinedmessage_;
  }
  if (gamelistplayerjoinedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListPlayerJoinedMessage>::GetOwningArena(gamelistplayerjoinedmessage);
    if (message_arena != submessage_arena) {
      gamelistplayerjoinedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistplayerjoinedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  gamelistplayerjoinedmessage_ = gamelistplayerjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListPlayerJoinedMessage)
}

// optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
inline bool PokerTHMessage::_internal_has_gamelistplayerleftmessage() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistplayerleftmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistplayerleftmessage() const {
  return _internal_has_gamelistplayerleftmessage();
}
inline void PokerTHMessage::clear_gamelistplayerleftmessage() {
  if (gamelistplayerleftmessage_ != nullptr) gamelistplayerleftmessage_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::GameListPlayerLeftMessage& PokerTHMessage::_internal_gamelistplayerleftmessage() const {
  const ::GameListPlayerLeftMessage* p = gamelistplayerleftmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListPlayerLeftMessage&>(
      ::_GameListPlayerLeftMessage_default_instance_);
}
inline const ::GameListPlayerLeftMessage& PokerTHMessage::gamelistplayerleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListPlayerLeftMessage)
  return _internal_gamelistplayerleftmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistplayerleftmessage(
    ::GameListPlayerLeftMessage* gamelistplayerleftmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistplayerleftmessage_);
  }
  gamelistplayerleftmessage_ = gamelistplayerleftmessage;
  if (gamelistplayerleftmessage) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListPlayerLeftMessage)
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::release_gamelistplayerleftmessage() {
  _has_bits_[0] &= ~0x00008000u;
  ::GameListPlayerLeftMessage* temp = gamelistplayerleftmessage_;
  gamelistplayerleftmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::unsafe_arena_release_gamelistplayerleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListPlayerLeftMessage)
  _has_bits_[0] &= ~0x00008000u;
  ::GameListPlayerLeftMessage* temp = gamelistplayerleftmessage_;
  gamelistplayerleftmessage_ = nullptr;
  return temp;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::_internal_mutable_gamelistplayerleftmessage() {
  _has_bits_[0] |= 0x00008000u;
  if (gamelistplayerleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListPlayerLeftMessage>(GetArenaForAllocation());
    gamelistplayerleftmessage_ = p;
  }
  return gamelistplayerleftmessage_;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::mutable_gamelistplayerleftmessage() {
  ::GameListPlayerLeftMessage* _msg = _internal_mutable_gamelistplayerleftmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListPlayerLeftMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistplayerleftmessage(::GameListPlayerLeftMessage* gamelistplayerleftmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistplayerleftmessage_;
  }
  if (gamelistplayerleftmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListPlayerLeftMessage>::GetOwningArena(gamelistplayerleftmessage);
    if (message_arena != submessage_arena) {
      gamelistplayerleftmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistplayerleftmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  gamelistplayerleftmessage_ = gamelistplayerleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListPlayerLeftMessage)
}

// optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
inline bool PokerTHMessage::_internal_has_gamelistadminchangedmessage() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistadminchangedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistadminchangedmessage() const {
  return _internal_has_gamelistadminchangedmessage();
}
inline void PokerTHMessage::clear_gamelistadminchangedmessage() {
  if (gamelistadminchangedmessage_ != nullptr) gamelistadminchangedmessage_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::GameListAdminChangedMessage& PokerTHMessage::_internal_gamelistadminchangedmessage() const {
  const ::GameListAdminChangedMessage* p = gamelistadminchangedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListAdminChangedMessage&>(
      ::_GameListAdminChangedMessage_default_instance_);
}
inline const ::GameListAdminChangedMessage& PokerTHMessage::gamelistadminchangedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListAdminChangedMessage)
  return _internal_gamelistadminchangedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistadminchangedmessage(
    ::GameListAdminChangedMessage* gamelistadminchangedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistadminchangedmessage_);
  }
  gamelistadminchangedmessage_ = gamelistadminchangedmessage;
  if (gamelistadminchangedmessage) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListAdminChangedMessage)
}
inline ::GameListAdminChangedMessage* PokerTHMessage::release_gamelistadminchangedmessage() {
  _has_bits_[0] &= ~0x00010000u;
  ::GameListAdminChangedMessage* temp = gamelistadminchangedmessage_;
  gamelistadminchangedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::unsafe_arena_release_gamelistadminchangedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListAdminChangedMessage)
  _has_bits_[0] &= ~0x00010000u;
  ::GameListAdminChangedMessage* temp = gamelistadminchangedmessage_;
  gamelistadminchangedmessage_ = nullptr;
  return temp;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::_internal_mutable_gamelistadminchangedmessage() {
  _has_bits_[0] |= 0x00010000u;
  if (gamelistadminchangedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListAdminChangedMessage>(GetArenaForAllocation());
    gamelistadminchangedmessage_ = p;
  }
  return gamelistadminchangedmessage_;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::mutable_gamelistadminchangedmessage() {
  ::GameListAdminChangedMessage* _msg = _internal_mutable_gamelistadminchangedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListAdminChangedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistadminchangedmessage(::GameListAdminChangedMessage* gamelistadminchangedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistadminchangedmessage_;
  }
  if (gamelistadminchangedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListAdminChangedMessage>::GetOwningArena(gamelistadminchangedmessage);
    if (message_arena != submessage_arena) {
      gamelistadminchangedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistadminchangedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  gamelistadminchangedmessage_ = gamelistadminchangedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListAdminChangedMessage)
}

// optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
inline bool PokerTHMessage::_internal_has_playerinforequestmessage() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || playerinforequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_playerinforequestmessage() const {
  return _internal_has_playerinforequestmessage();
}
inline void PokerTHMessage::clear_playerinforequestmessage() {
  if (playerinforequestmessage_ != nullptr) playerinforequestmessage_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::PlayerInfoRequestMessage& PokerTHMessage::_internal_playerinforequestmessage() const {
  const ::PlayerInfoRequestMessage* p = playerinforequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoRequestMessage&>(
      ::_PlayerInfoRequestMessage_default_instance_);
}
inline const ::PlayerInfoRequestMessage& PokerTHMessage::playerinforequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerInfoRequestMessage)
  return _internal_playerinforequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_playerinforequestmessage(
    ::PlayerInfoRequestMessage* playerinforequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinforequestmessage_);
  }
  playerinforequestmessage_ = playerinforequestmessage;
  if (playerinforequestmessage) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.playerInfoRequestMessage)
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::release_playerinforequestmessage() {
  _has_bits_[0] &= ~0x00020000u;
  ::PlayerInfoRequestMessage* temp = playerinforequestmessage_;
  playerinforequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::unsafe_arena_release_playerinforequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerInfoRequestMessage)
  _has_bits_[0] &= ~0x00020000u;
  ::PlayerInfoRequestMessage* temp = playerinforequestmessage_;
  playerinforequestmessage_ = nullptr;
  return temp;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::_internal_mutable_playerinforequestmessage() {
  _has_bits_[0] |= 0x00020000u;
  if (playerinforequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoRequestMessage>(GetArenaForAllocation());
    playerinforequestmessage_ = p;
  }
  return playerinforequestmessage_;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::mutable_playerinforequestmessage() {
  ::PlayerInfoRequestMessage* _msg = _internal_mutable_playerinforequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerInfoRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_playerinforequestmessage(::PlayerInfoRequestMessage* playerinforequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerinforequestmessage_;
  }
  if (playerinforequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerInfoRequestMessage>::GetOwningArena(playerinforequestmessage);
    if (message_arena != submessage_arena) {
      playerinforequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinforequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  playerinforequestmessage_ = playerinforequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerInfoRequestMessage)
}

// optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
inline bool PokerTHMessage::_internal_has_playerinforeplymessage() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || playerinforeplymessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_playerinforeplymessage() const {
  return _internal_has_playerinforeplymessage();
}
inline void PokerTHMessage::clear_playerinforeplymessage() {
  if (playerinforeplymessage_ != nullptr) playerinforeplymessage_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::PlayerInfoReplyMessage& PokerTHMessage::_internal_playerinforeplymessage() const {
  const ::PlayerInfoReplyMessage* p = playerinforeplymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoReplyMessage&>(
      ::_PlayerInfoReplyMessage_default_instance_);
}
inline const ::PlayerInfoReplyMessage& PokerTHMessage::playerinforeplymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerInfoReplyMessage)
  return _internal_playerinforeplymessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_playerinforeplymessage(
    ::PlayerInfoReplyMessage* playerinforeplymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinforeplymessage_);
  }
  playerinforeplymessage_ = playerinforeplymessage;
  if (playerinforeplymessage) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.playerInfoReplyMessage)
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::release_playerinforeplymessage() {
  _has_bits_[0] &= ~0x00040000u;
  ::PlayerInfoReplyMessage* temp = playerinforeplymessage_;
  playerinforeplymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::unsafe_arena_release_playerinforeplymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerInfoReplyMessage)
  _has_bits_[0] &= ~0x00040000u;
  ::PlayerInfoReplyMessage* temp = playerinforeplymessage_;
  playerinforeplymessage_ = nullptr;
  return temp;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::_internal_mutable_playerinforeplymessage() {
  _has_bits_[0] |= 0x00040000u;
  if (playerinforeplymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoReplyMessage>(GetArenaForAllocation());
    playerinforeplymessage_ = p;
  }
  return playerinforeplymessage_;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::mutable_playerinforeplymessage() {
  ::PlayerInfoReplyMessage* _msg = _internal_mutable_playerinforeplymessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerInfoReplyMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_playerinforeplymessage(::PlayerInfoReplyMessage* playerinforeplymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerinforeplymessage_;
  }
  if (playerinforeplymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerInfoReplyMessage>::GetOwningArena(playerinforeplymessage);
    if (message_arena != submessage_arena) {
      playerinforeplymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinforeplymessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  playerinforeplymessage_ = playerinforeplymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerInfoReplyMessage)
}

// optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
inline bool PokerTHMessage::_internal_has_subscriptionrequestmessage() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || subscriptionrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_subscriptionrequestmessage() const {
  return _internal_has_subscriptionrequestmessage();
}
inline void PokerTHMessage::clear_subscriptionrequestmessage() {
  if (subscriptionrequestmessage_ != nullptr) subscriptionrequestmessage_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::SubscriptionRequestMessage& PokerTHMessage::_internal_subscriptionrequestmessage() const {
  const ::SubscriptionRequestMessage* p = subscriptionrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::SubscriptionRequestMessage&>(
      ::_SubscriptionRequestMessage_default_instance_);
}
inline const ::SubscriptionRequestMessage& PokerTHMessage::subscriptionrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.subscriptionRequestMessage)
  return _internal_subscriptionrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_subscriptionrequestmessage(
    ::SubscriptionRequestMessage* subscriptionrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscriptionrequestmessage_);
  }
  subscriptionrequestmessage_ = subscriptionrequestmessage;
  if (subscriptionrequestmessage) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.subscriptionRequestMessage)
}
inline ::SubscriptionRequestMessage* PokerTHMessage::release_subscriptionrequestmessage() {
  _has_bits_[0] &= ~0x00080000u;
  ::SubscriptionRequestMessage* temp = subscriptionrequestmessage_;
  subscriptionrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::unsafe_arena_release_subscriptionrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.subscriptionRequestMessage)
  _has_bits_[0] &= ~0x00080000u;
  ::SubscriptionRequestMessage* temp = subscriptionrequestmessage_;
  subscriptionrequestmessage_ = nullptr;
  return temp;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::_internal_mutable_subscriptionrequestmessage() {
  _has_bits_[0] |= 0x00080000u;
  if (subscriptionrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SubscriptionRequestMessage>(GetArenaForAllocation());
    subscriptionrequestmessage_ = p;
  }
  return subscriptionrequestmessage_;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::mutable_subscriptionrequestmessage() {
  ::SubscriptionRequestMessage* _msg = _internal_mutable_subscriptionrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.subscriptionRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_subscriptionrequestmessage(::SubscriptionRequestMessage* subscriptionrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscriptionrequestmessage_;
  }
  if (subscriptionrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SubscriptionRequestMessage>::GetOwningArena(subscriptionrequestmessage);
    if (message_arena != submessage_arena) {
      subscriptionrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriptionrequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  subscriptionrequestmessage_ = subscriptionrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.subscriptionRequestMessage)
}

// optional .JoinExistingGameMessage joinExistingGameMessage = 22;
inline bool PokerTHMessage::_internal_has_joinexistinggamemessage() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || joinexistinggamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_joinexistinggamemessage() const {
  return _internal_has_joinexistinggamemessage();
}
inline void PokerTHMessage::clear_joinexistinggamemessage() {
  if (joinexistinggamemessage_ != nullptr) joinexistinggamemessage_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::JoinExistingGameMessage& PokerTHMessage::_internal_joinexistinggamemessage() const {
  const ::JoinExistingGameMessage* p = joinexistinggamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::JoinExistingGameMessage&>(
      ::_JoinExistingGameMessage_default_instance_);
}
inline const ::JoinExistingGameMessage& PokerTHMessage::joinexistinggamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinExistingGameMessage)
  return _internal_joinexistinggamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_joinexistinggamemessage(
    ::JoinExistingGameMessage* joinexistinggamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joinexistinggamemessage_);
  }
  joinexistinggamemessage_ = joinexistinggamemessage;
  if (joinexistinggamemessage) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.joinExistingGameMessage)
}
inline ::JoinExistingGameMessage* PokerTHMessage::release_joinexistinggamemessage() {
  _has_bits_[0] &= ~0x00100000u;
  ::JoinExistingGameMessage* temp = joinexistinggamemessage_;
  joinexistinggamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JoinExistingGameMessage* PokerTHMessage::unsafe_arena_release_joinexistinggamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinExistingGameMessage)
  _has_bits_[0] &= ~0x00100000u;
  ::JoinExistingGameMessage* temp = joinexistinggamemessage_;
  joinexistinggamemessage_ = nullptr;
  return temp;
}
inline ::JoinExistingGameMessage* PokerTHMessage::_internal_mutable_joinexistinggamemessage() {
  _has_bits_[0] |= 0x00100000u;
  if (joinexistinggamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinExistingGameMessage>(GetArenaForAllocation());
    joinexistinggamemessage_ = p;
  }
  return joinexistinggamemessage_;
}
inline ::JoinExistingGameMessage* PokerTHMessage::mutable_joinexistinggamemessage() {
  ::JoinExistingGameMessage* _msg = _internal_mutable_joinexistinggamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinExistingGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_joinexistinggamemessage(::JoinExistingGameMessage* joinexistinggamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete joinexistinggamemessage_;
  }
  if (joinexistinggamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::JoinExistingGameMessage>::GetOwningArena(joinexistinggamemessage);
    if (message_arena != submessage_arena) {
      joinexistinggamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joinexistinggamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  joinexistinggamemessage_ = joinexistinggamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinExistingGameMessage)
}

// optional .JoinNewGameMessage joinNewGameMessage = 23;
inline bool PokerTHMessage::_internal_has_joinnewgamemessage() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || joinnewgamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_joinnewgamemessage() const {
  return _internal_has_joinnewgamemessage();
}
inline void PokerTHMessage::clear_joinnewgamemessage() {
  if (joinnewgamemessage_ != nullptr) joinnewgamemessage_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::JoinNewGameMessage& PokerTHMessage::_internal_joinnewgamemessage() const {
  const ::JoinNewGameMessage* p = joinnewgamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::JoinNewGameMessage&>(
      ::_JoinNewGameMessage_default_instance_);
}
inline const ::JoinNewGameMessage& PokerTHMessage::joinnewgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinNewGameMessage)
  return _internal_joinnewgamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_joinnewgamemessage(
    ::JoinNewGameMessage* joinnewgamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joinnewgamemessage_);
  }
  joinnewgamemessage_ = joinnewgamemessage;
  if (joinnewgamemessage) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.joinNewGameMessage)
}
inline ::JoinNewGameMessage* PokerTHMessage::release_joinnewgamemessage() {
  _has_bits_[0] &= ~0x00200000u;
  ::JoinNewGameMessage* temp = joinnewgamemessage_;
  joinnewgamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JoinNewGameMessage* PokerTHMessage::unsafe_arena_release_joinnewgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinNewGameMessage)
  _has_bits_[0] &= ~0x00200000u;
  ::JoinNewGameMessage* temp = joinnewgamemessage_;
  joinnewgamemessage_ = nullptr;
  return temp;
}
inline ::JoinNewGameMessage* PokerTHMessage::_internal_mutable_joinnewgamemessage() {
  _has_bits_[0] |= 0x00200000u;
  if (joinnewgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinNewGameMessage>(GetArenaForAllocation());
    joinnewgamemessage_ = p;
  }
  return joinnewgamemessage_;
}
inline ::JoinNewGameMessage* PokerTHMessage::mutable_joinnewgamemessage() {
  ::JoinNewGameMessage* _msg = _internal_mutable_joinnewgamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinNewGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_joinnewgamemessage(::JoinNewGameMessage* joinnewgamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete joinnewgamemessage_;
  }
  if (joinnewgamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::JoinNewGameMessage>::GetOwningArena(joinnewgamemessage);
    if (message_arena != submessage_arena) {
      joinnewgamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joinnewgamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  joinnewgamemessage_ = joinnewgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinNewGameMessage)
}

// optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
inline bool PokerTHMessage::_internal_has_rejoinexistinggamemessage() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || rejoinexistinggamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_rejoinexistinggamemessage() const {
  return _internal_has_rejoinexistinggamemessage();
}
inline void PokerTHMessage::clear_rejoinexistinggamemessage() {
  if (rejoinexistinggamemessage_ != nullptr) rejoinexistinggamemessage_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::RejoinExistingGameMessage& PokerTHMessage::_internal_rejoinexistinggamemessage() const {
  const ::RejoinExistingGameMessage* p = rejoinexistinggamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::RejoinExistingGameMessage&>(
      ::_RejoinExistingGameMessage_default_instance_);
}
inline const ::RejoinExistingGameMessage& PokerTHMessage::rejoinexistinggamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejoinExistingGameMessage)
  return _internal_rejoinexistinggamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_rejoinexistinggamemessage(
    ::RejoinExistingGameMessage* rejoinexistinggamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rejoinexistinggamemessage_);
  }
  rejoinexistinggamemessage_ = rejoinexistinggamemessage;
  if (rejoinexistinggamemessage) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.rejoinExistingGameMessage)
}
inline ::RejoinExistingGameMessage* PokerTHMessage::release_rejoinexistinggamemessage() {
  _has_bits_[0] &= ~0x00400000u;
  ::RejoinExistingGameMessage* temp = rejoinexistinggamemessage_;
  rejoinexistinggamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::unsafe_arena_release_rejoinexistinggamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.rejoinExistingGameMessage)
  _has_bits_[0] &= ~0x00400000u;
  ::RejoinExistingGameMessage* temp = rejoinexistinggamemessage_;
  rejoinexistinggamemessage_ = nullptr;
  return temp;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::_internal_mutable_rejoinexistinggamemessage() {
  _has_bits_[0] |= 0x00400000u;
  if (rejoinexistinggamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RejoinExistingGameMessage>(GetArenaForAllocation());
    rejoinexistinggamemessage_ = p;
  }
  return rejoinexistinggamemessage_;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::mutable_rejoinexistinggamemessage() {
  ::RejoinExistingGameMessage* _msg = _internal_mutable_rejoinexistinggamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejoinExistingGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_rejoinexistinggamemessage(::RejoinExistingGameMessage* rejoinexistinggamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rejoinexistinggamemessage_;
  }
  if (rejoinexistinggamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RejoinExistingGameMessage>::GetOwningArena(rejoinexistinggamemessage);
    if (message_arena != submessage_arena) {
      rejoinexistinggamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rejoinexistinggamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  rejoinexistinggamemessage_ = rejoinexistinggamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejoinExistingGameMessage)
}

// optional .JoinGameAckMessage joinGameAckMessage = 25;
inline bool PokerTHMessage::_internal_has_joingameackmessage() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || joingameackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_joingameackmessage() const {
  return _internal_has_joingameackmessage();
}
inline void PokerTHMessage::clear_joingameackmessage() {
  if (joingameackmessage_ != nullptr) joingameackmessage_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::JoinGameAckMessage& PokerTHMessage::_internal_joingameackmessage() const {
  const ::JoinGameAckMessage* p = joingameackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::JoinGameAckMessage&>(
      ::_JoinGameAckMessage_default_instance_);
}
inline const ::JoinGameAckMessage& PokerTHMessage::joingameackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinGameAckMessage)
  return _internal_joingameackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_joingameackmessage(
    ::JoinGameAckMessage* joingameackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joingameackmessage_);
  }
  joingameackmessage_ = joingameackmessage;
  if (joingameackmessage) {
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.joinGameAckMessage)
}
inline ::JoinGameAckMessage* PokerTHMessage::release_joingameackmessage() {
  _has_bits_[0] &= ~0x00800000u;
  ::JoinGameAckMessage* temp = joingameackmessage_;
  joingameackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JoinGameAckMessage* PokerTHMessage::unsafe_arena_release_joingameackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinGameAckMessage)
  _has_bits_[0] &= ~0x00800000u;
  ::JoinGameAckMessage* temp = joingameackmessage_;
  joingameackmessage_ = nullptr;
  return temp;
}
inline ::JoinGameAckMessage* PokerTHMessage::_internal_mutable_joingameackmessage() {
  _has_bits_[0] |= 0x00800000u;
  if (joingameackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinGameAckMessage>(GetArenaForAllocation());
    joingameackmessage_ = p;
  }
  return joingameackmessage_;
}
inline ::JoinGameAckMessage* PokerTHMessage::mutable_joingameackmessage() {
  ::JoinGameAckMessage* _msg = _internal_mutable_joingameackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinGameAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_joingameackmessage(::JoinGameAckMessage* joingameackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete joingameackmessage_;
  }
  if (joingameackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::JoinGameAckMessage>::GetOwningArena(joingameackmessage);
    if (message_arena != submessage_arena) {
      joingameackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joingameackmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  joingameackmessage_ = joingameackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinGameAckMessage)
}

// optional .JoinGameFailedMessage joinGameFailedMessage = 26;
inline bool PokerTHMessage::_internal_has_joingamefailedmessage() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || joingamefailedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_joingamefailedmessage() const {
  return _internal_has_joingamefailedmessage();
}
inline void PokerTHMessage::clear_joingamefailedmessage() {
  if (joingamefailedmessage_ != nullptr) joingamefailedmessage_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::JoinGameFailedMessage& PokerTHMessage::_internal_joingamefailedmessage() const {
  const ::JoinGameFailedMessage* p = joingamefailedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::JoinGameFailedMessage&>(
      ::_JoinGameFailedMessage_default_instance_);
}
inline const ::JoinGameFailedMessage& PokerTHMessage::joingamefailedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinGameFailedMessage)
  return _internal_joingamefailedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_joingamefailedmessage(
    ::JoinGameFailedMessage* joingamefailedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joingamefailedmessage_);
  }
  joingamefailedmessage_ = joingamefailedmessage;
  if (joingamefailedmessage) {
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.joinGameFailedMessage)
}
inline ::JoinGameFailedMessage* PokerTHMessage::release_joingamefailedmessage() {
  _has_bits_[0] &= ~0x01000000u;
  ::JoinGameFailedMessage* temp = joingamefailedmessage_;
  joingamefailedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JoinGameFailedMessage* PokerTHMessage::unsafe_arena_release_joingamefailedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinGameFailedMessage)
  _has_bits_[0] &= ~0x01000000u;
  ::JoinGameFailedMessage* temp = joingamefailedmessage_;
  joingamefailedmessage_ = nullptr;
  return temp;
}
inline ::JoinGameFailedMessage* PokerTHMessage::_internal_mutable_joingamefailedmessage() {
  _has_bits_[0] |= 0x01000000u;
  if (joingamefailedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinGameFailedMessage>(GetArenaForAllocation());
    joingamefailedmessage_ = p;
  }
  return joingamefailedmessage_;
}
inline ::JoinGameFailedMessage* PokerTHMessage::mutable_joingamefailedmessage() {
  ::JoinGameFailedMessage* _msg = _internal_mutable_joingamefailedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinGameFailedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_joingamefailedmessage(::JoinGameFailedMessage* joingamefailedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete joingamefailedmessage_;
  }
  if (joingamefailedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::JoinGameFailedMessage>::GetOwningArena(joingamefailedmessage);
    if (message_arena != submessage_arena) {
      joingamefailedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joingamefailedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  joingamefailedmessage_ = joingamefailedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinGameFailedMessage)
}

// optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
inline bool PokerTHMessage::_internal_has_gameplayerjoinedmessage() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || gameplayerjoinedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gameplayerjoinedmessage() const {
  return _internal_has_gameplayerjoinedmessage();
}
inline void PokerTHMessage::clear_gameplayerjoinedmessage() {
  if (gameplayerjoinedmessage_ != nullptr) gameplayerjoinedmessage_->Clear();
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::GamePlayerJoinedMessage& PokerTHMessage::_internal_gameplayerjoinedmessage() const {
  const ::GamePlayerJoinedMessage* p = gameplayerjoinedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GamePlayerJoinedMessage&>(
      ::_GamePlayerJoinedMessage_default_instance_);
}
inline const ::GamePlayerJoinedMessage& PokerTHMessage::gameplayerjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gamePlayerJoinedMessage)
  return _internal_gameplayerjoinedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gameplayerjoinedmessage(
    ::GamePlayerJoinedMessage* gameplayerjoinedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameplayerjoinedmessage_);
  }
  gameplayerjoinedmessage_ = gameplayerjoinedmessage;
  if (gameplayerjoinedmessage) {
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gamePlayerJoinedMessage)
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::release_gameplayerjoinedmessage() {
  _has_bits_[0] &= ~0x02000000u;
  ::GamePlayerJoinedMessage* temp = gameplayerjoinedmessage_;
  gameplayerjoinedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::unsafe_arena_release_gameplayerjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gamePlayerJoinedMessage)
  _has_bits_[0] &= ~0x02000000u;
  ::GamePlayerJoinedMessage* temp = gameplayerjoinedmessage_;
  gameplayerjoinedmessage_ = nullptr;
  return temp;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::_internal_mutable_gameplayerjoinedmessage() {
  _has_bits_[0] |= 0x02000000u;
  if (gameplayerjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GamePlayerJoinedMessage>(GetArenaForAllocation());
    gameplayerjoinedmessage_ = p;
  }
  return gameplayerjoinedmessage_;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::mutable_gameplayerjoinedmessage() {
  ::GamePlayerJoinedMessage* _msg = _internal_mutable_gameplayerjoinedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gamePlayerJoinedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gameplayerjoinedmessage(::GamePlayerJoinedMessage* gameplayerjoinedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameplayerjoinedmessage_;
  }
  if (gameplayerjoinedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GamePlayerJoinedMessage>::GetOwningArena(gameplayerjoinedmessage);
    if (message_arena != submessage_arena) {
      gameplayerjoinedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameplayerjoinedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  gameplayerjoinedmessage_ = gameplayerjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gamePlayerJoinedMessage)
}

// optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
inline bool PokerTHMessage::_internal_has_gameplayerleftmessage() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || gameplayerleftmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gameplayerleftmessage() const {
  return _internal_has_gameplayerleftmessage();
}
inline void PokerTHMessage::clear_gameplayerleftmessage() {
  if (gameplayerleftmessage_ != nullptr) gameplayerleftmessage_->Clear();
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::GamePlayerLeftMessage& PokerTHMessage::_internal_gameplayerleftmessage() const {
  const ::GamePlayerLeftMessage* p = gameplayerleftmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GamePlayerLeftMessage&>(
      ::_GamePlayerLeftMessage_default_instance_);
}
inline const ::GamePlayerLeftMessage& PokerTHMessage::gameplayerleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gamePlayerLeftMessage)
  return _internal_gameplayerleftmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gameplayerleftmessage(
    ::GamePlayerLeftMessage* gameplayerleftmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameplayerleftmessage_);
  }
  gameplayerleftmessage_ = gameplayerleftmessage;
  if (gameplayerleftmessage) {
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gamePlayerLeftMessage)
}
inline ::GamePlayerLeftMessage* PokerTHMessage::release_gameplayerleftmessage() {
  _has_bits_[0] &= ~0x04000000u;
  ::GamePlayerLeftMessage* temp = gameplayerleftmessage_;
  gameplayerleftmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::unsafe_arena_release_gameplayerleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gamePlayerLeftMessage)
  _has_bits_[0] &= ~0x04000000u;
  ::GamePlayerLeftMessage* temp = gameplayerleftmessage_;
  gameplayerleftmessage_ = nullptr;
  return temp;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::_internal_mutable_gameplayerleftmessage() {
  _has_bits_[0] |= 0x04000000u;
  if (gameplayerleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GamePlayerLeftMessage>(GetArenaForAllocation());
    gameplayerleftmessage_ = p;
  }
  return gameplayerleftmessage_;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::mutable_gameplayerleftmessage() {
  ::GamePlayerLeftMessage* _msg = _internal_mutable_gameplayerleftmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gamePlayerLeftMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gameplayerleftmessage(::GamePlayerLeftMessage* gameplayerleftmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameplayerleftmessage_;
  }
  if (gameplayerleftmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GamePlayerLeftMessage>::GetOwningArena(gameplayerleftmessage);
    if (message_arena != submessage_arena) {
      gameplayerleftmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameplayerleftmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  gameplayerleftmessage_ = gameplayerleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gamePlayerLeftMessage)
}

// optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
inline bool PokerTHMessage::_internal_has_gameadminchangedmessage() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || gameadminchangedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gameadminchangedmessage() const {
  return _internal_has_gameadminchangedmessage();
}
inline void PokerTHMessage::clear_gameadminchangedmessage() {
  if (gameadminchangedmessage_ != nullptr) gameadminchangedmessage_->Clear();
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::GameAdminChangedMessage& PokerTHMessage::_internal_gameadminchangedmessage() const {
  const ::GameAdminChangedMessage* p = gameadminchangedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameAdminChangedMessage&>(
      ::_GameAdminChangedMessage_default_instance_);
}
inline const ::GameAdminChangedMessage& PokerTHMessage::gameadminchangedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameAdminChangedMessage)
  return _internal_gameadminchangedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gameadminchangedmessage(
    ::GameAdminChangedMessage* gameadminchangedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameadminchangedmessage_);
  }
  gameadminchangedmessage_ = gameadminchangedmessage;
  if (gameadminchangedmessage) {
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameAdminChangedMessage)
}
inline ::GameAdminChangedMessage* PokerTHMessage::release_gameadminchangedmessage() {
  _has_bits_[0] &= ~0x08000000u;
  ::GameAdminChangedMessage* temp = gameadminchangedmessage_;
  gameadminchangedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameAdminChangedMessage* PokerTHMessage::unsafe_arena_release_gameadminchangedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameAdminChangedMessage)
  _has_bits_[0] &= ~0x08000000u;
  ::GameAdminChangedMessage* temp = gameadminchangedmessage_;
  gameadminchangedmessage_ = nullptr;
  return temp;
}
inline ::GameAdminChangedMessage* PokerTHMessage::_internal_mutable_gameadminchangedmessage() {
  _has_bits_[0] |= 0x08000000u;
  if (gameadminchangedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameAdminChangedMessage>(GetArenaForAllocation());
    gameadminchangedmessage_ = p;
  }
  return gameadminchangedmessage_;
}
inline ::GameAdminChangedMessage* PokerTHMessage::mutable_gameadminchangedmessage() {
  ::GameAdminChangedMessage* _msg = _internal_mutable_gameadminchangedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameAdminChangedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gameadminchangedmessage(::GameAdminChangedMessage* gameadminchangedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameadminchangedmessage_;
  }
  if (gameadminchangedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameAdminChangedMessage>::GetOwningArena(gameadminchangedmessage);
    if (message_arena != submessage_arena) {
      gameadminchangedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameadminchangedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  gameadminchangedmessage_ = gameadminchangedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameAdminChangedMessage)
}

// optional .RemovedFromGameMessage removedFromGameMessage = 30;
inline bool PokerTHMessage::_internal_has_removedfromgamemessage() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || removedfromgamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_removedfromgamemessage() const {
  return _internal_has_removedfromgamemessage();
}
inline void PokerTHMessage::clear_removedfromgamemessage() {
  if (removedfromgamemessage_ != nullptr) removedfromgamemessage_->Clear();
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::RemovedFromGameMessage& PokerTHMessage::_internal_removedfromgamemessage() const {
  const ::RemovedFromGameMessage* p = removedfromgamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::RemovedFromGameMessage&>(
      ::_RemovedFromGameMessage_default_instance_);
}
inline const ::RemovedFromGameMessage& PokerTHMessage::removedfromgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.removedFromGameMessage)
  return _internal_removedfromgamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_removedfromgamemessage(
    ::RemovedFromGameMessage* removedfromgamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(removedfromgamemessage_);
  }
  removedfromgamemessage_ = removedfromgamemessage;
  if (removedfromgamemessage) {
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.removedFromGameMessage)
}
inline ::RemovedFromGameMessage* PokerTHMessage::release_removedfromgamemessage() {
  _has_bits_[0] &= ~0x10000000u;
  ::RemovedFromGameMessage* temp = removedfromgamemessage_;
  removedfromgamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RemovedFromGameMessage* PokerTHMessage::unsafe_arena_release_removedfromgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.removedFromGameMessage)
  _has_bits_[0] &= ~0x10000000u;
  ::RemovedFromGameMessage* temp = removedfromgamemessage_;
  removedfromgamemessage_ = nullptr;
  return temp;
}
inline ::RemovedFromGameMessage* PokerTHMessage::_internal_mutable_removedfromgamemessage() {
  _has_bits_[0] |= 0x10000000u;
  if (removedfromgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RemovedFromGameMessage>(GetArenaForAllocation());
    removedfromgamemessage_ = p;
  }
  return removedfromgamemessage_;
}
inline ::RemovedFromGameMessage* PokerTHMessage::mutable_removedfromgamemessage() {
  ::RemovedFromGameMessage* _msg = _internal_mutable_removedfromgamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.removedFromGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_removedfromgamemessage(::RemovedFromGameMessage* removedfromgamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete removedfromgamemessage_;
  }
  if (removedfromgamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RemovedFromGameMessage>::GetOwningArena(removedfromgamemessage);
    if (message_arena != submessage_arena) {
      removedfromgamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, removedfromgamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  removedfromgamemessage_ = removedfromgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.removedFromGameMessage)
}

// optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
inline bool PokerTHMessage::_internal_has_kickplayerrequestmessage() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || kickplayerrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_kickplayerrequestmessage() const {
  return _internal_has_kickplayerrequestmessage();
}
inline void PokerTHMessage::clear_kickplayerrequestmessage() {
  if (kickplayerrequestmessage_ != nullptr) kickplayerrequestmessage_->Clear();
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::KickPlayerRequestMessage& PokerTHMessage::_internal_kickplayerrequestmessage() const {
  const ::KickPlayerRequestMessage* p = kickplayerrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::KickPlayerRequestMessage&>(
      ::_KickPlayerRequestMessage_default_instance_);
}
inline const ::KickPlayerRequestMessage& PokerTHMessage::kickplayerrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.kickPlayerRequestMessage)
  return _internal_kickplayerrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_kickplayerrequestmessage(
    ::KickPlayerRequestMessage* kickplayerrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kickplayerrequestmessage_);
  }
  kickplayerrequestmessage_ = kickplayerrequestmessage;
  if (kickplayerrequestmessage) {
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.kickPlayerRequestMessage)
}
inline ::KickPlayerRequestMessage* PokerTHMessage::release_kickplayerrequestmessage() {
  _has_bits_[0] &= ~0x20000000u;
  ::KickPlayerRequestMessage* temp = kickplayerrequestmessage_;
  kickplayerrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::unsafe_arena_release_kickplayerrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.kickPlayerRequestMessage)
  _has_bits_[0] &= ~0x20000000u;
  ::KickPlayerRequestMessage* temp = kickplayerrequestmessage_;
  kickplayerrequestmessage_ = nullptr;
  return temp;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::_internal_mutable_kickplayerrequestmessage() {
  _has_bits_[0] |= 0x20000000u;
  if (kickplayerrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::KickPlayerRequestMessage>(GetArenaForAllocation());
    kickplayerrequestmessage_ = p;
  }
  return kickplayerrequestmessage_;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::mutable_kickplayerrequestmessage() {
  ::KickPlayerRequestMessage* _msg = _internal_mutable_kickplayerrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.kickPlayerRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_kickplayerrequestmessage(::KickPlayerRequestMessage* kickplayerrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kickplayerrequestmessage_;
  }
  if (kickplayerrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KickPlayerRequestMessage>::GetOwningArena(kickplayerrequestmessage);
    if (message_arena != submessage_arena) {
      kickplayerrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kickplayerrequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  kickplayerrequestmessage_ = kickplayerrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.kickPlayerRequestMessage)
}

// optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
inline bool PokerTHMessage::_internal_has_leavegamerequestmessage() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || leavegamerequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_leavegamerequestmessage() const {
  return _internal_has_leavegamerequestmessage();
}
inline void PokerTHMessage::clear_leavegamerequestmessage() {
  if (leavegamerequestmessage_ != nullptr) leavegamerequestmessage_->Clear();
  _has_bits_[0] &= ~0x40000000u;
}
inline const ::LeaveGameRequestMessage& PokerTHMessage::_internal_leavegamerequestmessage() const {
  const ::LeaveGameRequestMessage* p = leavegamerequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::LeaveGameRequestMessage&>(
      ::_LeaveGameRequestMessage_default_instance_);
}
inline const ::LeaveGameRequestMessage& PokerTHMessage::leavegamerequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.leaveGameRequestMessage)
  return _internal_leavegamerequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_leavegamerequestmessage(
    ::LeaveGameRequestMessage* leavegamerequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leavegamerequestmessage_);
  }
  leavegamerequestmessage_ = leavegamerequestmessage;
  if (leavegamerequestmessage) {
    _has_bits_[0] |= 0x40000000u;
  } else {
    _has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.leaveGameRequestMessage)
}
inline ::LeaveGameRequestMessage* PokerTHMessage::release_leavegamerequestmessage() {
  _has_bits_[0] &= ~0x40000000u;
  ::LeaveGameRequestMessage* temp = leavegamerequestmessage_;
  leavegamerequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::unsafe_arena_release_leavegamerequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.leaveGameRequestMessage)
  _has_bits_[0] &= ~0x40000000u;
  ::LeaveGameRequestMessage* temp = leavegamerequestmessage_;
  leavegamerequestmessage_ = nullptr;
  return temp;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::_internal_mutable_leavegamerequestmessage() {
  _has_bits_[0] |= 0x40000000u;
  if (leavegamerequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::LeaveGameRequestMessage>(GetArenaForAllocation());
    leavegamerequestmessage_ = p;
  }
  return leavegamerequestmessage_;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::mutable_leavegamerequestmessage() {
  ::LeaveGameRequestMessage* _msg = _internal_mutable_leavegamerequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.leaveGameRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_leavegamerequestmessage(::LeaveGameRequestMessage* leavegamerequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete leavegamerequestmessage_;
  }
  if (leavegamerequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::LeaveGameRequestMessage>::GetOwningArena(leavegamerequestmessage);
    if (message_arena != submessage_arena) {
      leavegamerequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leavegamerequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x40000000u;
  } else {
    _has_bits_[0] &= ~0x40000000u;
  }
  leavegamerequestmessage_ = leavegamerequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.leaveGameRequestMessage)
}

// optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
inline bool PokerTHMessage::_internal_has_inviteplayertogamemessage() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || inviteplayertogamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_inviteplayertogamemessage() const {
  return _internal_has_inviteplayertogamemessage();
}
inline void PokerTHMessage::clear_inviteplayertogamemessage() {
  if (inviteplayertogamemessage_ != nullptr) inviteplayertogamemessage_->Clear();
  _has_bits_[0] &= ~0x80000000u;
}
inline const ::InvitePlayerToGameMessage& PokerTHMessage::_internal_inviteplayertogamemessage() const {
  const ::InvitePlayerToGameMessage* p = inviteplayertogamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::InvitePlayerToGameMessage&>(
      ::_InvitePlayerToGameMessage_default_instance_);
}
inline const ::InvitePlayerToGameMessage& PokerTHMessage::inviteplayertogamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.invitePlayerToGameMessage)
  return _internal_inviteplayertogamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_inviteplayertogamemessage(
    ::InvitePlayerToGameMessage* inviteplayertogamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inviteplayertogamemessage_);
  }
  inviteplayertogamemessage_ = inviteplayertogamemessage;
  if (inviteplayertogamemessage) {
    _has_bits_[0] |= 0x80000000u;
  } else {
    _has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.invitePlayerToGameMessage)
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::release_inviteplayertogamemessage() {
  _has_bits_[0] &= ~0x80000000u;
  ::InvitePlayerToGameMessage* temp = inviteplayertogamemessage_;
  inviteplayertogamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::unsafe_arena_release_inviteplayertogamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.invitePlayerToGameMessage)
  _has_bits_[0] &= ~0x80000000u;
  ::InvitePlayerToGameMessage* temp = inviteplayertogamemessage_;
  inviteplayertogamemessage_ = nullptr;
  return temp;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::_internal_mutable_inviteplayertogamemessage() {
  _has_bits_[0] |= 0x80000000u;
  if (inviteplayertogamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InvitePlayerToGameMessage>(GetArenaForAllocation());
    inviteplayertogamemessage_ = p;
  }
  return inviteplayertogamemessage_;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::mutable_inviteplayertogamemessage() {
  ::InvitePlayerToGameMessage* _msg = _internal_mutable_inviteplayertogamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.invitePlayerToGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_inviteplayertogamemessage(::InvitePlayerToGameMessage* inviteplayertogamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inviteplayertogamemessage_;
  }
  if (inviteplayertogamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::InvitePlayerToGameMessage>::GetOwningArena(inviteplayertogamemessage);
    if (message_arena != submessage_arena) {
      inviteplayertogamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inviteplayertogamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x80000000u;
  } else {
    _has_bits_[0] &= ~0x80000000u;
  }
  inviteplayertogamemessage_ = inviteplayertogamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.invitePlayerToGameMessage)
}

// optional .InviteNotifyMessage inviteNotifyMessage = 34;
inline bool PokerTHMessage::_internal_has_invitenotifymessage() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || invitenotifymessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_invitenotifymessage() const {
  return _internal_has_invitenotifymessage();
}
inline void PokerTHMessage::clear_invitenotifymessage() {
  if (invitenotifymessage_ != nullptr) invitenotifymessage_->Clear();
  _has_bits_[1] &= ~0x00000001u;
}
inline const ::InviteNotifyMessage& PokerTHMessage::_internal_invitenotifymessage() const {
  const ::InviteNotifyMessage* p = invitenotifymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::InviteNotifyMessage&>(
      ::_InviteNotifyMessage_default_instance_);
}
inline const ::InviteNotifyMessage& PokerTHMessage::invitenotifymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.inviteNotifyMessage)
  return _internal_invitenotifymessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_invitenotifymessage(
    ::InviteNotifyMessage* invitenotifymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invitenotifymessage_);
  }
  invitenotifymessage_ = invitenotifymessage;
  if (invitenotifymessage) {
    _has_bits_[1] |= 0x00000001u;
  } else {
    _has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.inviteNotifyMessage)
}
inline ::InviteNotifyMessage* PokerTHMessage::release_invitenotifymessage() {
  _has_bits_[1] &= ~0x00000001u;
  ::InviteNotifyMessage* temp = invitenotifymessage_;
  invitenotifymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::InviteNotifyMessage* PokerTHMessage::unsafe_arena_release_invitenotifymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.inviteNotifyMessage)
  _has_bits_[1] &= ~0x00000001u;
  ::InviteNotifyMessage* temp = invitenotifymessage_;
  invitenotifymessage_ = nullptr;
  return temp;
}
inline ::InviteNotifyMessage* PokerTHMessage::_internal_mutable_invitenotifymessage() {
  _has_bits_[1] |= 0x00000001u;
  if (invitenotifymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InviteNotifyMessage>(GetArenaForAllocation());
    invitenotifymessage_ = p;
  }
  return invitenotifymessage_;
}
inline ::InviteNotifyMessage* PokerTHMessage::mutable_invitenotifymessage() {
  ::InviteNotifyMessage* _msg = _internal_mutable_invitenotifymessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.inviteNotifyMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_invitenotifymessage(::InviteNotifyMessage* invitenotifymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invitenotifymessage_;
  }
  if (invitenotifymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::InviteNotifyMessage>::GetOwningArena(invitenotifymessage);
    if (message_arena != submessage_arena) {
      invitenotifymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invitenotifymessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000001u;
  } else {
    _has_bits_[1] &= ~0x00000001u;
  }
  invitenotifymessage_ = invitenotifymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.inviteNotifyMessage)
}

// optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
inline bool PokerTHMessage::_internal_has_rejectgameinvitationmessage() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rejectgameinvitationmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_rejectgameinvitationmessage() const {
  return _internal_has_rejectgameinvitationmessage();
}
inline void PokerTHMessage::clear_rejectgameinvitationmessage() {
  if (rejectgameinvitationmessage_ != nullptr) rejectgameinvitationmessage_->Clear();
  _has_bits_[1] &= ~0x00000002u;
}
inline const ::RejectGameInvitationMessage& PokerTHMessage::_internal_rejectgameinvitationmessage() const {
  const ::RejectGameInvitationMessage* p = rejectgameinvitationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::RejectGameInvitationMessage&>(
      ::_RejectGameInvitationMessage_default_instance_);
}
inline const ::RejectGameInvitationMessage& PokerTHMessage::rejectgameinvitationmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejectGameInvitationMessage)
  return _internal_rejectgameinvitationmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_rejectgameinvitationmessage(
    ::RejectGameInvitationMessage* rejectgameinvitationmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rejectgameinvitationmessage_);
  }
  rejectgameinvitationmessage_ = rejectgameinvitationmessage;
  if (rejectgameinvitationmessage) {
    _has_bits_[1] |= 0x00000002u;
  } else {
    _has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.rejectGameInvitationMessage)
}
inline ::RejectGameInvitationMessage* PokerTHMessage::release_rejectgameinvitationmessage() {
  _has_bits_[1] &= ~0x00000002u;
  ::RejectGameInvitationMessage* temp = rejectgameinvitationmessage_;
  rejectgameinvitationmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::unsafe_arena_release_rejectgameinvitationmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.rejectGameInvitationMessage)
  _has_bits_[1] &= ~0x00000002u;
  ::RejectGameInvitationMessage* temp = rejectgameinvitationmessage_;
  rejectgameinvitationmessage_ = nullptr;
  return temp;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::_internal_mutable_rejectgameinvitationmessage() {
  _has_bits_[1] |= 0x00000002u;
  if (rejectgameinvitationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RejectGameInvitationMessage>(GetArenaForAllocation());
    rejectgameinvitationmessage_ = p;
  }
  return rejectgameinvitationmessage_;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::mutable_rejectgameinvitationmessage() {
  ::RejectGameInvitationMessage* _msg = _internal_mutable_rejectgameinvitationmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejectGameInvitationMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_rejectgameinvitationmessage(::RejectGameInvitationMessage* rejectgameinvitationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rejectgameinvitationmessage_;
  }
  if (rejectgameinvitationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RejectGameInvitationMessage>::GetOwningArena(rejectgameinvitationmessage);
    if (message_arena != submessage_arena) {
      rejectgameinvitationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rejectgameinvitationmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000002u;
  } else {
    _has_bits_[1] &= ~0x00000002u;
  }
  rejectgameinvitationmessage_ = rejectgameinvitationmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejectGameInvitationMessage)
}

// optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
inline bool PokerTHMessage::_internal_has_rejectinvnotifymessage() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rejectinvnotifymessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_rejectinvnotifymessage() const {
  return _internal_has_rejectinvnotifymessage();
}
inline void PokerTHMessage::clear_rejectinvnotifymessage() {
  if (rejectinvnotifymessage_ != nullptr) rejectinvnotifymessage_->Clear();
  _has_bits_[1] &= ~0x00000004u;
}
inline const ::RejectInvNotifyMessage& PokerTHMessage::_internal_rejectinvnotifymessage() const {
  const ::RejectInvNotifyMessage* p = rejectinvnotifymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::RejectInvNotifyMessage&>(
      ::_RejectInvNotifyMessage_default_instance_);
}
inline const ::RejectInvNotifyMessage& PokerTHMessage::rejectinvnotifymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejectInvNotifyMessage)
  return _internal_rejectinvnotifymessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_rejectinvnotifymessage(
    ::RejectInvNotifyMessage* rejectinvnotifymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rejectinvnotifymessage_);
  }
  rejectinvnotifymessage_ = rejectinvnotifymessage;
  if (rejectinvnotifymessage) {
    _has_bits_[1] |= 0x00000004u;
  } else {
    _has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.rejectInvNotifyMessage)
}
inline ::RejectInvNotifyMessage* PokerTHMessage::release_rejectinvnotifymessage() {
  _has_bits_[1] &= ~0x00000004u;
  ::RejectInvNotifyMessage* temp = rejectinvnotifymessage_;
  rejectinvnotifymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::unsafe_arena_release_rejectinvnotifymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.rejectInvNotifyMessage)
  _has_bits_[1] &= ~0x00000004u;
  ::RejectInvNotifyMessage* temp = rejectinvnotifymessage_;
  rejectinvnotifymessage_ = nullptr;
  return temp;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::_internal_mutable_rejectinvnotifymessage() {
  _has_bits_[1] |= 0x00000004u;
  if (rejectinvnotifymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RejectInvNotifyMessage>(GetArenaForAllocation());
    rejectinvnotifymessage_ = p;
  }
  return rejectinvnotifymessage_;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::mutable_rejectinvnotifymessage() {
  ::RejectInvNotifyMessage* _msg = _internal_mutable_rejectinvnotifymessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejectInvNotifyMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_rejectinvnotifymessage(::RejectInvNotifyMessage* rejectinvnotifymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rejectinvnotifymessage_;
  }
  if (rejectinvnotifymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RejectInvNotifyMessage>::GetOwningArena(rejectinvnotifymessage);
    if (message_arena != submessage_arena) {
      rejectinvnotifymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rejectinvnotifymessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000004u;
  } else {
    _has_bits_[1] &= ~0x00000004u;
  }
  rejectinvnotifymessage_ = rejectinvnotifymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejectInvNotifyMessage)
}

// optional .StartEventMessage startEventMessage = 37;
inline bool PokerTHMessage::_internal_has_starteventmessage() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || starteventmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_starteventmessage() const {
  return _internal_has_starteventmessage();
}
inline void PokerTHMessage::clear_starteventmessage() {
  if (starteventmessage_ != nullptr) starteventmessage_->Clear();
  _has_bits_[1] &= ~0x00000008u;
}
inline const ::StartEventMessage& PokerTHMessage::_internal_starteventmessage() const {
  const ::StartEventMessage* p = starteventmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::StartEventMessage&>(
      ::_StartEventMessage_default_instance_);
}
inline const ::StartEventMessage& PokerTHMessage::starteventmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.startEventMessage)
  return _internal_starteventmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_starteventmessage(
    ::StartEventMessage* starteventmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starteventmessage_);
  }
  starteventmessage_ = starteventmessage;
  if (starteventmessage) {
    _has_bits_[1] |= 0x00000008u;
  } else {
    _has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.startEventMessage)
}
inline ::StartEventMessage* PokerTHMessage::release_starteventmessage() {
  _has_bits_[1] &= ~0x00000008u;
  ::StartEventMessage* temp = starteventmessage_;
  starteventmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StartEventMessage* PokerTHMessage::unsafe_arena_release_starteventmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.startEventMessage)
  _has_bits_[1] &= ~0x00000008u;
  ::StartEventMessage* temp = starteventmessage_;
  starteventmessage_ = nullptr;
  return temp;
}
inline ::StartEventMessage* PokerTHMessage::_internal_mutable_starteventmessage() {
  _has_bits_[1] |= 0x00000008u;
  if (starteventmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartEventMessage>(GetArenaForAllocation());
    starteventmessage_ = p;
  }
  return starteventmessage_;
}
inline ::StartEventMessage* PokerTHMessage::mutable_starteventmessage() {
  ::StartEventMessage* _msg = _internal_mutable_starteventmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startEventMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_starteventmessage(::StartEventMessage* starteventmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete starteventmessage_;
  }
  if (starteventmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StartEventMessage>::GetOwningArena(starteventmessage);
    if (message_arena != submessage_arena) {
      starteventmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starteventmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000008u;
  } else {
    _has_bits_[1] &= ~0x00000008u;
  }
  starteventmessage_ = starteventmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startEventMessage)
}

// optional .StartEventAckMessage startEventAckMessage = 38;
inline bool PokerTHMessage::_internal_has_starteventackmessage() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || starteventackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_starteventackmessage() const {
  return _internal_has_starteventackmessage();
}
inline void PokerTHMessage::clear_starteventackmessage() {
  if (starteventackmessage_ != nullptr) starteventackmessage_->Clear();
  _has_bits_[1] &= ~0x00000010u;
}
inline const ::StartEventAckMessage& PokerTHMessage::_internal_starteventackmessage() const {
  const ::StartEventAckMessage* p = starteventackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::StartEventAckMessage&>(
      ::_StartEventAckMessage_default_instance_);
}
inline const ::StartEventAckMessage& PokerTHMessage::starteventackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.startEventAckMessage)
  return _internal_starteventackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_starteventackmessage(
    ::StartEventAckMessage* starteventackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starteventackmessage_);
  }
  starteventackmessage_ = starteventackmessage;
  if (starteventackmessage) {
    _has_bits_[1] |= 0x00000010u;
  } else {
    _has_bits_[1] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.startEventAckMessage)
}
inline ::StartEventAckMessage* PokerTHMessage::release_starteventackmessage() {
  _has_bits_[1] &= ~0x00000010u;
  ::StartEventAckMessage* temp = starteventackmessage_;
  starteventackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StartEventAckMessage* PokerTHMessage::unsafe_arena_release_starteventackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.startEventAckMessage)
  _has_bits_[1] &= ~0x00000010u;
  ::StartEventAckMessage* temp = starteventackmessage_;
  starteventackmessage_ = nullptr;
  return temp;
}
inline ::StartEventAckMessage* PokerTHMessage::_internal_mutable_starteventackmessage() {
  _has_bits_[1] |= 0x00000010u;
  if (starteventackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartEventAckMessage>(GetArenaForAllocation());
    starteventackmessage_ = p;
  }
  return starteventackmessage_;
}
inline ::StartEventAckMessage* PokerTHMessage::mutable_starteventackmessage() {
  ::StartEventAckMessage* _msg = _internal_mutable_starteventackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startEventAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_starteventackmessage(::StartEventAckMessage* starteventackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete starteventackmessage_;
  }
  if (starteventackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StartEventAckMessage>::GetOwningArena(starteventackmessage);
    if (message_arena != submessage_arena) {
      starteventackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starteventackmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000010u;
  } else {
    _has_bits_[1] &= ~0x00000010u;
  }
  starteventackmessage_ = starteventackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startEventAckMessage)
}

// optional .GameStartInitialMessage gameStartInitialMessage = 39;
inline bool PokerTHMessage::_internal_has_gamestartinitialmessage() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || gamestartinitialmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamestartinitialmessage() const {
  return _internal_has_gamestartinitialmessage();
}
inline void PokerTHMessage::clear_gamestartinitialmessage() {
  if (gamestartinitialmessage_ != nullptr) gamestartinitialmessage_->Clear();
  _has_bits_[1] &= ~0x00000020u;
}
inline const ::GameStartInitialMessage& PokerTHMessage::_internal_gamestartinitialmessage() const {
  const ::GameStartInitialMessage* p = gamestartinitialmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameStartInitialMessage&>(
      ::_GameStartInitialMessage_default_instance_);
}
inline const ::GameStartInitialMessage& PokerTHMessage::gamestartinitialmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameStartInitialMessage)
  return _internal_gamestartinitialmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamestartinitialmessage(
    ::GameStartInitialMessage* gamestartinitialmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamestartinitialmessage_);
  }
  gamestartinitialmessage_ = gamestartinitialmessage;
  if (gamestartinitialmessage) {
    _has_bits_[1] |= 0x00000020u;
  } else {
    _has_bits_[1] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameStartInitialMessage)
}
inline ::GameStartInitialMessage* PokerTHMessage::release_gamestartinitialmessage() {
  _has_bits_[1] &= ~0x00000020u;
  ::GameStartInitialMessage* temp = gamestartinitialmessage_;
  gamestartinitialmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameStartInitialMessage* PokerTHMessage::unsafe_arena_release_gamestartinitialmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameStartInitialMessage)
  _has_bits_[1] &= ~0x00000020u;
  ::GameStartInitialMessage* temp = gamestartinitialmessage_;
  gamestartinitialmessage_ = nullptr;
  return temp;
}
inline ::GameStartInitialMessage* PokerTHMessage::_internal_mutable_gamestartinitialmessage() {
  _has_bits_[1] |= 0x00000020u;
  if (gamestartinitialmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameStartInitialMessage>(GetArenaForAllocation());
    gamestartinitialmessage_ = p;
  }
  return gamestartinitialmessage_;
}
inline ::GameStartInitialMessage* PokerTHMessage::mutable_gamestartinitialmessage() {
  ::GameStartInitialMessage* _msg = _internal_mutable_gamestartinitialmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameStartInitialMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamestartinitialmessage(::GameStartInitialMessage* gamestartinitialmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamestartinitialmessage_;
  }
  if (gamestartinitialmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameStartInitialMessage>::GetOwningArena(gamestartinitialmessage);
    if (message_arena != submessage_arena) {
      gamestartinitialmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamestartinitialmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000020u;
  } else {
    _has_bits_[1] &= ~0x00000020u;
  }
  gamestartinitialmessage_ = gamestartinitialmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameStartInitialMessage)
}

// optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
inline bool PokerTHMessage::_internal_has_gamestartrejoinmessage() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || gamestartrejoinmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamestartrejoinmessage() const {
  return _internal_has_gamestartrejoinmessage();
}
inline void PokerTHMessage::clear_gamestartrejoinmessage() {
  if (gamestartrejoinmessage_ != nullptr) gamestartrejoinmessage_->Clear();
  _has_bits_[1] &= ~0x00000040u;
}
inline const ::GameStartRejoinMessage& PokerTHMessage::_internal_gamestartrejoinmessage() const {
  const ::GameStartRejoinMessage* p = gamestartrejoinmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameStartRejoinMessage&>(
      ::_GameStartRejoinMessage_default_instance_);
}
inline const ::GameStartRejoinMessage& PokerTHMessage::gamestartrejoinmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameStartRejoinMessage)
  return _internal_gamestartrejoinmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamestartrejoinmessage(
    ::GameStartRejoinMessage* gamestartrejoinmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamestartrejoinmessage_);
  }
  gamestartrejoinmessage_ = gamestartrejoinmessage;
  if (gamestartrejoinmessage) {
    _has_bits_[1] |= 0x00000040u;
  } else {
    _has_bits_[1] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameStartRejoinMessage)
}
inline ::GameStartRejoinMessage* PokerTHMessage::release_gamestartrejoinmessage() {
  _has_bits_[1] &= ~0x00000040u;
  ::GameStartRejoinMessage* temp = gamestartrejoinmessage_;
  gamestartrejoinmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameStartRejoinMessage* PokerTHMessage::unsafe_arena_release_gamestartrejoinmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameStartRejoinMessage)
  _has_bits_[1] &= ~0x00000040u;
  ::GameStartRejoinMessage* temp = gamestartrejoinmessage_;
  gamestartrejoinmessage_ = nullptr;
  return temp;
}
inline ::GameStartRejoinMessage* PokerTHMessage::_internal_mutable_gamestartrejoinmessage() {
  _has_bits_[1] |= 0x00000040u;
  if (gamestartrejoinmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameStartRejoinMessage>(GetArenaForAllocation());
    gamestartrejoinmessage_ = p;
  }
  return gamestartrejoinmessage_;
}
inline ::GameStartRejoinMessage* PokerTHMessage::mutable_gamestartrejoinmessage() {
  ::GameStartRejoinMessage* _msg = _internal_mutable_gamestartrejoinmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameStartRejoinMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamestartrejoinmessage(::GameStartRejoinMessage* gamestartrejoinmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamestartrejoinmessage_;
  }
  if (gamestartrejoinmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameStartRejoinMessage>::GetOwningArena(gamestartrejoinmessage);
    if (message_arena != submessage_arena) {
      gamestartrejoinmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamestartrejoinmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000040u;
  } else {
    _has_bits_[1] &= ~0x00000040u;
  }
  gamestartrejoinmessage_ = gamestartrejoinmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameStartRejoinMessage)
}

// optional .HandStartMessage handStartMessage = 41;
inline bool PokerTHMessage::_internal_has_handstartmessage() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || handstartmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_handstartmessage() const {
  return _internal_has_handstartmessage();
}
inline void PokerTHMessage::clear_handstartmessage() {
  if (handstartmessage_ != nullptr) handstartmessage_->Clear();
  _has_bits_[1] &= ~0x00000080u;
}
inline const ::HandStartMessage& PokerTHMessage::_internal_handstartmessage() const {
  const ::HandStartMessage* p = handstartmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::HandStartMessage&>(
      ::_HandStartMessage_default_instance_);
}
inline const ::HandStartMessage& PokerTHMessage::handstartmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.handStartMessage)
  return _internal_handstartmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_handstartmessage(
    ::HandStartMessage* handstartmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handstartmessage_);
  }
  handstartmessage_ = handstartmessage;
  if (handstartmessage) {
    _has_bits_[1] |= 0x00000080u;
  } else {
    _has_bits_[1] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.handStartMessage)
}
inline ::HandStartMessage* PokerTHMessage::release_handstartmessage() {
  _has_bits_[1] &= ~0x00000080u;
  ::HandStartMessage* temp = handstartmessage_;
  handstartmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HandStartMessage* PokerTHMessage::unsafe_arena_release_handstartmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.handStartMessage)
  _has_bits_[1] &= ~0x00000080u;
  ::HandStartMessage* temp = handstartmessage_;
  handstartmessage_ = nullptr;
  return temp;
}
inline ::HandStartMessage* PokerTHMessage::_internal_mutable_handstartmessage() {
  _has_bits_[1] |= 0x00000080u;
  if (handstartmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::HandStartMessage>(GetArenaForAllocation());
    handstartmessage_ = p;
  }
  return handstartmessage_;
}
inline ::HandStartMessage* PokerTHMessage::mutable_handstartmessage() {
  ::HandStartMessage* _msg = _internal_mutable_handstartmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.handStartMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_handstartmessage(::HandStartMessage* handstartmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete handstartmessage_;
  }
  if (handstartmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HandStartMessage>::GetOwningArena(handstartmessage);
    if (message_arena != submessage_arena) {
      handstartmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handstartmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000080u;
  } else {
    _has_bits_[1] &= ~0x00000080u;
  }
  handstartmessage_ = handstartmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.handStartMessage)
}

// optional .PlayersTurnMessage playersTurnMessage = 42;
inline bool PokerTHMessage::_internal_has_playersturnmessage() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || playersturnmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_playersturnmessage() const {
  return _internal_has_playersturnmessage();
}
inline void PokerTHMessage::clear_playersturnmessage() {
  if (playersturnmessage_ != nullptr) playersturnmessage_->Clear();
  _has_bits_[1] &= ~0x00000100u;
}
inline const ::PlayersTurnMessage& PokerTHMessage::_internal_playersturnmessage() const {
  const ::PlayersTurnMessage* p = playersturnmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayersTurnMessage&>(
      ::_PlayersTurnMessage_default_instance_);
}
inline const ::PlayersTurnMessage& PokerTHMessage::playersturnmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playersTurnMessage)
  return _internal_playersturnmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_playersturnmessage(
    ::PlayersTurnMessage* playersturnmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playersturnmessage_);
  }
  playersturnmessage_ = playersturnmessage;
  if (playersturnmessage) {
    _has_bits_[1] |= 0x00000100u;
  } else {
    _has_bits_[1] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.playersTurnMessage)
}
inline ::PlayersTurnMessage* PokerTHMessage::release_playersturnmessage() {
  _has_bits_[1] &= ~0x00000100u;
  ::PlayersTurnMessage* temp = playersturnmessage_;
  playersturnmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayersTurnMessage* PokerTHMessage::unsafe_arena_release_playersturnmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playersTurnMessage)
  _has_bits_[1] &= ~0x00000100u;
  ::PlayersTurnMessage* temp = playersturnmessage_;
  playersturnmessage_ = nullptr;
  return temp;
}
inline ::PlayersTurnMessage* PokerTHMessage::_internal_mutable_playersturnmessage() {
  _has_bits_[1] |= 0x00000100u;
  if (playersturnmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayersTurnMessage>(GetArenaForAllocation());
    playersturnmessage_ = p;
  }
  return playersturnmessage_;
}
inline ::PlayersTurnMessage* PokerTHMessage::mutable_playersturnmessage() {
  ::PlayersTurnMessage* _msg = _internal_mutable_playersturnmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playersTurnMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_playersturnmessage(::PlayersTurnMessage* playersturnmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playersturnmessage_;
  }
  if (playersturnmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayersTurnMessage>::GetOwningArena(playersturnmessage);
    if (message_arena != submessage_arena) {
      playersturnmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playersturnmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000100u;
  } else {
    _has_bits_[1] &= ~0x00000100u;
  }
  playersturnmessage_ = playersturnmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playersTurnMessage)
}

// optional .MyActionRequestMessage myActionRequestMessage = 43;
inline bool PokerTHMessage::_internal_has_myactionrequestmessage() const {
  bool value = (_has_bits_[1] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || myactionrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_myactionrequestmessage() const {
  return _internal_has_myactionrequestmessage();
}
inline void PokerTHMessage::clear_myactionrequestmessage() {
  if (myactionrequestmessage_ != nullptr) myactionrequestmessage_->Clear();
  _has_bits_[1] &= ~0x00000200u;
}
inline const ::MyActionRequestMessage& PokerTHMessage::_internal_myactionrequestmessage() const {
  const ::MyActionRequestMessage* p = myactionrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::MyActionRequestMessage&>(
      ::_MyActionRequestMessage_default_instance_);
}
inline const ::MyActionRequestMessage& PokerTHMessage::myactionrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.myActionRequestMessage)
  return _internal_myactionrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_myactionrequestmessage(
    ::MyActionRequestMessage* myactionrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(myactionrequestmessage_);
  }
  myactionrequestmessage_ = myactionrequestmessage;
  if (myactionrequestmessage) {
    _has_bits_[1] |= 0x00000200u;
  } else {
    _has_bits_[1] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.myActionRequestMessage)
}
inline ::MyActionRequestMessage* PokerTHMessage::release_myactionrequestmessage() {
  _has_bits_[1] &= ~0x00000200u;
  ::MyActionRequestMessage* temp = myactionrequestmessage_;
  myactionrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MyActionRequestMessage* PokerTHMessage::unsafe_arena_release_myactionrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.myActionRequestMessage)
  _has_bits_[1] &= ~0x00000200u;
  ::MyActionRequestMessage* temp = myactionrequestmessage_;
  myactionrequestmessage_ = nullptr;
  return temp;
}
inline ::MyActionRequestMessage* PokerTHMessage::_internal_mutable_myactionrequestmessage() {
  _has_bits_[1] |= 0x00000200u;
  if (myactionrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::MyActionRequestMessage>(GetArenaForAllocation());
    myactionrequestmessage_ = p;
  }
  return myactionrequestmessage_;
}
inline ::MyActionRequestMessage* PokerTHMessage::mutable_myactionrequestmessage() {
  ::MyActionRequestMessage* _msg = _internal_mutable_myactionrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.myActionRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_myactionrequestmessage(::MyActionRequestMessage* myactionrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete myactionrequestmessage_;
  }
  if (myactionrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MyActionRequestMessage>::GetOwningArena(myactionrequestmessage);
    if (message_arena != submessage_arena) {
      myactionrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, myactionrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000200u;
  } else {
    _has_bits_[1] &= ~0x00000200u;
  }
  myactionrequestmessage_ = myactionrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.myActionRequestMessage)
}

// optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
inline bool PokerTHMessage::_internal_has_youractionrejectedmessage() const {
  bool value = (_has_bits_[1] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || youractionrejectedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_youractionrejectedmessage() const {
  return _internal_has_youractionrejectedmessage();
}
inline void PokerTHMessage::clear_youractionrejectedmessage() {
  if (youractionrejectedmessage_ != nullptr) youractionrejectedmessage_->Clear();
  _has_bits_[1] &= ~0x00000400u;
}
inline const ::YourActionRejectedMessage& PokerTHMessage::_internal_youractionrejectedmessage() const {
  const ::YourActionRejectedMessage* p = youractionrejectedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::YourActionRejectedMessage&>(
      ::_YourActionRejectedMessage_default_instance_);
}
inline const ::YourActionRejectedMessage& PokerTHMessage::youractionrejectedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.yourActionRejectedMessage)
  return _internal_youractionrejectedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_youractionrejectedmessage(
    ::YourActionRejectedMessage* youractionrejectedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(youractionrejectedmessage_);
  }
  youractionrejectedmessage_ = youractionrejectedmessage;
  if (youractionrejectedmessage) {
    _has_bits_[1] |= 0x00000400u;
  } else {
    _has_bits_[1] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.yourActionRejectedMessage)
}
inline ::YourActionRejectedMessage* PokerTHMessage::release_youractionrejectedmessage() {
  _has_bits_[1] &= ~0x00000400u;
  ::YourActionRejectedMessage* temp = youractionrejectedmessage_;
  youractionrejectedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::YourActionRejectedMessage* PokerTHMessage::unsafe_arena_release_youractionrejectedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.yourActionRejectedMessage)
  _has_bits_[1] &= ~0x00000400u;
  ::YourActionRejectedMessage* temp = youractionrejectedmessage_;
  youractionrejectedmessage_ = nullptr;
  return temp;
}
inline ::YourActionRejectedMessage* PokerTHMessage::_internal_mutable_youractionrejectedmessage() {
  _has_bits_[1] |= 0x00000400u;
  if (youractionrejectedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::YourActionRejectedMessage>(GetArenaForAllocation());
    youractionrejectedmessage_ = p;
  }
  return youractionrejectedmessage_;
}
inline ::YourActionRejectedMessage* PokerTHMessage::mutable_youractionrejectedmessage() {
  ::YourActionRejectedMessage* _msg = _internal_mutable_youractionrejectedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.yourActionRejectedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_youractionrejectedmessage(::YourActionRejectedMessage* youractionrejectedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete youractionrejectedmessage_;
  }
  if (youractionrejectedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::YourActionRejectedMessage>::GetOwningArena(youractionrejectedmessage);
    if (message_arena != submessage_arena) {
      youractionrejectedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, youractionrejectedmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000400u;
  } else {
    _has_bits_[1] &= ~0x00000400u;
  }
  youractionrejectedmessage_ = youractionrejectedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.yourActionRejectedMessage)
}

// optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
inline bool PokerTHMessage::_internal_has_playersactiondonemessage() const {
  bool value = (_has_bits_[1] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || playersactiondonemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_playersactiondonemessage() const {
  return _internal_has_playersactiondonemessage();
}
inline void PokerTHMessage::clear_playersactiondonemessage() {
  if (playersactiondonemessage_ != nullptr) playersactiondonemessage_->Clear();
  _has_bits_[1] &= ~0x00000800u;
}
inline const ::PlayersActionDoneMessage& PokerTHMessage::_internal_playersactiondonemessage() const {
  const ::PlayersActionDoneMessage* p = playersactiondonemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayersActionDoneMessage&>(
      ::_PlayersActionDoneMessage_default_instance_);
}
inline const ::PlayersActionDoneMessage& PokerTHMessage::playersactiondonemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playersActionDoneMessage)
  return _internal_playersactiondonemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_playersactiondonemessage(
    ::PlayersActionDoneMessage* playersactiondonemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playersactiondonemessage_);
  }
  playersactiondonemessage_ = playersactiondonemessage;
  if (playersactiondonemessage) {
    _has_bits_[1] |= 0x00000800u;
  } else {
    _has_bits_[1] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.playersActionDoneMessage)
}
inline ::PlayersActionDoneMessage* PokerTHMessage::release_playersactiondonemessage() {
  _has_bits_[1] &= ~0x00000800u;
  ::PlayersActionDoneMessage* temp = playersactiondonemessage_;
  playersactiondonemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::unsafe_arena_release_playersactiondonemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playersActionDoneMessage)
  _has_bits_[1] &= ~0x00000800u;
  ::PlayersActionDoneMessage* temp = playersactiondonemessage_;
  playersactiondonemessage_ = nullptr;
  return temp;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::_internal_mutable_playersactiondonemessage() {
  _has_bits_[1] |= 0x00000800u;
  if (playersactiondonemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayersActionDoneMessage>(GetArenaForAllocation());
    playersactiondonemessage_ = p;
  }
  return playersactiondonemessage_;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::mutable_playersactiondonemessage() {
  ::PlayersActionDoneMessage* _msg = _internal_mutable_playersactiondonemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playersActionDoneMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_playersactiondonemessage(::PlayersActionDoneMessage* playersactiondonemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playersactiondonemessage_;
  }
  if (playersactiondonemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayersActionDoneMessage>::GetOwningArena(playersactiondonemessage);
    if (message_arena != submessage_arena) {
      playersactiondonemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playersactiondonemessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000800u;
  } else {
    _has_bits_[1] &= ~0x00000800u;
  }
  playersactiondonemessage_ = playersactiondonemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playersActionDoneMessage)
}

// optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
inline bool PokerTHMessage::_internal_has_dealflopcardsmessage() const {
  bool value = (_has_bits_[1] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || dealflopcardsmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_dealflopcardsmessage() const {
  return _internal_has_dealflopcardsmessage();
}
inline void PokerTHMessage::clear_dealflopcardsmessage() {
  if (dealflopcardsmessage_ != nullptr) dealflopcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00001000u;
}
inline const ::DealFlopCardsMessage& PokerTHMessage::_internal_dealflopcardsmessage() const {
  const ::DealFlopCardsMessage* p = dealflopcardsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::DealFlopCardsMessage&>(
      ::_DealFlopCardsMessage_default_instance_);
}
inline const ::DealFlopCardsMessage& PokerTHMessage::dealflopcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealFlopCardsMessage)
  return _internal_dealflopcardsmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_dealflopcardsmessage(
    ::DealFlopCardsMessage* dealflopcardsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dealflopcardsmessage_);
  }
  dealflopcardsmessage_ = dealflopcardsmessage;
  if (dealflopcardsmessage) {
    _has_bits_[1] |= 0x00001000u;
  } else {
    _has_bits_[1] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.dealFlopCardsMessage)
}
inline ::DealFlopCardsMessage* PokerTHMessage::release_dealflopcardsmessage() {
  _has_bits_[1] &= ~0x00001000u;
  ::DealFlopCardsMessage* temp = dealflopcardsmessage_;
  dealflopcardsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DealFlopCardsMessage* PokerTHMessage::unsafe_arena_release_dealflopcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dealFlopCardsMessage)
  _has_bits_[1] &= ~0x00001000u;
  ::DealFlopCardsMessage* temp = dealflopcardsmessage_;
  dealflopcardsmessage_ = nullptr;
  return temp;
}
inline ::DealFlopCardsMessage* PokerTHMessage::_internal_mutable_dealflopcardsmessage() {
  _has_bits_[1] |= 0x00001000u;
  if (dealflopcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DealFlopCardsMessage>(GetArenaForAllocation());
    dealflopcardsmessage_ = p;
  }
  return dealflopcardsmessage_;
}
inline ::DealFlopCardsMessage* PokerTHMessage::mutable_dealflopcardsmessage() {
  ::DealFlopCardsMessage* _msg = _internal_mutable_dealflopcardsmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealFlopCardsMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_dealflopcardsmessage(::DealFlopCardsMessage* dealflopcardsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dealflopcardsmessage_;
  }
  if (dealflopcardsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DealFlopCardsMessage>::GetOwningArena(dealflopcardsmessage);
    if (message_arena != submessage_arena) {
      dealflopcardsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dealflopcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00001000u;
  } else {
    _has_bits_[1] &= ~0x00001000u;
  }
  dealflopcardsmessage_ = dealflopcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealFlopCardsMessage)
}

// optional .DealTurnCardMessage dealTurnCardMessage = 47;
inline bool PokerTHMessage::_internal_has_dealturncardmessage() const {
  bool value = (_has_bits_[1] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || dealturncardmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_dealturncardmessage() const {
  return _internal_has_dealturncardmessage();
}
inline void PokerTHMessage::clear_dealturncardmessage() {
  if (dealturncardmessage_ != nullptr) dealturncardmessage_->Clear();
  _has_bits_[1] &= ~0x00002000u;
}
inline const ::DealTurnCardMessage& PokerTHMessage::_internal_dealturncardmessage() const {
  const ::DealTurnCardMessage* p = dealturncardmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::DealTurnCardMessage&>(
      ::_DealTurnCardMessage_default_instance_);
}
inline const ::DealTurnCardMessage& PokerTHMessage::dealturncardmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealTurnCardMessage)
  return _internal_dealturncardmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_dealturncardmessage(
    ::DealTurnCardMessage* dealturncardmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dealturncardmessage_);
  }
  dealturncardmessage_ = dealturncardmessage;
  if (dealturncardmessage) {
    _has_bits_[1] |= 0x00002000u;
  } else {
    _has_bits_[1] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.dealTurnCardMessage)
}
inline ::DealTurnCardMessage* PokerTHMessage::release_dealturncardmessage() {
  _has_bits_[1] &= ~0x00002000u;
  ::DealTurnCardMessage* temp = dealturncardmessage_;
  dealturncardmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DealTurnCardMessage* PokerTHMessage::unsafe_arena_release_dealturncardmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dealTurnCardMessage)
  _has_bits_[1] &= ~0x00002000u;
  ::DealTurnCardMessage* temp = dealturncardmessage_;
  dealturncardmessage_ = nullptr;
  return temp;
}
inline ::DealTurnCardMessage* PokerTHMessage::_internal_mutable_dealturncardmessage() {
  _has_bits_[1] |= 0x00002000u;
  if (dealturncardmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DealTurnCardMessage>(GetArenaForAllocation());
    dealturncardmessage_ = p;
  }
  return dealturncardmessage_;
}
inline ::DealTurnCardMessage* PokerTHMessage::mutable_dealturncardmessage() {
  ::DealTurnCardMessage* _msg = _internal_mutable_dealturncardmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealTurnCardMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_dealturncardmessage(::DealTurnCardMessage* dealturncardmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dealturncardmessage_;
  }
  if (dealturncardmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DealTurnCardMessage>::GetOwningArena(dealturncardmessage);
    if (message_arena != submessage_arena) {
      dealturncardmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dealturncardmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00002000u;
  } else {
    _has_bits_[1] &= ~0x00002000u;
  }
  dealturncardmessage_ = dealturncardmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealTurnCardMessage)
}

// optional .DealRiverCardMessage dealRiverCardMessage = 48;
inline bool PokerTHMessage::_internal_has_dealrivercardmessage() const {
  bool value = (_has_bits_[1] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || dealrivercardmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_dealrivercardmessage() const {
  return _internal_has_dealrivercardmessage();
}
inline void PokerTHMessage::clear_dealrivercardmessage() {
  if (dealrivercardmessage_ != nullptr) dealrivercardmessage_->Clear();
  _has_bits_[1] &= ~0x00004000u;
}
inline const ::DealRiverCardMessage& PokerTHMessage::_internal_dealrivercardmessage() const {
  const ::DealRiverCardMessage* p = dealrivercardmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::DealRiverCardMessage&>(
      ::_DealRiverCardMessage_default_instance_);
}
inline const ::DealRiverCardMessage& PokerTHMessage::dealrivercardmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealRiverCardMessage)
  return _internal_dealrivercardmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_dealrivercardmessage(
    ::DealRiverCardMessage* dealrivercardmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dealrivercardmessage_);
  }
  dealrivercardmessage_ = dealrivercardmessage;
  if (dealrivercardmessage) {
    _has_bits_[1] |= 0x00004000u;
  } else {
    _has_bits_[1] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.dealRiverCardMessage)
}
inline ::DealRiverCardMessage* PokerTHMessage::release_dealrivercardmessage() {
  _has_bits_[1] &= ~0x00004000u;
  ::DealRiverCardMessage* temp = dealrivercardmessage_;
  dealrivercardmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DealRiverCardMessage* PokerTHMessage::unsafe_arena_release_dealrivercardmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dealRiverCardMessage)
  _has_bits_[1] &= ~0x00004000u;
  ::DealRiverCardMessage* temp = dealrivercardmessage_;
  dealrivercardmessage_ = nullptr;
  return temp;
}
inline ::DealRiverCardMessage* PokerTHMessage::_internal_mutable_dealrivercardmessage() {
  _has_bits_[1] |= 0x00004000u;
  if (dealrivercardmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DealRiverCardMessage>(GetArenaForAllocation());
    dealrivercardmessage_ = p;
  }
  return dealrivercardmessage_;
}
inline ::DealRiverCardMessage* PokerTHMessage::mutable_dealrivercardmessage() {
  ::DealRiverCardMessage* _msg = _internal_mutable_dealrivercardmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealRiverCardMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_dealrivercardmessage(::DealRiverCardMessage* dealrivercardmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dealrivercardmessage_;
  }
  if (dealrivercardmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DealRiverCardMessage>::GetOwningArena(dealrivercardmessage);
    if (message_arena != submessage_arena) {
      dealrivercardmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dealrivercardmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00004000u;
  } else {
    _has_bits_[1] &= ~0x00004000u;
  }
  dealrivercardmessage_ = dealrivercardmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealRiverCardMessage)
}

// optional .AllInShowCardsMessage allInShowCardsMessage = 49;
inline bool PokerTHMessage::_internal_has_allinshowcardsmessage() const {
  bool value = (_has_bits_[1] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || allinshowcardsmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_allinshowcardsmessage() const {
  return _internal_has_allinshowcardsmessage();
}
inline void PokerTHMessage::clear_allinshowcardsmessage() {
  if (allinshowcardsmessage_ != nullptr) allinshowcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00008000u;
}
inline const ::AllInShowCardsMessage& PokerTHMessage::_internal_allinshowcardsmessage() const {
  const ::AllInShowCardsMessage* p = allinshowcardsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AllInShowCardsMessage&>(
      ::_AllInShowCardsMessage_default_instance_);
}
inline const ::AllInShowCardsMessage& PokerTHMessage::allinshowcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.allInShowCardsMessage)
  return _internal_allinshowcardsmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_allinshowcardsmessage(
    ::AllInShowCardsMessage* allinshowcardsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(allinshowcardsmessage_);
  }
  allinshowcardsmessage_ = allinshowcardsmessage;
  if (allinshowcardsmessage) {
    _has_bits_[1] |= 0x00008000u;
  } else {
    _has_bits_[1] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.allInShowCardsMessage)
}
inline ::AllInShowCardsMessage* PokerTHMessage::release_allinshowcardsmessage() {
  _has_bits_[1] &= ~0x00008000u;
  ::AllInShowCardsMessage* temp = allinshowcardsmessage_;
  allinshowcardsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AllInShowCardsMessage* PokerTHMessage::unsafe_arena_release_allinshowcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.allInShowCardsMessage)
  _has_bits_[1] &= ~0x00008000u;
  ::AllInShowCardsMessage* temp = allinshowcardsmessage_;
  allinshowcardsmessage_ = nullptr;
  return temp;
}
inline ::AllInShowCardsMessage* PokerTHMessage::_internal_mutable_allinshowcardsmessage() {
  _has_bits_[1] |= 0x00008000u;
  if (allinshowcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AllInShowCardsMessage>(GetArenaForAllocation());
    allinshowcardsmessage_ = p;
  }
  return allinshowcardsmessage_;
}
inline ::AllInShowCardsMessage* PokerTHMessage::mutable_allinshowcardsmessage() {
  ::AllInShowCardsMessage* _msg = _internal_mutable_allinshowcardsmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.allInShowCardsMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_allinshowcardsmessage(::AllInShowCardsMessage* allinshowcardsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete allinshowcardsmessage_;
  }
  if (allinshowcardsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AllInShowCardsMessage>::GetOwningArena(allinshowcardsmessage);
    if (message_arena != submessage_arena) {
      allinshowcardsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allinshowcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00008000u;
  } else {
    _has_bits_[1] &= ~0x00008000u;
  }
  allinshowcardsmessage_ = allinshowcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.allInShowCardsMessage)
}

// optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
inline bool PokerTHMessage::_internal_has_endofhandshowcardsmessage() const {
  bool value = (_has_bits_[1] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || endofhandshowcardsmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_endofhandshowcardsmessage() const {
  return _internal_has_endofhandshowcardsmessage();
}
inline void PokerTHMessage::clear_endofhandshowcardsmessage() {
  if (endofhandshowcardsmessage_ != nullptr) endofhandshowcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00010000u;
}
inline const ::EndOfHandShowCardsMessage& PokerTHMessage::_internal_endofhandshowcardsmessage() const {
  const ::EndOfHandShowCardsMessage* p = endofhandshowcardsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::EndOfHandShowCardsMessage&>(
      ::_EndOfHandShowCardsMessage_default_instance_);
}
inline const ::EndOfHandShowCardsMessage& PokerTHMessage::endofhandshowcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfHandShowCardsMessage)
  return _internal_endofhandshowcardsmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_endofhandshowcardsmessage(
    ::EndOfHandShowCardsMessage* endofhandshowcardsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endofhandshowcardsmessage_);
  }
  endofhandshowcardsmessage_ = endofhandshowcardsmessage;
  if (endofhandshowcardsmessage) {
    _has_bits_[1] |= 0x00010000u;
  } else {
    _has_bits_[1] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.endOfHandShowCardsMessage)
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::release_endofhandshowcardsmessage() {
  _has_bits_[1] &= ~0x00010000u;
  ::EndOfHandShowCardsMessage* temp = endofhandshowcardsmessage_;
  endofhandshowcardsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::unsafe_arena_release_endofhandshowcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endOfHandShowCardsMessage)
  _has_bits_[1] &= ~0x00010000u;
  ::EndOfHandShowCardsMessage* temp = endofhandshowcardsmessage_;
  endofhandshowcardsmessage_ = nullptr;
  return temp;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::_internal_mutable_endofhandshowcardsmessage() {
  _has_bits_[1] |= 0x00010000u;
  if (endofhandshowcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndOfHandShowCardsMessage>(GetArenaForAllocation());
    endofhandshowcardsmessage_ = p;
  }
  return endofhandshowcardsmessage_;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::mutable_endofhandshowcardsmessage() {
  ::EndOfHandShowCardsMessage* _msg = _internal_mutable_endofhandshowcardsmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfHandShowCardsMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_endofhandshowcardsmessage(::EndOfHandShowCardsMessage* endofhandshowcardsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endofhandshowcardsmessage_;
  }
  if (endofhandshowcardsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EndOfHandShowCardsMessage>::GetOwningArena(endofhandshowcardsmessage);
    if (message_arena != submessage_arena) {
      endofhandshowcardsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endofhandshowcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00010000u;
  } else {
    _has_bits_[1] &= ~0x00010000u;
  }
  endofhandshowcardsmessage_ = endofhandshowcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfHandShowCardsMessage)
}

// optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
inline bool PokerTHMessage::_internal_has_endofhandhidecardsmessage() const {
  bool value = (_has_bits_[1] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || endofhandhidecardsmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_endofhandhidecardsmessage() const {
  return _internal_has_endofhandhidecardsmessage();
}
inline void PokerTHMessage::clear_endofhandhidecardsmessage() {
  if (endofhandhidecardsmessage_ != nullptr) endofhandhidecardsmessage_->Clear();
  _has_bits_[1] &= ~0x00020000u;
}
inline const ::EndOfHandHideCardsMessage& PokerTHMessage::_internal_endofhandhidecardsmessage() const {
  const ::EndOfHandHideCardsMessage* p = endofhandhidecardsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::EndOfHandHideCardsMessage&>(
      ::_EndOfHandHideCardsMessage_default_instance_);
}
inline const ::EndOfHandHideCardsMessage& PokerTHMessage::endofhandhidecardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfHandHideCardsMessage)
  return _internal_endofhandhidecardsmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_endofhandhidecardsmessage(
    ::EndOfHandHideCardsMessage* endofhandhidecardsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endofhandhidecardsmessage_);
  }
  endofhandhidecardsmessage_ = endofhandhidecardsmessage;
  if (endofhandhidecardsmessage) {
    _has_bits_[1] |= 0x00020000u;
  } else {
    _has_bits_[1] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.endOfHandHideCardsMessage)
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::release_endofhandhidecardsmessage() {
  _has_bits_[1] &= ~0x00020000u;
  ::EndOfHandHideCardsMessage* temp = endofhandhidecardsmessage_;
  endofhandhidecardsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::unsafe_arena_release_endofhandhidecardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endOfHandHideCardsMessage)
  _has_bits_[1] &= ~0x00020000u;
  ::EndOfHandHideCardsMessage* temp = endofhandhidecardsmessage_;
  endofhandhidecardsmessage_ = nullptr;
  return temp;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::_internal_mutable_endofhandhidecardsmessage() {
  _has_bits_[1] |= 0x00020000u;
  if (endofhandhidecardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndOfHandHideCardsMessage>(GetArenaForAllocation());
    endofhandhidecardsmessage_ = p;
  }
  return endofhandhidecardsmessage_;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::mutable_endofhandhidecardsmessage() {
  ::EndOfHandHideCardsMessage* _msg = _internal_mutable_endofhandhidecardsmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfHandHideCardsMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_endofhandhidecardsmessage(::EndOfHandHideCardsMessage* endofhandhidecardsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endofhandhidecardsmessage_;
  }
  if (endofhandhidecardsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EndOfHandHideCardsMessage>::GetOwningArena(endofhandhidecardsmessage);
    if (message_arena != submessage_arena) {
      endofhandhidecardsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endofhandhidecardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00020000u;
  } else {
    _has_bits_[1] &= ~0x00020000u;
  }
  endofhandhidecardsmessage_ = endofhandhidecardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfHandHideCardsMessage)
}

// optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
inline bool PokerTHMessage::_internal_has_showmycardsrequestmessage() const {
  bool value = (_has_bits_[1] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || showmycardsrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_showmycardsrequestmessage() const {
  return _internal_has_showmycardsrequestmessage();
}
inline void PokerTHMessage::clear_showmycardsrequestmessage() {
  if (showmycardsrequestmessage_ != nullptr) showmycardsrequestmessage_->Clear();
  _has_bits_[1] &= ~0x00040000u;
}
inline const ::ShowMyCardsRequestMessage& PokerTHMessage::_internal_showmycardsrequestmessage() const {
  const ::ShowMyCardsRequestMessage* p = showmycardsrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShowMyCardsRequestMessage&>(
      ::_ShowMyCardsRequestMessage_default_instance_);
}
inline const ::ShowMyCardsRequestMessage& PokerTHMessage::showmycardsrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.showMyCardsRequestMessage)
  return _internal_showmycardsrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_showmycardsrequestmessage(
    ::ShowMyCardsRequestMessage* showmycardsrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(showmycardsrequestmessage_);
  }
  showmycardsrequestmessage_ = showmycardsrequestmessage;
  if (showmycardsrequestmessage) {
    _has_bits_[1] |= 0x00040000u;
  } else {
    _has_bits_[1] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.showMyCardsRequestMessage)
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::release_showmycardsrequestmessage() {
  _has_bits_[1] &= ~0x00040000u;
  ::ShowMyCardsRequestMessage* temp = showmycardsrequestmessage_;
  showmycardsrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::unsafe_arena_release_showmycardsrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.showMyCardsRequestMessage)
  _has_bits_[1] &= ~0x00040000u;
  ::ShowMyCardsRequestMessage* temp = showmycardsrequestmessage_;
  showmycardsrequestmessage_ = nullptr;
  return temp;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::_internal_mutable_showmycardsrequestmessage() {
  _has_bits_[1] |= 0x00040000u;
  if (showmycardsrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShowMyCardsRequestMessage>(GetArenaForAllocation());
    showmycardsrequestmessage_ = p;
  }
  return showmycardsrequestmessage_;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::mutable_showmycardsrequestmessage() {
  ::ShowMyCardsRequestMessage* _msg = _internal_mutable_showmycardsrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.showMyCardsRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_showmycardsrequestmessage(::ShowMyCardsRequestMessage* showmycardsrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete showmycardsrequestmessage_;
  }
  if (showmycardsrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ShowMyCardsRequestMessage>::GetOwningArena(showmycardsrequestmessage);
    if (message_arena != submessage_arena) {
      showmycardsrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, showmycardsrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00040000u;
  } else {
    _has_bits_[1] &= ~0x00040000u;
  }
  showmycardsrequestmessage_ = showmycardsrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.showMyCardsRequestMessage)
}

// optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
inline bool PokerTHMessage::_internal_has_afterhandshowcardsmessage() const {
  bool value = (_has_bits_[1] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || afterhandshowcardsmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_afterhandshowcardsmessage() const {
  return _internal_has_afterhandshowcardsmessage();
}
inline void PokerTHMessage::clear_afterhandshowcardsmessage() {
  if (afterhandshowcardsmessage_ != nullptr) afterhandshowcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00080000u;
}
inline const ::AfterHandShowCardsMessage& PokerTHMessage::_internal_afterhandshowcardsmessage() const {
  const ::AfterHandShowCardsMessage* p = afterhandshowcardsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AfterHandShowCardsMessage&>(
      ::_AfterHandShowCardsMessage_default_instance_);
}
inline const ::AfterHandShowCardsMessage& PokerTHMessage::afterhandshowcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.afterHandShowCardsMessage)
  return _internal_afterhandshowcardsmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_afterhandshowcardsmessage(
    ::AfterHandShowCardsMessage* afterhandshowcardsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(afterhandshowcardsmessage_);
  }
  afterhandshowcardsmessage_ = afterhandshowcardsmessage;
  if (afterhandshowcardsmessage) {
    _has_bits_[1] |= 0x00080000u;
  } else {
    _has_bits_[1] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.afterHandShowCardsMessage)
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::release_afterhandshowcardsmessage() {
  _has_bits_[1] &= ~0x00080000u;
  ::AfterHandShowCardsMessage* temp = afterhandshowcardsmessage_;
  afterhandshowcardsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::unsafe_arena_release_afterhandshowcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.afterHandShowCardsMessage)
  _has_bits_[1] &= ~0x00080000u;
  ::AfterHandShowCardsMessage* temp = afterhandshowcardsmessage_;
  afterhandshowcardsmessage_ = nullptr;
  return temp;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::_internal_mutable_afterhandshowcardsmessage() {
  _has_bits_[1] |= 0x00080000u;
  if (afterhandshowcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AfterHandShowCardsMessage>(GetArenaForAllocation());
    afterhandshowcardsmessage_ = p;
  }
  return afterhandshowcardsmessage_;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::mutable_afterhandshowcardsmessage() {
  ::AfterHandShowCardsMessage* _msg = _internal_mutable_afterhandshowcardsmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.afterHandShowCardsMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_afterhandshowcardsmessage(::AfterHandShowCardsMessage* afterhandshowcardsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete afterhandshowcardsmessage_;
  }
  if (afterhandshowcardsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AfterHandShowCardsMessage>::GetOwningArena(afterhandshowcardsmessage);
    if (message_arena != submessage_arena) {
      afterhandshowcardsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, afterhandshowcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00080000u;
  } else {
    _has_bits_[1] &= ~0x00080000u;
  }
  afterhandshowcardsmessage_ = afterhandshowcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.afterHandShowCardsMessage)
}

// optional .EndOfGameMessage endOfGameMessage = 54;
inline bool PokerTHMessage::_internal_has_endofgamemessage() const {
  bool value = (_has_bits_[1] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || endofgamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_endofgamemessage() const {
  return _internal_has_endofgamemessage();
}
inline void PokerTHMessage::clear_endofgamemessage() {
  if (endofgamemessage_ != nullptr) endofgamemessage_->Clear();
  _has_bits_[1] &= ~0x00100000u;
}
inline const ::EndOfGameMessage& PokerTHMessage::_internal_endofgamemessage() const {
  const ::EndOfGameMessage* p = endofgamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::EndOfGameMessage&>(
      ::_EndOfGameMessage_default_instance_);
}
inline const ::EndOfGameMessage& PokerTHMessage::endofgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfGameMessage)
  return _internal_endofgamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_endofgamemessage(
    ::EndOfGameMessage* endofgamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endofgamemessage_);
  }
  endofgamemessage_ = endofgamemessage;
  if (endofgamemessage) {
    _has_bits_[1] |= 0x00100000u;
  } else {
    _has_bits_[1] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.endOfGameMessage)
}
inline ::EndOfGameMessage* PokerTHMessage::release_endofgamemessage() {
  _has_bits_[1] &= ~0x00100000u;
  ::EndOfGameMessage* temp = endofgamemessage_;
  endofgamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EndOfGameMessage* PokerTHMessage::unsafe_arena_release_endofgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endOfGameMessage)
  _has_bits_[1] &= ~0x00100000u;
  ::EndOfGameMessage* temp = endofgamemessage_;
  endofgamemessage_ = nullptr;
  return temp;
}
inline ::EndOfGameMessage* PokerTHMessage::_internal_mutable_endofgamemessage() {
  _has_bits_[1] |= 0x00100000u;
  if (endofgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndOfGameMessage>(GetArenaForAllocation());
    endofgamemessage_ = p;
  }
  return endofgamemessage_;
}
inline ::EndOfGameMessage* PokerTHMessage::mutable_endofgamemessage() {
  ::EndOfGameMessage* _msg = _internal_mutable_endofgamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_endofgamemessage(::EndOfGameMessage* endofgamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endofgamemessage_;
  }
  if (endofgamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EndOfGameMessage>::GetOwningArena(endofgamemessage);
    if (message_arena != submessage_arena) {
      endofgamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endofgamemessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00100000u;
  } else {
    _has_bits_[1] &= ~0x00100000u;
  }
  endofgamemessage_ = endofgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfGameMessage)
}

// optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
inline bool PokerTHMessage::_internal_has_playeridchangedmessage() const {
  bool value = (_has_bits_[1] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || playeridchangedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_playeridchangedmessage() const {
  return _internal_has_playeridchangedmessage();
}
inline void PokerTHMessage::clear_playeridchangedmessage() {
  if (playeridchangedmessage_ != nullptr) playeridchangedmessage_->Clear();
  _has_bits_[1] &= ~0x00200000u;
}
inline const ::PlayerIdChangedMessage& PokerTHMessage::_internal_playeridchangedmessage() const {
  const ::PlayerIdChangedMessage* p = playeridchangedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerIdChangedMessage&>(
      ::_PlayerIdChangedMessage_default_instance_);
}
inline const ::PlayerIdChangedMessage& PokerTHMessage::playeridchangedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerIdChangedMessage)
  return _internal_playeridchangedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_playeridchangedmessage(
    ::PlayerIdChangedMessage* playeridchangedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeridchangedmessage_);
  }
  playeridchangedmessage_ = playeridchangedmessage;
  if (playeridchangedmessage) {
    _has_bits_[1] |= 0x00200000u;
  } else {
    _has_bits_[1] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.playerIdChangedMessage)
}
inline ::PlayerIdChangedMessage* PokerTHMessage::release_playeridchangedmessage() {
  _has_bits_[1] &= ~0x00200000u;
  ::PlayerIdChangedMessage* temp = playeridchangedmessage_;
  playeridchangedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::unsafe_arena_release_playeridchangedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerIdChangedMessage)
  _has_bits_[1] &= ~0x00200000u;
  ::PlayerIdChangedMessage* temp = playeridchangedmessage_;
  playeridchangedmessage_ = nullptr;
  return temp;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::_internal_mutable_playeridchangedmessage() {
  _has_bits_[1] |= 0x00200000u;
  if (playeridchangedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerIdChangedMessage>(GetArenaForAllocation());
    playeridchangedmessage_ = p;
  }
  return playeridchangedmessage_;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::mutable_playeridchangedmessage() {
  ::PlayerIdChangedMessage* _msg = _internal_mutable_playeridchangedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerIdChangedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_playeridchangedmessage(::PlayerIdChangedMessage* playeridchangedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playeridchangedmessage_;
  }
  if (playeridchangedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PlayerIdChangedMessage>::GetOwningArena(playeridchangedmessage);
    if (message_arena != submessage_arena) {
      playeridchangedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playeridchangedmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00200000u;
  } else {
    _has_bits_[1] &= ~0x00200000u;
  }
  playeridchangedmessage_ = playeridchangedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerIdChangedMessage)
}

// optional .AskKickPlayerMessage askKickPlayerMessage = 56;
inline bool PokerTHMessage::_internal_has_askkickplayermessage() const {
  bool value = (_has_bits_[1] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || askkickplayermessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_askkickplayermessage() const {
  return _internal_has_askkickplayermessage();
}
inline void PokerTHMessage::clear_askkickplayermessage() {
  if (askkickplayermessage_ != nullptr) askkickplayermessage_->Clear();
  _has_bits_[1] &= ~0x00400000u;
}
inline const ::AskKickPlayerMessage& PokerTHMessage::_internal_askkickplayermessage() const {
  const ::AskKickPlayerMessage* p = askkickplayermessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AskKickPlayerMessage&>(
      ::_AskKickPlayerMessage_default_instance_);
}
inline const ::AskKickPlayerMessage& PokerTHMessage::askkickplayermessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.askKickPlayerMessage)
  return _internal_askkickplayermessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_askkickplayermessage(
    ::AskKickPlayerMessage* askkickplayermessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(askkickplayermessage_);
  }
  askkickplayermessage_ = askkickplayermessage;
  if (askkickplayermessage) {
    _has_bits_[1] |= 0x00400000u;
  } else {
    _has_bits_[1] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.askKickPlayerMessage)
}
inline ::AskKickPlayerMessage* PokerTHMessage::release_askkickplayermessage() {
  _has_bits_[1] &= ~0x00400000u;
  ::AskKickPlayerMessage* temp = askkickplayermessage_;
  askkickplayermessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AskKickPlayerMessage* PokerTHMessage::unsafe_arena_release_askkickplayermessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.askKickPlayerMessage)
  _has_bits_[1] &= ~0x00400000u;
  ::AskKickPlayerMessage* temp = askkickplayermessage_;
  askkickplayermessage_ = nullptr;
  return temp;
}
inline ::AskKickPlayerMessage* PokerTHMessage::_internal_mutable_askkickplayermessage() {
  _has_bits_[1] |= 0x00400000u;
  if (askkickplayermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AskKickPlayerMessage>(GetArenaForAllocation());
    askkickplayermessage_ = p;
  }
  return askkickplayermessage_;
}
inline ::AskKickPlayerMessage* PokerTHMessage::mutable_askkickplayermessage() {
  ::AskKickPlayerMessage* _msg = _internal_mutable_askkickplayermessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.askKickPlayerMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_askkickplayermessage(::AskKickPlayerMessage* askkickplayermessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete askkickplayermessage_;
  }
  if (askkickplayermessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AskKickPlayerMessage>::GetOwningArena(askkickplayermessage);
    if (message_arena != submessage_arena) {
      askkickplayermessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, askkickplayermessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00400000u;
  } else {
    _has_bits_[1] &= ~0x00400000u;
  }
  askkickplayermessage_ = askkickplayermessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.askKickPlayerMessage)
}

// optional .AskKickDeniedMessage askKickDeniedMessage = 57;
inline bool PokerTHMessage::_internal_has_askkickdeniedmessage() const {
  bool value = (_has_bits_[1] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || askkickdeniedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_askkickdeniedmessage() const {
  return _internal_has_askkickdeniedmessage();
}
inline void PokerTHMessage::clear_askkickdeniedmessage() {
  if (askkickdeniedmessage_ != nullptr) askkickdeniedmessage_->Clear();
  _has_bits_[1] &= ~0x00800000u;
}
inline const ::AskKickDeniedMessage& PokerTHMessage::_internal_askkickdeniedmessage() const {
  const ::AskKickDeniedMessage* p = askkickdeniedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AskKickDeniedMessage&>(
      ::_AskKickDeniedMessage_default_instance_);
}
inline const ::AskKickDeniedMessage& PokerTHMessage::askkickdeniedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.askKickDeniedMessage)
  return _internal_askkickdeniedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_askkickdeniedmessage(
    ::AskKickDeniedMessage* askkickdeniedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(askkickdeniedmessage_);
  }
  askkickdeniedmessage_ = askkickdeniedmessage;
  if (askkickdeniedmessage) {
    _has_bits_[1] |= 0x00800000u;
  } else {
    _has_bits_[1] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.askKickDeniedMessage)
}
inline ::AskKickDeniedMessage* PokerTHMessage::release_askkickdeniedmessage() {
  _has_bits_[1] &= ~0x00800000u;
  ::AskKickDeniedMessage* temp = askkickdeniedmessage_;
  askkickdeniedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AskKickDeniedMessage* PokerTHMessage::unsafe_arena_release_askkickdeniedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.askKickDeniedMessage)
  _has_bits_[1] &= ~0x00800000u;
  ::AskKickDeniedMessage* temp = askkickdeniedmessage_;
  askkickdeniedmessage_ = nullptr;
  return temp;
}
inline ::AskKickDeniedMessage* PokerTHMessage::_internal_mutable_askkickdeniedmessage() {
  _has_bits_[1] |= 0x00800000u;
  if (askkickdeniedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AskKickDeniedMessage>(GetArenaForAllocation());
    askkickdeniedmessage_ = p;
  }
  return askkickdeniedmessage_;
}
inline ::AskKickDeniedMessage* PokerTHMessage::mutable_askkickdeniedmessage() {
  ::AskKickDeniedMessage* _msg = _internal_mutable_askkickdeniedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.askKickDeniedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_askkickdeniedmessage(::AskKickDeniedMessage* askkickdeniedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete askkickdeniedmessage_;
  }
  if (askkickdeniedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AskKickDeniedMessage>::GetOwningArena(askkickdeniedmessage);
    if (message_arena != submessage_arena) {
      askkickdeniedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, askkickdeniedmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00800000u;
  } else {
    _has_bits_[1] &= ~0x00800000u;
  }
  askkickdeniedmessage_ = askkickdeniedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.askKickDeniedMessage)
}

// optional .StartKickPetitionMessage startKickPetitionMessage = 58;
inline bool PokerTHMessage::_internal_has_startkickpetitionmessage() const {
  bool value = (_has_bits_[1] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || startkickpetitionmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_startkickpetitionmessage() const {
  return _internal_has_startkickpetitionmessage();
}
inline void PokerTHMessage::clear_startkickpetitionmessage() {
  if (startkickpetitionmessage_ != nullptr) startkickpetitionmessage_->Clear();
  _has_bits_[1] &= ~0x01000000u;
}
inline const ::StartKickPetitionMessage& PokerTHMessage::_internal_startkickpetitionmessage() const {
  const ::StartKickPetitionMessage* p = startkickpetitionmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::StartKickPetitionMessage&>(
      ::_StartKickPetitionMessage_default_instance_);
}
inline const ::StartKickPetitionMessage& PokerTHMessage::startkickpetitionmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.startKickPetitionMessage)
  return _internal_startkickpetitionmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_startkickpetitionmessage(
    ::StartKickPetitionMessage* startkickpetitionmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(startkickpetitionmessage_);
  }
  startkickpetitionmessage_ = startkickpetitionmessage;
  if (startkickpetitionmessage) {
    _has_bits_[1] |= 0x01000000u;
  } else {
    _has_bits_[1] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.startKickPetitionMessage)
}
inline ::StartKickPetitionMessage* PokerTHMessage::release_startkickpetitionmessage() {
  _has_bits_[1] &= ~0x01000000u;
  ::StartKickPetitionMessage* temp = startkickpetitionmessage_;
  startkickpetitionmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StartKickPetitionMessage* PokerTHMessage::unsafe_arena_release_startkickpetitionmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.startKickPetitionMessage)
  _has_bits_[1] &= ~0x01000000u;
  ::StartKickPetitionMessage* temp = startkickpetitionmessage_;
  startkickpetitionmessage_ = nullptr;
  return temp;
}
inline ::StartKickPetitionMessage* PokerTHMessage::_internal_mutable_startkickpetitionmessage() {
  _has_bits_[1] |= 0x01000000u;
  if (startkickpetitionmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartKickPetitionMessage>(GetArenaForAllocation());
    startkickpetitionmessage_ = p;
  }
  return startkickpetitionmessage_;
}
inline ::StartKickPetitionMessage* PokerTHMessage::mutable_startkickpetitionmessage() {
  ::StartKickPetitionMessage* _msg = _internal_mutable_startkickpetitionmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startKickPetitionMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_startkickpetitionmessage(::StartKickPetitionMessage* startkickpetitionmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete startkickpetitionmessage_;
  }
  if (startkickpetitionmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StartKickPetitionMessage>::GetOwningArena(startkickpetitionmessage);
    if (message_arena != submessage_arena) {
      startkickpetitionmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startkickpetitionmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x01000000u;
  } else {
    _has_bits_[1] &= ~0x01000000u;
  }
  startkickpetitionmessage_ = startkickpetitionmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startKickPetitionMessage)
}

// optional .VoteKickRequestMessage voteKickRequestMessage = 59;
inline bool PokerTHMessage::_internal_has_votekickrequestmessage() const {
  bool value = (_has_bits_[1] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || votekickrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_votekickrequestmessage() const {
  return _internal_has_votekickrequestmessage();
}
inline void PokerTHMessage::clear_votekickrequestmessage() {
  if (votekickrequestmessage_ != nullptr) votekickrequestmessage_->Clear();
  _has_bits_[1] &= ~0x02000000u;
}
inline const ::VoteKickRequestMessage& PokerTHMessage::_internal_votekickrequestmessage() const {
  const ::VoteKickRequestMessage* p = votekickrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::VoteKickRequestMessage&>(
      ::_VoteKickRequestMessage_default_instance_);
}
inline const ::VoteKickRequestMessage& PokerTHMessage::votekickrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.voteKickRequestMessage)
  return _internal_votekickrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_votekickrequestmessage(
    ::VoteKickRequestMessage* votekickrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(votekickrequestmessage_);
  }
  votekickrequestmessage_ = votekickrequestmessage;
  if (votekickrequestmessage) {
    _has_bits_[1] |= 0x02000000u;
  } else {
    _has_bits_[1] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.voteKickRequestMessage)
}
inline ::VoteKickRequestMessage* PokerTHMessage::release_votekickrequestmessage() {
  _has_bits_[1] &= ~0x02000000u;
  ::VoteKickRequestMessage* temp = votekickrequestmessage_;
  votekickrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VoteKickRequestMessage* PokerTHMessage::unsafe_arena_release_votekickrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.voteKickRequestMessage)
  _has_bits_[1] &= ~0x02000000u;
  ::VoteKickRequestMessage* temp = votekickrequestmessage_;
  votekickrequestmessage_ = nullptr;
  return temp;
}
inline ::VoteKickRequestMessage* PokerTHMessage::_internal_mutable_votekickrequestmessage() {
  _has_bits_[1] |= 0x02000000u;
  if (votekickrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::VoteKickRequestMessage>(GetArenaForAllocation());
    votekickrequestmessage_ = p;
  }
  return votekickrequestmessage_;
}
inline ::VoteKickRequestMessage* PokerTHMessage::mutable_votekickrequestmessage() {
  ::VoteKickRequestMessage* _msg = _internal_mutable_votekickrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.voteKickRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_votekickrequestmessage(::VoteKickRequestMessage* votekickrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete votekickrequestmessage_;
  }
  if (votekickrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::VoteKickRequestMessage>::GetOwningArena(votekickrequestmessage);
    if (message_arena != submessage_arena) {
      votekickrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, votekickrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x02000000u;
  } else {
    _has_bits_[1] &= ~0x02000000u;
  }
  votekickrequestmessage_ = votekickrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.voteKickRequestMessage)
}

// optional .VoteKickReplyMessage voteKickReplyMessage = 60;
inline bool PokerTHMessage::_internal_has_votekickreplymessage() const {
  bool value = (_has_bits_[1] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || votekickreplymessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_votekickreplymessage() const {
  return _internal_has_votekickreplymessage();
}
inline void PokerTHMessage::clear_votekickreplymessage() {
  if (votekickreplymessage_ != nullptr) votekickreplymessage_->Clear();
  _has_bits_[1] &= ~0x04000000u;
}
inline const ::VoteKickReplyMessage& PokerTHMessage::_internal_votekickreplymessage() const {
  const ::VoteKickReplyMessage* p = votekickreplymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::VoteKickReplyMessage&>(
      ::_VoteKickReplyMessage_default_instance_);
}
inline const ::VoteKickReplyMessage& PokerTHMessage::votekickreplymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.voteKickReplyMessage)
  return _internal_votekickreplymessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_votekickreplymessage(
    ::VoteKickReplyMessage* votekickreplymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(votekickreplymessage_);
  }
  votekickreplymessage_ = votekickreplymessage;
  if (votekickreplymessage) {
    _has_bits_[1] |= 0x04000000u;
  } else {
    _has_bits_[1] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.voteKickReplyMessage)
}
inline ::VoteKickReplyMessage* PokerTHMessage::release_votekickreplymessage() {
  _has_bits_[1] &= ~0x04000000u;
  ::VoteKickReplyMessage* temp = votekickreplymessage_;
  votekickreplymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VoteKickReplyMessage* PokerTHMessage::unsafe_arena_release_votekickreplymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.voteKickReplyMessage)
  _has_bits_[1] &= ~0x04000000u;
  ::VoteKickReplyMessage* temp = votekickreplymessage_;
  votekickreplymessage_ = nullptr;
  return temp;
}
inline ::VoteKickReplyMessage* PokerTHMessage::_internal_mutable_votekickreplymessage() {
  _has_bits_[1] |= 0x04000000u;
  if (votekickreplymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::VoteKickReplyMessage>(GetArenaForAllocation());
    votekickreplymessage_ = p;
  }
  return votekickreplymessage_;
}
inline ::VoteKickReplyMessage* PokerTHMessage::mutable_votekickreplymessage() {
  ::VoteKickReplyMessage* _msg = _internal_mutable_votekickreplymessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.voteKickReplyMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_votekickreplymessage(::VoteKickReplyMessage* votekickreplymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete votekickreplymessage_;
  }
  if (votekickreplymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::VoteKickReplyMessage>::GetOwningArena(votekickreplymessage);
    if (message_arena != submessage_arena) {
      votekickreplymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, votekickreplymessage, submessage_arena);
    }
    _has_bits_[1] |= 0x04000000u;
  } else {
    _has_bits_[1] &= ~0x04000000u;
  }
  votekickreplymessage_ = votekickreplymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.voteKickReplyMessage)
}

// optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
inline bool PokerTHMessage::_internal_has_kickpetitionupdatemessage() const {
  bool value = (_has_bits_[1] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || kickpetitionupdatemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_kickpetitionupdatemessage() const {
  return _internal_has_kickpetitionupdatemessage();
}
inline void PokerTHMessage::clear_kickpetitionupdatemessage() {
  if (kickpetitionupdatemessage_ != nullptr) kickpetitionupdatemessage_->Clear();
  _has_bits_[1] &= ~0x08000000u;
}
inline const ::KickPetitionUpdateMessage& PokerTHMessage::_internal_kickpetitionupdatemessage() const {
  const ::KickPetitionUpdateMessage* p = kickpetitionupdatemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::KickPetitionUpdateMessage&>(
      ::_KickPetitionUpdateMessage_default_instance_);
}
inline const ::KickPetitionUpdateMessage& PokerTHMessage::kickpetitionupdatemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.kickPetitionUpdateMessage)
  return _internal_kickpetitionupdatemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_kickpetitionupdatemessage(
    ::KickPetitionUpdateMessage* kickpetitionupdatemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kickpetitionupdatemessage_);
  }
  kickpetitionupdatemessage_ = kickpetitionupdatemessage;
  if (kickpetitionupdatemessage) {
    _has_bits_[1] |= 0x08000000u;
  } else {
    _has_bits_[1] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.kickPetitionUpdateMessage)
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::release_kickpetitionupdatemessage() {
  _has_bits_[1] &= ~0x08000000u;
  ::KickPetitionUpdateMessage* temp = kickpetitionupdatemessage_;
  kickpetitionupdatemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::unsafe_arena_release_kickpetitionupdatemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.kickPetitionUpdateMessage)
  _has_bits_[1] &= ~0x08000000u;
  ::KickPetitionUpdateMessage* temp = kickpetitionupdatemessage_;
  kickpetitionupdatemessage_ = nullptr;
  return temp;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::_internal_mutable_kickpetitionupdatemessage() {
  _has_bits_[1] |= 0x08000000u;
  if (kickpetitionupdatemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::KickPetitionUpdateMessage>(GetArenaForAllocation());
    kickpetitionupdatemessage_ = p;
  }
  return kickpetitionupdatemessage_;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::mutable_kickpetitionupdatemessage() {
  ::KickPetitionUpdateMessage* _msg = _internal_mutable_kickpetitionupdatemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.kickPetitionUpdateMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_kickpetitionupdatemessage(::KickPetitionUpdateMessage* kickpetitionupdatemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kickpetitionupdatemessage_;
  }
  if (kickpetitionupdatemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KickPetitionUpdateMessage>::GetOwningArena(kickpetitionupdatemessage);
    if (message_arena != submessage_arena) {
      kickpetitionupdatemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kickpetitionupdatemessage, submessage_arena);
    }
    _has_bits_[1] |= 0x08000000u;
  } else {
    _has_bits_[1] &= ~0x08000000u;
  }
  kickpetitionupdatemessage_ = kickpetitionupdatemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.kickPetitionUpdateMessage)
}

// optional .EndKickPetitionMessage endKickPetitionMessage = 62;
inline bool PokerTHMessage::_internal_has_endkickpetitionmessage() const {
  bool value = (_has_bits_[1] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || endkickpetitionmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_endkickpetitionmessage() const {
  return _internal_has_endkickpetitionmessage();
}
inline void PokerTHMessage::clear_endkickpetitionmessage() {
  if (endkickpetitionmessage_ != nullptr) endkickpetitionmessage_->Clear();
  _has_bits_[1] &= ~0x10000000u;
}
inline const ::EndKickPetitionMessage& PokerTHMessage::_internal_endkickpetitionmessage() const {
  const ::EndKickPetitionMessage* p = endkickpetitionmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::EndKickPetitionMessage&>(
      ::_EndKickPetitionMessage_default_instance_);
}
inline const ::EndKickPetitionMessage& PokerTHMessage::endkickpetitionmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endKickPetitionMessage)
  return _internal_endkickpetitionmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_endkickpetitionmessage(
    ::EndKickPetitionMessage* endkickpetitionmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endkickpetitionmessage_);
  }
  endkickpetitionmessage_ = endkickpetitionmessage;
  if (endkickpetitionmessage) {
    _has_bits_[1] |= 0x10000000u;
  } else {
    _has_bits_[1] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.endKickPetitionMessage)
}
inline ::EndKickPetitionMessage* PokerTHMessage::release_endkickpetitionmessage() {
  _has_bits_[1] &= ~0x10000000u;
  ::EndKickPetitionMessage* temp = endkickpetitionmessage_;
  endkickpetitionmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EndKickPetitionMessage* PokerTHMessage::unsafe_arena_release_endkickpetitionmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endKickPetitionMessage)
  _has_bits_[1] &= ~0x10000000u;
  ::EndKickPetitionMessage* temp = endkickpetitionmessage_;
  endkickpetitionmessage_ = nullptr;
  return temp;
}
inline ::EndKickPetitionMessage* PokerTHMessage::_internal_mutable_endkickpetitionmessage() {
  _has_bits_[1] |= 0x10000000u;
  if (endkickpetitionmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndKickPetitionMessage>(GetArenaForAllocation());
    endkickpetitionmessage_ = p;
  }
  return endkickpetitionmessage_;
}
inline ::EndKickPetitionMessage* PokerTHMessage::mutable_endkickpetitionmessage() {
  ::EndKickPetitionMessage* _msg = _internal_mutable_endkickpetitionmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endKickPetitionMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_endkickpetitionmessage(::EndKickPetitionMessage* endkickpetitionmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endkickpetitionmessage_;
  }
  if (endkickpetitionmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EndKickPetitionMessage>::GetOwningArena(endkickpetitionmessage);
    if (message_arena != submessage_arena) {
      endkickpetitionmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endkickpetitionmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x10000000u;
  } else {
    _has_bits_[1] &= ~0x10000000u;
  }
  endkickpetitionmessage_ = endkickpetitionmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endKickPetitionMessage)
}

// optional .StatisticsMessage statisticsMessage = 63;
inline bool PokerTHMessage::_internal_has_statisticsmessage() const {
  bool value = (_has_bits_[1] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || statisticsmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_statisticsmessage() const {
  return _internal_has_statisticsmessage();
}
inline void PokerTHMessage::clear_statisticsmessage() {
  if (statisticsmessage_ != nullptr) statisticsmessage_->Clear();
  _has_bits_[1] &= ~0x20000000u;
}
inline const ::StatisticsMessage& PokerTHMessage::_internal_statisticsmessage() const {
  const ::StatisticsMessage* p = statisticsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatisticsMessage&>(
      ::_StatisticsMessage_default_instance_);
}
inline const ::StatisticsMessage& PokerTHMessage::statisticsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.statisticsMessage)
  return _internal_statisticsmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_statisticsmessage(
    ::StatisticsMessage* statisticsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statisticsmessage_);
  }
  statisticsmessage_ = statisticsmessage;
  if (statisticsmessage) {
    _has_bits_[1] |= 0x20000000u;
  } else {
    _has_bits_[1] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.statisticsMessage)
}
inline ::StatisticsMessage* PokerTHMessage::release_statisticsmessage() {
  _has_bits_[1] &= ~0x20000000u;
  ::StatisticsMessage* temp = statisticsmessage_;
  statisticsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatisticsMessage* PokerTHMessage::unsafe_arena_release_statisticsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.statisticsMessage)
  _has_bits_[1] &= ~0x20000000u;
  ::StatisticsMessage* temp = statisticsmessage_;
  statisticsmessage_ = nullptr;
  return temp;
}
inline ::StatisticsMessage* PokerTHMessage::_internal_mutable_statisticsmessage() {
  _has_bits_[1] |= 0x20000000u;
  if (statisticsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatisticsMessage>(GetArenaForAllocation());
    statisticsmessage_ = p;
  }
  return statisticsmessage_;
}
inline ::StatisticsMessage* PokerTHMessage::mutable_statisticsmessage() {
  ::StatisticsMessage* _msg = _internal_mutable_statisticsmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.statisticsMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_statisticsmessage(::StatisticsMessage* statisticsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete statisticsmessage_;
  }
  if (statisticsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StatisticsMessage>::GetOwningArena(statisticsmessage);
    if (message_arena != submessage_arena) {
      statisticsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statisticsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x20000000u;
  } else {
    _has_bits_[1] &= ~0x20000000u;
  }
  statisticsmessage_ = statisticsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.statisticsMessage)
}

// optional .ChatRequestMessage chatRequestMessage = 64;
inline bool PokerTHMessage::_internal_has_chatrequestmessage() const {
  bool value = (_has_bits_[1] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || chatrequestmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_chatrequestmessage() const {
  return _internal_has_chatrequestmessage();
}
inline void PokerTHMessage::clear_chatrequestmessage() {
  if (chatrequestmessage_ != nullptr) chatrequestmessage_->Clear();
  _has_bits_[1] &= ~0x40000000u;
}
inline const ::ChatRequestMessage& PokerTHMessage::_internal_chatrequestmessage() const {
  const ::ChatRequestMessage* p = chatrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChatRequestMessage&>(
      ::_ChatRequestMessage_default_instance_);
}
inline const ::ChatRequestMessage& PokerTHMessage::chatrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatRequestMessage)
  return _internal_chatrequestmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_chatrequestmessage(
    ::ChatRequestMessage* chatrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chatrequestmessage_);
  }
  chatrequestmessage_ = chatrequestmessage;
  if (chatrequestmessage) {
    _has_bits_[1] |= 0x40000000u;
  } else {
    _has_bits_[1] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.chatRequestMessage)
}
inline ::ChatRequestMessage* PokerTHMessage::release_chatrequestmessage() {
  _has_bits_[1] &= ~0x40000000u;
  ::ChatRequestMessage* temp = chatrequestmessage_;
  chatrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChatRequestMessage* PokerTHMessage::unsafe_arena_release_chatrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.chatRequestMessage)
  _has_bits_[1] &= ~0x40000000u;
  ::ChatRequestMessage* temp = chatrequestmessage_;
  chatrequestmessage_ = nullptr;
  return temp;
}
inline ::ChatRequestMessage* PokerTHMessage::_internal_mutable_chatrequestmessage() {
  _has_bits_[1] |= 0x40000000u;
  if (chatrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatRequestMessage>(GetArenaForAllocation());
    chatrequestmessage_ = p;
  }
  return chatrequestmessage_;
}
inline ::ChatRequestMessage* PokerTHMessage::mutable_chatrequestmessage() {
  ::ChatRequestMessage* _msg = _internal_mutable_chatrequestmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatRequestMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_chatrequestmessage(::ChatRequestMessage* chatrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chatrequestmessage_;
  }
  if (chatrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ChatRequestMessage>::GetOwningArena(chatrequestmessage);
    if (message_arena != submessage_arena) {
      chatrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x40000000u;
  } else {
    _has_bits_[1] &= ~0x40000000u;
  }
  chatrequestmessage_ = chatrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatRequestMessage)
}

// optional .ChatMessage chatMessage = 65;
inline bool PokerTHMessage::_internal_has_chatmessage() const {
  bool value = (_has_bits_[1] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || chatmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_chatmessage() const {
  return _internal_has_chatmessage();
}
inline void PokerTHMessage::clear_chatmessage() {
  if (chatmessage_ != nullptr) chatmessage_->Clear();
  _has_bits_[1] &= ~0x80000000u;
}
inline const ::ChatMessage& PokerTHMessage::_internal_chatmessage() const {
  const ::ChatMessage* p = chatmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChatMessage&>(
      ::_ChatMessage_default_instance_);
}
inline const ::ChatMessage& PokerTHMessage::chatmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatMessage)
  return _internal_chatmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_chatmessage(
    ::ChatMessage* chatmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chatmessage_);
  }
  chatmessage_ = chatmessage;
  if (chatmessage) {
    _has_bits_[1] |= 0x80000000u;
  } else {
    _has_bits_[1] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.chatMessage)
}
inline ::ChatMessage* PokerTHMessage::release_chatmessage() {
  _has_bits_[1] &= ~0x80000000u;
  ::ChatMessage* temp = chatmessage_;
  chatmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChatMessage* PokerTHMessage::unsafe_arena_release_chatmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.chatMessage)
  _has_bits_[1] &= ~0x80000000u;
  ::ChatMessage* temp = chatmessage_;
  chatmessage_ = nullptr;
  return temp;
}
inline ::ChatMessage* PokerTHMessage::_internal_mutable_chatmessage() {
  _has_bits_[1] |= 0x80000000u;
  if (chatmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatMessage>(GetArenaForAllocation());
    chatmessage_ = p;
  }
  return chatmessage_;
}
inline ::ChatMessage* PokerTHMessage::mutable_chatmessage() {
  ::ChatMessage* _msg = _internal_mutable_chatmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_chatmessage(::ChatMessage* chatmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chatmessage_;
  }
  if (chatmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ChatMessage>::GetOwningArena(chatmessage);
    if (message_arena != submessage_arena) {
      chatmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x80000000u;
  } else {
    _has_bits_[1] &= ~0x80000000u;
  }
  chatmessage_ = chatmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatMessage)
}

// optional .ChatRejectMessage chatRejectMessage = 66;
inline bool PokerTHMessage::_internal_has_chatrejectmessage() const {
  bool value = (_has_bits_[2] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || chatrejectmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_chatrejectmessage() const {
  return _internal_has_chatrejectmessage();
}
inline void PokerTHMessage::clear_chatrejectmessage() {
  if (chatrejectmessage_ != nullptr) chatrejectmessage_->Clear();
  _has_bits_[2] &= ~0x00000001u;
}
inline const ::ChatRejectMessage& PokerTHMessage::_internal_chatrejectmessage() const {
  const ::ChatRejectMessage* p = chatrejectmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChatRejectMessage&>(
      ::_ChatRejectMessage_default_instance_);
}
inline const ::ChatRejectMessage& PokerTHMessage::chatrejectmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatRejectMessage)
  return _internal_chatrejectmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_chatrejectmessage(
    ::ChatRejectMessage* chatrejectmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chatrejectmessage_);
  }
  chatrejectmessage_ = chatrejectmessage;
  if (chatrejectmessage) {
    _has_bits_[2] |= 0x00000001u;
  } else {
    _has_bits_[2] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.chatRejectMessage)
}
inline ::ChatRejectMessage* PokerTHMessage::release_chatrejectmessage() {
  _has_bits_[2] &= ~0x00000001u;
  ::ChatRejectMessage* temp = chatrejectmessage_;
  chatrejectmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChatRejectMessage* PokerTHMessage::unsafe_arena_release_chatrejectmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.chatRejectMessage)
  _has_bits_[2] &= ~0x00000001u;
  ::ChatRejectMessage* temp = chatrejectmessage_;
  chatrejectmessage_ = nullptr;
  return temp;
}
inline ::ChatRejectMessage* PokerTHMessage::_internal_mutable_chatrejectmessage() {
  _has_bits_[2] |= 0x00000001u;
  if (chatrejectmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatRejectMessage>(GetArenaForAllocation());
    chatrejectmessage_ = p;
  }
  return chatrejectmessage_;
}
inline ::ChatRejectMessage* PokerTHMessage::mutable_chatrejectmessage() {
  ::ChatRejectMessage* _msg = _internal_mutable_chatrejectmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatRejectMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_chatrejectmessage(::ChatRejectMessage* chatrejectmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chatrejectmessage_;
  }
  if (chatrejectmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ChatRejectMessage>::GetOwningArena(chatrejectmessage);
    if (message_arena != submessage_arena) {
      chatrejectmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatrejectmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000001u;
  } else {
    _has_bits_[2] &= ~0x00000001u;
  }
  chatrejectmessage_ = chatrejectmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatRejectMessage)
}

// optional .DialogMessage dialogMessage = 67;
inline bool PokerTHMessage::_internal_has_dialogmessage() const {
  bool value = (_has_bits_[2] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || dialogmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_dialogmessage() const {
  return _internal_has_dialogmessage();
}
inline void PokerTHMessage::clear_dialogmessage() {
  if (dialogmessage_ != nullptr) dialogmessage_->Clear();
  _has_bits_[2] &= ~0x00000002u;
}
inline const ::DialogMessage& PokerTHMessage::_internal_dialogmessage() const {
  const ::DialogMessage* p = dialogmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::DialogMessage&>(
      ::_DialogMessage_default_instance_);
}
inline const ::DialogMessage& PokerTHMessage::dialogmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dialogMessage)
  return _internal_dialogmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_dialogmessage(
    ::DialogMessage* dialogmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dialogmessage_);
  }
  dialogmessage_ = dialogmessage;
  if (dialogmessage) {
    _has_bits_[2] |= 0x00000002u;
  } else {
    _has_bits_[2] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.dialogMessage)
}
inline ::DialogMessage* PokerTHMessage::release_dialogmessage() {
  _has_bits_[2] &= ~0x00000002u;
  ::DialogMessage* temp = dialogmessage_;
  dialogmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DialogMessage* PokerTHMessage::unsafe_arena_release_dialogmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dialogMessage)
  _has_bits_[2] &= ~0x00000002u;
  ::DialogMessage* temp = dialogmessage_;
  dialogmessage_ = nullptr;
  return temp;
}
inline ::DialogMessage* PokerTHMessage::_internal_mutable_dialogmessage() {
  _has_bits_[2] |= 0x00000002u;
  if (dialogmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DialogMessage>(GetArenaForAllocation());
    dialogmessage_ = p;
  }
  return dialogmessage_;
}
inline ::DialogMessage* PokerTHMessage::mutable_dialogmessage() {
  ::DialogMessage* _msg = _internal_mutable_dialogmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dialogMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_dialogmessage(::DialogMessage* dialogmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dialogmessage_;
  }
  if (dialogmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DialogMessage>::GetOwningArena(dialogmessage);
    if (message_arena != submessage_arena) {
      dialogmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dialogmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000002u;
  } else {
    _has_bits_[2] &= ~0x00000002u;
  }
  dialogmessage_ = dialogmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dialogMessage)
}

// optional .TimeoutWarningMessage timeoutWarningMessage = 68;
inline bool PokerTHMessage::_internal_has_timeoutwarningmessage() const {
  bool value = (_has_bits_[2] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || timeoutwarningmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_timeoutwarningmessage() const {
  return _internal_has_timeoutwarningmessage();
}
inline void PokerTHMessage::clear_timeoutwarningmessage() {
  if (timeoutwarningmessage_ != nullptr) timeoutwarningmessage_->Clear();
  _has_bits_[2] &= ~0x00000004u;
}
inline const ::TimeoutWarningMessage& PokerTHMessage::_internal_timeoutwarningmessage() const {
  const ::TimeoutWarningMessage* p = timeoutwarningmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TimeoutWarningMessage&>(
      ::_TimeoutWarningMessage_default_instance_);
}
inline const ::TimeoutWarningMessage& PokerTHMessage::timeoutwarningmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.timeoutWarningMessage)
  return _internal_timeoutwarningmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_timeoutwarningmessage(
    ::TimeoutWarningMessage* timeoutwarningmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeoutwarningmessage_);
  }
  timeoutwarningmessage_ = timeoutwarningmessage;
  if (timeoutwarningmessage) {
    _has_bits_[2] |= 0x00000004u;
  } else {
    _has_bits_[2] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.timeoutWarningMessage)
}
inline ::TimeoutWarningMessage* PokerTHMessage::release_timeoutwarningmessage() {
  _has_bits_[2] &= ~0x00000004u;
  ::TimeoutWarningMessage* temp = timeoutwarningmessage_;
  timeoutwarningmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TimeoutWarningMessage* PokerTHMessage::unsafe_arena_release_timeoutwarningmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.timeoutWarningMessage)
  _has_bits_[2] &= ~0x00000004u;
  ::TimeoutWarningMessage* temp = timeoutwarningmessage_;
  timeoutwarningmessage_ = nullptr;
  return temp;
}
inline ::TimeoutWarningMessage* PokerTHMessage::_internal_mutable_timeoutwarningmessage() {
  _has_bits_[2] |= 0x00000004u;
  if (timeoutwarningmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TimeoutWarningMessage>(GetArenaForAllocation());
    timeoutwarningmessage_ = p;
  }
  return timeoutwarningmessage_;
}
inline ::TimeoutWarningMessage* PokerTHMessage::mutable_timeoutwarningmessage() {
  ::TimeoutWarningMessage* _msg = _internal_mutable_timeoutwarningmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.timeoutWarningMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_timeoutwarningmessage(::TimeoutWarningMessage* timeoutwarningmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timeoutwarningmessage_;
  }
  if (timeoutwarningmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TimeoutWarningMessage>::GetOwningArena(timeoutwarningmessage);
    if (message_arena != submessage_arena) {
      timeoutwarningmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeoutwarningmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000004u;
  } else {
    _has_bits_[2] &= ~0x00000004u;
  }
  timeoutwarningmessage_ = timeoutwarningmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.timeoutWarningMessage)
}

// optional .ResetTimeoutMessage resetTimeoutMessage = 69;
inline bool PokerTHMessage::_internal_has_resettimeoutmessage() const {
  bool value = (_has_bits_[2] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || resettimeoutmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_resettimeoutmessage() const {
  return _internal_has_resettimeoutmessage();
}
inline void PokerTHMessage::clear_resettimeoutmessage() {
  if (resettimeoutmessage_ != nullptr) resettimeoutmessage_->Clear();
  _has_bits_[2] &= ~0x00000008u;
}
inline const ::ResetTimeoutMessage& PokerTHMessage::_internal_resettimeoutmessage() const {
  const ::ResetTimeoutMessage* p = resettimeoutmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ResetTimeoutMessage&>(
      ::_ResetTimeoutMessage_default_instance_);
}
inline const ::ResetTimeoutMessage& PokerTHMessage::resettimeoutmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.resetTimeoutMessage)
  return _internal_resettimeoutmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_resettimeoutmessage(
    ::ResetTimeoutMessage* resettimeoutmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resettimeoutmessage_);
  }
  resettimeoutmessage_ = resettimeoutmessage;
  if (resettimeoutmessage) {
    _has_bits_[2] |= 0x00000008u;
  } else {
    _has_bits_[2] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.resetTimeoutMessage)
}
inline ::ResetTimeoutMessage* PokerTHMessage::release_resettimeoutmessage() {
  _has_bits_[2] &= ~0x00000008u;
  ::ResetTimeoutMessage* temp = resettimeoutmessage_;
  resettimeoutmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ResetTimeoutMessage* PokerTHMessage::unsafe_arena_release_resettimeoutmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.resetTimeoutMessage)
  _has_bits_[2] &= ~0x00000008u;
  ::ResetTimeoutMessage* temp = resettimeoutmessage_;
  resettimeoutmessage_ = nullptr;
  return temp;
}
inline ::ResetTimeoutMessage* PokerTHMessage::_internal_mutable_resettimeoutmessage() {
  _has_bits_[2] |= 0x00000008u;
  if (resettimeoutmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResetTimeoutMessage>(GetArenaForAllocation());
    resettimeoutmessage_ = p;
  }
  return resettimeoutmessage_;
}
inline ::ResetTimeoutMessage* PokerTHMessage::mutable_resettimeoutmessage() {
  ::ResetTimeoutMessage* _msg = _internal_mutable_resettimeoutmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.resetTimeoutMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_resettimeoutmessage(::ResetTimeoutMessage* resettimeoutmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resettimeoutmessage_;
  }
  if (resettimeoutmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ResetTimeoutMessage>::GetOwningArena(resettimeoutmessage);
    if (message_arena != submessage_arena) {
      resettimeoutmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resettimeoutmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000008u;
  } else {
    _has_bits_[2] &= ~0x00000008u;
  }
  resettimeoutmessage_ = resettimeoutmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.resetTimeoutMessage)
}

// optional .ReportAvatarMessage reportAvatarMessage = 70;
inline bool PokerTHMessage::_internal_has_reportavatarmessage() const {
  bool value = (_has_bits_[2] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || reportavatarmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_reportavatarmessage() const {
  return _internal_has_reportavatarmessage();
}
inline void PokerTHMessage::clear_reportavatarmessage() {
  if (reportavatarmessage_ != nullptr) reportavatarmessage_->Clear();
  _has_bits_[2] &= ~0x00000010u;
}
inline const ::ReportAvatarMessage& PokerTHMessage::_internal_reportavatarmessage() const {
  const ::ReportAvatarMessage* p = reportavatarmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ReportAvatarMessage&>(
      ::_ReportAvatarMessage_default_instance_);
}
inline const ::ReportAvatarMessage& PokerTHMessage::reportavatarmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportAvatarMessage)
  return _internal_reportavatarmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_reportavatarmessage(
    ::ReportAvatarMessage* reportavatarmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reportavatarmessage_);
  }
  reportavatarmessage_ = reportavatarmessage;
  if (reportavatarmessage) {
    _has_bits_[2] |= 0x00000010u;
  } else {
    _has_bits_[2] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.reportAvatarMessage)
}
inline ::ReportAvatarMessage* PokerTHMessage::release_reportavatarmessage() {
  _has_bits_[2] &= ~0x00000010u;
  ::ReportAvatarMessage* temp = reportavatarmessage_;
  reportavatarmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ReportAvatarMessage* PokerTHMessage::unsafe_arena_release_reportavatarmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportAvatarMessage)
  _has_bits_[2] &= ~0x00000010u;
  ::ReportAvatarMessage* temp = reportavatarmessage_;
  reportavatarmessage_ = nullptr;
  return temp;
}
inline ::ReportAvatarMessage* PokerTHMessage::_internal_mutable_reportavatarmessage() {
  _has_bits_[2] |= 0x00000010u;
  if (reportavatarmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportAvatarMessage>(GetArenaForAllocation());
    reportavatarmessage_ = p;
  }
  return reportavatarmessage_;
}
inline ::ReportAvatarMessage* PokerTHMessage::mutable_reportavatarmessage() {
  ::ReportAvatarMessage* _msg = _internal_mutable_reportavatarmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportAvatarMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_reportavatarmessage(::ReportAvatarMessage* reportavatarmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reportavatarmessage_;
  }
  if (reportavatarmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ReportAvatarMessage>::GetOwningArena(reportavatarmessage);
    if (message_arena != submessage_arena) {
      reportavatarmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reportavatarmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000010u;
  } else {
    _has_bits_[2] &= ~0x00000010u;
  }
  reportavatarmessage_ = reportavatarmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportAvatarMessage)
}

// optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
inline bool PokerTHMessage::_internal_has_reportavatarackmessage() const {
  bool value = (_has_bits_[2] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || reportavatarackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_reportavatarackmessage() const {
  return _internal_has_reportavatarackmessage();
}
inline void PokerTHMessage::clear_reportavatarackmessage() {
  if (reportavatarackmessage_ != nullptr) reportavatarackmessage_->Clear();
  _has_bits_[2] &= ~0x00000020u;
}
inline const ::ReportAvatarAckMessage& PokerTHMessage::_internal_reportavatarackmessage() const {
  const ::ReportAvatarAckMessage* p = reportavatarackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ReportAvatarAckMessage&>(
      ::_ReportAvatarAckMessage_default_instance_);
}
inline const ::ReportAvatarAckMessage& PokerTHMessage::reportavatarackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportAvatarAckMessage)
  return _internal_reportavatarackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_reportavatarackmessage(
    ::ReportAvatarAckMessage* reportavatarackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reportavatarackmessage_);
  }
  reportavatarackmessage_ = reportavatarackmessage;
  if (reportavatarackmessage) {
    _has_bits_[2] |= 0x00000020u;
  } else {
    _has_bits_[2] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.reportAvatarAckMessage)
}
inline ::ReportAvatarAckMessage* PokerTHMessage::release_reportavatarackmessage() {
  _has_bits_[2] &= ~0x00000020u;
  ::ReportAvatarAckMessage* temp = reportavatarackmessage_;
  reportavatarackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::unsafe_arena_release_reportavatarackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportAvatarAckMessage)
  _has_bits_[2] &= ~0x00000020u;
  ::ReportAvatarAckMessage* temp = reportavatarackmessage_;
  reportavatarackmessage_ = nullptr;
  return temp;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::_internal_mutable_reportavatarackmessage() {
  _has_bits_[2] |= 0x00000020u;
  if (reportavatarackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportAvatarAckMessage>(GetArenaForAllocation());
    reportavatarackmessage_ = p;
  }
  return reportavatarackmessage_;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::mutable_reportavatarackmessage() {
  ::ReportAvatarAckMessage* _msg = _internal_mutable_reportavatarackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportAvatarAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_reportavatarackmessage(::ReportAvatarAckMessage* reportavatarackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reportavatarackmessage_;
  }
  if (reportavatarackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ReportAvatarAckMessage>::GetOwningArena(reportavatarackmessage);
    if (message_arena != submessage_arena) {
      reportavatarackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reportavatarackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000020u;
  } else {
    _has_bits_[2] &= ~0x00000020u;
  }
  reportavatarackmessage_ = reportavatarackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportAvatarAckMessage)
}

// optional .ReportGameMessage reportGameMessage = 72;
inline bool PokerTHMessage::_internal_has_reportgamemessage() const {
  bool value = (_has_bits_[2] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || reportgamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_reportgamemessage() const {
  return _internal_has_reportgamemessage();
}
inline void PokerTHMessage::clear_reportgamemessage() {
  if (reportgamemessage_ != nullptr) reportgamemessage_->Clear();
  _has_bits_[2] &= ~0x00000040u;
}
inline const ::ReportGameMessage& PokerTHMessage::_internal_reportgamemessage() const {
  const ::ReportGameMessage* p = reportgamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ReportGameMessage&>(
      ::_ReportGameMessage_default_instance_);
}
inline const ::ReportGameMessage& PokerTHMessage::reportgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportGameMessage)
  return _internal_reportgamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_reportgamemessage(
    ::ReportGameMessage* reportgamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reportgamemessage_);
  }
  reportgamemessage_ = reportgamemessage;
  if (reportgamemessage) {
    _has_bits_[2] |= 0x00000040u;
  } else {
    _has_bits_[2] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.reportGameMessage)
}
inline ::ReportGameMessage* PokerTHMessage::release_reportgamemessage() {
  _has_bits_[2] &= ~0x00000040u;
  ::ReportGameMessage* temp = reportgamemessage_;
  reportgamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ReportGameMessage* PokerTHMessage::unsafe_arena_release_reportgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportGameMessage)
  _has_bits_[2] &= ~0x00000040u;
  ::ReportGameMessage* temp = reportgamemessage_;
  reportgamemessage_ = nullptr;
  return temp;
}
inline ::ReportGameMessage* PokerTHMessage::_internal_mutable_reportgamemessage() {
  _has_bits_[2] |= 0x00000040u;
  if (reportgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportGameMessage>(GetArenaForAllocation());
    reportgamemessage_ = p;
  }
  return reportgamemessage_;
}
inline ::ReportGameMessage* PokerTHMessage::mutable_reportgamemessage() {
  ::ReportGameMessage* _msg = _internal_mutable_reportgamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_reportgamemessage(::ReportGameMessage* reportgamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reportgamemessage_;
  }
  if (reportgamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ReportGameMessage>::GetOwningArena(reportgamemessage);
    if (message_arena != submessage_arena) {
      reportgamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reportgamemessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000040u;
  } else {
    _has_bits_[2] &= ~0x00000040u;
  }
  reportgamemessage_ = reportgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportGameMessage)
}

// optional .ReportGameAckMessage reportGameAckMessage = 73;
inline bool PokerTHMessage::_internal_has_reportgameackmessage() const {
  bool value = (_has_bits_[2] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || reportgameackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_reportgameackmessage() const {
  return _internal_has_reportgameackmessage();
}
inline void PokerTHMessage::clear_reportgameackmessage() {
  if (reportgameackmessage_ != nullptr) reportgameackmessage_->Clear();
  _has_bits_[2] &= ~0x00000080u;
}
inline const ::ReportGameAckMessage& PokerTHMessage::_internal_reportgameackmessage() const {
  const ::ReportGameAckMessage* p = reportgameackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ReportGameAckMessage&>(
      ::_ReportGameAckMessage_default_instance_);
}
inline const ::ReportGameAckMessage& PokerTHMessage::reportgameackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportGameAckMessage)
  return _internal_reportgameackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_reportgameackmessage(
    ::ReportGameAckMessage* reportgameackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reportgameackmessage_);
  }
  reportgameackmessage_ = reportgameackmessage;
  if (reportgameackmessage) {
    _has_bits_[2] |= 0x00000080u;
  } else {
    _has_bits_[2] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.reportGameAckMessage)
}
inline ::ReportGameAckMessage* PokerTHMessage::release_reportgameackmessage() {
  _has_bits_[2] &= ~0x00000080u;
  ::ReportGameAckMessage* temp = reportgameackmessage_;
  reportgameackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ReportGameAckMessage* PokerTHMessage::unsafe_arena_release_reportgameackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportGameAckMessage)
  _has_bits_[2] &= ~0x00000080u;
  ::ReportGameAckMessage* temp = reportgameackmessage_;
  reportgameackmessage_ = nullptr;
  return temp;
}
inline ::ReportGameAckMessage* PokerTHMessage::_internal_mutable_reportgameackmessage() {
  _has_bits_[2] |= 0x00000080u;
  if (reportgameackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportGameAckMessage>(GetArenaForAllocation());
    reportgameackmessage_ = p;
  }
  return reportgameackmessage_;
}
inline ::ReportGameAckMessage* PokerTHMessage::mutable_reportgameackmessage() {
  ::ReportGameAckMessage* _msg = _internal_mutable_reportgameackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportGameAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_reportgameackmessage(::ReportGameAckMessage* reportgameackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reportgameackmessage_;
  }
  if (reportgameackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ReportGameAckMessage>::GetOwningArena(reportgameackmessage);
    if (message_arena != submessage_arena) {
      reportgameackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reportgameackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000080u;
  } else {
    _has_bits_[2] &= ~0x00000080u;
  }
  reportgameackmessage_ = reportgameackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportGameAckMessage)
}

// optional .ErrorMessage errorMessage = 74;
inline bool PokerTHMessage::_internal_has_errormessage() const {
  bool value = (_has_bits_[2] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || errormessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_errormessage() const {
  return _internal_has_errormessage();
}
inline void PokerTHMessage::clear_errormessage() {
  if (errormessage_ != nullptr) errormessage_->Clear();
  _has_bits_[2] &= ~0x00000100u;
}
inline const ::ErrorMessage& PokerTHMessage::_internal_errormessage() const {
  const ::ErrorMessage* p = errormessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ErrorMessage&>(
      ::_ErrorMessage_default_instance_);
}
inline const ::ErrorMessage& PokerTHMessage::errormessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.errorMessage)
  return _internal_errormessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_errormessage(
    ::ErrorMessage* errormessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errormessage_);
  }
  errormessage_ = errormessage;
  if (errormessage) {
    _has_bits_[2] |= 0x00000100u;
  } else {
    _has_bits_[2] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.errorMessage)
}
inline ::ErrorMessage* PokerTHMessage::release_errormessage() {
  _has_bits_[2] &= ~0x00000100u;
  ::ErrorMessage* temp = errormessage_;
  errormessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ErrorMessage* PokerTHMessage::unsafe_arena_release_errormessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.errorMessage)
  _has_bits_[2] &= ~0x00000100u;
  ::ErrorMessage* temp = errormessage_;
  errormessage_ = nullptr;
  return temp;
}
inline ::ErrorMessage* PokerTHMessage::_internal_mutable_errormessage() {
  _has_bits_[2] |= 0x00000100u;
  if (errormessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ErrorMessage>(GetArenaForAllocation());
    errormessage_ = p;
  }
  return errormessage_;
}
inline ::ErrorMessage* PokerTHMessage::mutable_errormessage() {
  ::ErrorMessage* _msg = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.errorMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_errormessage(::ErrorMessage* errormessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete errormessage_;
  }
  if (errormessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ErrorMessage>::GetOwningArena(errormessage);
    if (message_arena != submessage_arena) {
      errormessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errormessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000100u;
  } else {
    _has_bits_[2] &= ~0x00000100u;
  }
  errormessage_ = errormessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.errorMessage)
}

// optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
inline bool PokerTHMessage::_internal_has_adminremovegamemessage() const {
  bool value = (_has_bits_[2] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || adminremovegamemessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_adminremovegamemessage() const {
  return _internal_has_adminremovegamemessage();
}
inline void PokerTHMessage::clear_adminremovegamemessage() {
  if (adminremovegamemessage_ != nullptr) adminremovegamemessage_->Clear();
  _has_bits_[2] &= ~0x00000200u;
}
inline const ::AdminRemoveGameMessage& PokerTHMessage::_internal_adminremovegamemessage() const {
  const ::AdminRemoveGameMessage* p = adminremovegamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AdminRemoveGameMessage&>(
      ::_AdminRemoveGameMessage_default_instance_);
}
inline const ::AdminRemoveGameMessage& PokerTHMessage::adminremovegamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminRemoveGameMessage)
  return _internal_adminremovegamemessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_adminremovegamemessage(
    ::AdminRemoveGameMessage* adminremovegamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adminremovegamemessage_);
  }
  adminremovegamemessage_ = adminremovegamemessage;
  if (adminremovegamemessage) {
    _has_bits_[2] |= 0x00000200u;
  } else {
    _has_bits_[2] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.adminRemoveGameMessage)
}
inline ::AdminRemoveGameMessage* PokerTHMessage::release_adminremovegamemessage() {
  _has_bits_[2] &= ~0x00000200u;
  ::AdminRemoveGameMessage* temp = adminremovegamemessage_;
  adminremovegamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AdminRemoveGameMessage* PokerTHMessage::unsafe_arena_release_adminremovegamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminRemoveGameMessage)
  _has_bits_[2] &= ~0x00000200u;
  ::AdminRemoveGameMessage* temp = adminremovegamemessage_;
  adminremovegamemessage_ = nullptr;
  return temp;
}
inline ::AdminRemoveGameMessage* PokerTHMessage::_internal_mutable_adminremovegamemessage() {
  _has_bits_[2] |= 0x00000200u;
  if (adminremovegamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminRemoveGameMessage>(GetArenaForAllocation());
    adminremovegamemessage_ = p;
  }
  return adminremovegamemessage_;
}
inline ::AdminRemoveGameMessage* PokerTHMessage::mutable_adminremovegamemessage() {
  ::AdminRemoveGameMessage* _msg = _internal_mutable_adminremovegamemessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminRemoveGameMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_adminremovegamemessage(::AdminRemoveGameMessage* adminremovegamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete adminremovegamemessage_;
  }
  if (adminremovegamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AdminRemoveGameMessage>::GetOwningArena(adminremovegamemessage);
    if (message_arena != submessage_arena) {
      adminremovegamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adminremovegamemessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000200u;
  } else {
    _has_bits_[2] &= ~0x00000200u;
  }
  adminremovegamemessage_ = adminremovegamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminRemoveGameMessage)
}

// optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
inline bool PokerTHMessage::_internal_has_adminremovegameackmessage() const {
  bool value = (_has_bits_[2] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || adminremovegameackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_adminremovegameackmessage() const {
  return _internal_has_adminremovegameackmessage();
}
inline void PokerTHMessage::clear_adminremovegameackmessage() {
  if (adminremovegameackmessage_ != nullptr) adminremovegameackmessage_->Clear();
  _has_bits_[2] &= ~0x00000400u;
}
inline const ::AdminRemoveGameAckMessage& PokerTHMessage::_internal_adminremovegameackmessage() const {
  const ::AdminRemoveGameAckMessage* p = adminremovegameackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AdminRemoveGameAckMessage&>(
      ::_AdminRemoveGameAckMessage_default_instance_);
}
inline const ::AdminRemoveGameAckMessage& PokerTHMessage::adminremovegameackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminRemoveGameAckMessage)
  return _internal_adminremovegameackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_adminremovegameackmessage(
    ::AdminRemoveGameAckMessage* adminremovegameackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adminremovegameackmessage_);
  }
  adminremovegameackmessage_ = adminremovegameackmessage;
  if (adminremovegameackmessage) {
    _has_bits_[2] |= 0x00000400u;
  } else {
    _has_bits_[2] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.adminRemoveGameAckMessage)
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::release_adminremovegameackmessage() {
  _has_bits_[2] &= ~0x00000400u;
  ::AdminRemoveGameAckMessage* temp = adminremovegameackmessage_;
  adminremovegameackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::unsafe_arena_release_adminremovegameackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminRemoveGameAckMessage)
  _has_bits_[2] &= ~0x00000400u;
  ::AdminRemoveGameAckMessage* temp = adminremovegameackmessage_;
  adminremovegameackmessage_ = nullptr;
  return temp;
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::_internal_mutable_adminremovegameackmessage() {
  _has_bits_[2] |= 0x00000400u;
  if (adminremovegameackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminRemoveGameAckMessage>(GetArenaForAllocation());
    adminremovegameackmessage_ = p;
  }
  return adminremovegameackmessage_;
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::mutable_adminremovegameackmessage() {
  ::AdminRemoveGameAckMessage* _msg = _internal_mutable_adminremovegameackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminRemoveGameAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_adminremovegameackmessage(::AdminRemoveGameAckMessage* adminremovegameackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete adminremovegameackmessage_;
  }
  if (adminremovegameackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AdminRemoveGameAckMessage>::GetOwningArena(adminremovegameackmessage);
    if (message_arena != submessage_arena) {
      adminremovegameackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adminremovegameackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000400u;
  } else {
    _has_bits_[2] &= ~0x00000400u;
  }
  adminremovegameackmessage_ = adminremovegameackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminRemoveGameAckMessage)
}

// optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
inline bool PokerTHMessage::_internal_has_adminbanplayermessage() const {
  bool value = (_has_bits_[2] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || adminbanplayermessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_adminbanplayermessage() const {
  return _internal_has_adminbanplayermessage();
}
inline void PokerTHMessage::clear_adminbanplayermessage() {
  if (adminbanplayermessage_ != nullptr) adminbanplayermessage_->Clear();
  _has_bits_[2] &= ~0x00000800u;
}
inline const ::AdminBanPlayerMessage& PokerTHMessage::_internal_adminbanplayermessage() const {
  const ::AdminBanPlayerMessage* p = adminbanplayermessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AdminBanPlayerMessage&>(
      ::_AdminBanPlayerMessage_default_instance_);
}
inline const ::AdminBanPlayerMessage& PokerTHMessage::adminbanplayermessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminBanPlayerMessage)
  return _internal_adminbanplayermessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_adminbanplayermessage(
    ::AdminBanPlayerMessage* adminbanplayermessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adminbanplayermessage_);
  }
  adminbanplayermessage_ = adminbanplayermessage;
  if (adminbanplayermessage) {
    _has_bits_[2] |= 0x00000800u;
  } else {
    _has_bits_[2] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.adminBanPlayerMessage)
}
inline ::AdminBanPlayerMessage* PokerTHMessage::release_adminbanplayermessage() {
  _has_bits_[2] &= ~0x00000800u;
  ::AdminBanPlayerMessage* temp = adminbanplayermessage_;
  adminbanplayermessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AdminBanPlayerMessage* PokerTHMessage::unsafe_arena_release_adminbanplayermessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminBanPlayerMessage)
  _has_bits_[2] &= ~0x00000800u;
  ::AdminBanPlayerMessage* temp = adminbanplayermessage_;
  adminbanplayermessage_ = nullptr;
  return temp;
}
inline ::AdminBanPlayerMessage* PokerTHMessage::_internal_mutable_adminbanplayermessage() {
  _has_bits_[2] |= 0x00000800u;
  if (adminbanplayermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminBanPlayerMessage>(GetArenaForAllocation());
    adminbanplayermessage_ = p;
  }
  return adminbanplayermessage_;
}
inline ::AdminBanPlayerMessage* PokerTHMessage::mutable_adminbanplayermessage() {
  ::AdminBanPlayerMessage* _msg = _internal_mutable_adminbanplayermessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminBanPlayerMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_adminbanplayermessage(::AdminBanPlayerMessage* adminbanplayermessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete adminbanplayermessage_;
  }
  if (adminbanplayermessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AdminBanPlayerMessage>::GetOwningArena(adminbanplayermessage);
    if (message_arena != submessage_arena) {
      adminbanplayermessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adminbanplayermessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000800u;
  } else {
    _has_bits_[2] &= ~0x00000800u;
  }
  adminbanplayermessage_ = adminbanplayermessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminBanPlayerMessage)
}

// optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
inline bool PokerTHMessage::_internal_has_adminbanplayerackmessage() const {
  bool value = (_has_bits_[2] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || adminbanplayerackmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_adminbanplayerackmessage() const {
  return _internal_has_adminbanplayerackmessage();
}
inline void PokerTHMessage::clear_adminbanplayerackmessage() {
  if (adminbanplayerackmessage_ != nullptr) adminbanplayerackmessage_->Clear();
  _has_bits_[2] &= ~0x00001000u;
}
inline const ::AdminBanPlayerAckMessage& PokerTHMessage::_internal_adminbanplayerackmessage() const {
  const ::AdminBanPlayerAckMessage* p = adminbanplayerackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::AdminBanPlayerAckMessage&>(
      ::_AdminBanPlayerAckMessage_default_instance_);
}
inline const ::AdminBanPlayerAckMessage& PokerTHMessage::adminbanplayerackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminBanPlayerAckMessage)
  return _internal_adminbanplayerackmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_adminbanplayerackmessage(
    ::AdminBanPlayerAckMessage* adminbanplayerackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adminbanplayerackmessage_);
  }
  adminbanplayerackmessage_ = adminbanplayerackmessage;
  if (adminbanplayerackmessage) {
    _has_bits_[2] |= 0x00001000u;
  } else {
    _has_bits_[2] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.adminBanPlayerAckMessage)
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::release_adminbanplayerackmessage() {
  _has_bits_[2] &= ~0x00001000u;
  ::AdminBanPlayerAckMessage* temp = adminbanplayerackmessage_;
  adminbanplayerackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::unsafe_arena_release_adminbanplayerackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminBanPlayerAckMessage)
  _has_bits_[2] &= ~0x00001000u;
  ::AdminBanPlayerAckMessage* temp = adminbanplayerackmessage_;
  adminbanplayerackmessage_ = nullptr;
  return temp;
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::_internal_mutable_adminbanplayerackmessage() {
  _has_bits_[2] |= 0x00001000u;
  if (adminbanplayerackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminBanPlayerAckMessage>(GetArenaForAllocation());
    adminbanplayerackmessage_ = p;
  }
  return adminbanplayerackmessage_;
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::mutable_adminbanplayerackmessage() {
  ::AdminBanPlayerAckMessage* _msg = _internal_mutable_adminbanplayerackmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminBanPlayerAckMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_adminbanplayerackmessage(::AdminBanPlayerAckMessage* adminbanplayerackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete adminbanplayerackmessage_;
  }
  if (adminbanplayerackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AdminBanPlayerAckMessage>::GetOwningArena(adminbanplayerackmessage);
    if (message_arena != submessage_arena) {
      adminbanplayerackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adminbanplayerackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00001000u;
  } else {
    _has_bits_[2] &= ~0x00001000u;
  }
  adminbanplayerackmessage_ = adminbanplayerackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminBanPlayerAckMessage)
}

// optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
inline bool PokerTHMessage::_internal_has_gamelistspectatorjoinedmessage() const {
  bool value = (_has_bits_[2] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistspectatorjoinedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistspectatorjoinedmessage() const {
  return _internal_has_gamelistspectatorjoinedmessage();
}
inline void PokerTHMessage::clear_gamelistspectatorjoinedmessage() {
  if (gamelistspectatorjoinedmessage_ != nullptr) gamelistspectatorjoinedmessage_->Clear();
  _has_bits_[2] &= ~0x00002000u;
}
inline const ::GameListSpectatorJoinedMessage& PokerTHMessage::_internal_gamelistspectatorjoinedmessage() const {
  const ::GameListSpectatorJoinedMessage* p = gamelistspectatorjoinedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListSpectatorJoinedMessage&>(
      ::_GameListSpectatorJoinedMessage_default_instance_);
}
inline const ::GameListSpectatorJoinedMessage& PokerTHMessage::gamelistspectatorjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListSpectatorJoinedMessage)
  return _internal_gamelistspectatorjoinedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistspectatorjoinedmessage(
    ::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistspectatorjoinedmessage_);
  }
  gamelistspectatorjoinedmessage_ = gamelistspectatorjoinedmessage;
  if (gamelistspectatorjoinedmessage) {
    _has_bits_[2] |= 0x00002000u;
  } else {
    _has_bits_[2] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListSpectatorJoinedMessage)
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::release_gamelistspectatorjoinedmessage() {
  _has_bits_[2] &= ~0x00002000u;
  ::GameListSpectatorJoinedMessage* temp = gamelistspectatorjoinedmessage_;
  gamelistspectatorjoinedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::unsafe_arena_release_gamelistspectatorjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListSpectatorJoinedMessage)
  _has_bits_[2] &= ~0x00002000u;
  ::GameListSpectatorJoinedMessage* temp = gamelistspectatorjoinedmessage_;
  gamelistspectatorjoinedmessage_ = nullptr;
  return temp;
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::_internal_mutable_gamelistspectatorjoinedmessage() {
  _has_bits_[2] |= 0x00002000u;
  if (gamelistspectatorjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListSpectatorJoinedMessage>(GetArenaForAllocation());
    gamelistspectatorjoinedmessage_ = p;
  }
  return gamelistspectatorjoinedmessage_;
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::mutable_gamelistspectatorjoinedmessage() {
  ::GameListSpectatorJoinedMessage* _msg = _internal_mutable_gamelistspectatorjoinedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListSpectatorJoinedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistspectatorjoinedmessage(::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistspectatorjoinedmessage_;
  }
  if (gamelistspectatorjoinedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListSpectatorJoinedMessage>::GetOwningArena(gamelistspectatorjoinedmessage);
    if (message_arena != submessage_arena) {
      gamelistspectatorjoinedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistspectatorjoinedmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00002000u;
  } else {
    _has_bits_[2] &= ~0x00002000u;
  }
  gamelistspectatorjoinedmessage_ = gamelistspectatorjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListSpectatorJoinedMessage)
}

// optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
inline bool PokerTHMessage::_internal_has_gamelistspectatorleftmessage() const {
  bool value = (_has_bits_[2] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || gamelistspectatorleftmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamelistspectatorleftmessage() const {
  return _internal_has_gamelistspectatorleftmessage();
}
inline void PokerTHMessage::clear_gamelistspectatorleftmessage() {
  if (gamelistspectatorleftmessage_ != nullptr) gamelistspectatorleftmessage_->Clear();
  _has_bits_[2] &= ~0x00004000u;
}
inline const ::GameListSpectatorLeftMessage& PokerTHMessage::_internal_gamelistspectatorleftmessage() const {
  const ::GameListSpectatorLeftMessage* p = gamelistspectatorleftmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameListSpectatorLeftMessage&>(
      ::_GameListSpectatorLeftMessage_default_instance_);
}
inline const ::GameListSpectatorLeftMessage& PokerTHMessage::gamelistspectatorleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListSpectatorLeftMessage)
  return _internal_gamelistspectatorleftmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamelistspectatorleftmessage(
    ::GameListSpectatorLeftMessage* gamelistspectatorleftmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamelistspectatorleftmessage_);
  }
  gamelistspectatorleftmessage_ = gamelistspectatorleftmessage;
  if (gamelistspectatorleftmessage) {
    _has_bits_[2] |= 0x00004000u;
  } else {
    _has_bits_[2] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameListSpectatorLeftMessage)
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::release_gamelistspectatorleftmessage() {
  _has_bits_[2] &= ~0x00004000u;
  ::GameListSpectatorLeftMessage* temp = gamelistspectatorleftmessage_;
  gamelistspectatorleftmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::unsafe_arena_release_gamelistspectatorleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListSpectatorLeftMessage)
  _has_bits_[2] &= ~0x00004000u;
  ::GameListSpectatorLeftMessage* temp = gamelistspectatorleftmessage_;
  gamelistspectatorleftmessage_ = nullptr;
  return temp;
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::_internal_mutable_gamelistspectatorleftmessage() {
  _has_bits_[2] |= 0x00004000u;
  if (gamelistspectatorleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListSpectatorLeftMessage>(GetArenaForAllocation());
    gamelistspectatorleftmessage_ = p;
  }
  return gamelistspectatorleftmessage_;
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::mutable_gamelistspectatorleftmessage() {
  ::GameListSpectatorLeftMessage* _msg = _internal_mutable_gamelistspectatorleftmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListSpectatorLeftMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamelistspectatorleftmessage(::GameListSpectatorLeftMessage* gamelistspectatorleftmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamelistspectatorleftmessage_;
  }
  if (gamelistspectatorleftmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameListSpectatorLeftMessage>::GetOwningArena(gamelistspectatorleftmessage);
    if (message_arena != submessage_arena) {
      gamelistspectatorleftmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamelistspectatorleftmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00004000u;
  } else {
    _has_bits_[2] &= ~0x00004000u;
  }
  gamelistspectatorleftmessage_ = gamelistspectatorleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListSpectatorLeftMessage)
}

// optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
inline bool PokerTHMessage::_internal_has_gamespectatorjoinedmessage() const {
  bool value = (_has_bits_[2] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || gamespectatorjoinedmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamespectatorjoinedmessage() const {
  return _internal_has_gamespectatorjoinedmessage();
}
inline void PokerTHMessage::clear_gamespectatorjoinedmessage() {
  if (gamespectatorjoinedmessage_ != nullptr) gamespectatorjoinedmessage_->Clear();
  _has_bits_[2] &= ~0x00008000u;
}
inline const ::GameSpectatorJoinedMessage& PokerTHMessage::_internal_gamespectatorjoinedmessage() const {
  const ::GameSpectatorJoinedMessage* p = gamespectatorjoinedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameSpectatorJoinedMessage&>(
      ::_GameSpectatorJoinedMessage_default_instance_);
}
inline const ::GameSpectatorJoinedMessage& PokerTHMessage::gamespectatorjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameSpectatorJoinedMessage)
  return _internal_gamespectatorjoinedmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamespectatorjoinedmessage(
    ::GameSpectatorJoinedMessage* gamespectatorjoinedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamespectatorjoinedmessage_);
  }
  gamespectatorjoinedmessage_ = gamespectatorjoinedmessage;
  if (gamespectatorjoinedmessage) {
    _has_bits_[2] |= 0x00008000u;
  } else {
    _has_bits_[2] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameSpectatorJoinedMessage)
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::release_gamespectatorjoinedmessage() {
  _has_bits_[2] &= ~0x00008000u;
  ::GameSpectatorJoinedMessage* temp = gamespectatorjoinedmessage_;
  gamespectatorjoinedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::unsafe_arena_release_gamespectatorjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameSpectatorJoinedMessage)
  _has_bits_[2] &= ~0x00008000u;
  ::GameSpectatorJoinedMessage* temp = gamespectatorjoinedmessage_;
  gamespectatorjoinedmessage_ = nullptr;
  return temp;
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::_internal_mutable_gamespectatorjoinedmessage() {
  _has_bits_[2] |= 0x00008000u;
  if (gamespectatorjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpectatorJoinedMessage>(GetArenaForAllocation());
    gamespectatorjoinedmessage_ = p;
  }
  return gamespectatorjoinedmessage_;
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::mutable_gamespectatorjoinedmessage() {
  ::GameSpectatorJoinedMessage* _msg = _internal_mutable_gamespectatorjoinedmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameSpectatorJoinedMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamespectatorjoinedmessage(::GameSpectatorJoinedMessage* gamespectatorjoinedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamespectatorjoinedmessage_;
  }
  if (gamespectatorjoinedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameSpectatorJoinedMessage>::GetOwningArena(gamespectatorjoinedmessage);
    if (message_arena != submessage_arena) {
      gamespectatorjoinedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamespectatorjoinedmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00008000u;
  } else {
    _has_bits_[2] &= ~0x00008000u;
  }
  gamespectatorjoinedmessage_ = gamespectatorjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameSpectatorJoinedMessage)
}

// optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
inline bool PokerTHMessage::_internal_has_gamespectatorleftmessage() const {
  bool value = (_has_bits_[2] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || gamespectatorleftmessage_ != nullptr);
  return value;
}
inline bool PokerTHMessage::has_gamespectatorleftmessage() const {
  return _internal_has_gamespectatorleftmessage();
}
inline void PokerTHMessage::clear_gamespectatorleftmessage() {
  if (gamespectatorleftmessage_ != nullptr) gamespectatorleftmessage_->Clear();
  _has_bits_[2] &= ~0x00010000u;
}
inline const ::GameSpectatorLeftMessage& PokerTHMessage::_internal_gamespectatorleftmessage() const {
  const ::GameSpectatorLeftMessage* p = gamespectatorleftmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameSpectatorLeftMessage&>(
      ::_GameSpectatorLeftMessage_default_instance_);
}
inline const ::GameSpectatorLeftMessage& PokerTHMessage::gamespectatorleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameSpectatorLeftMessage)
  return _internal_gamespectatorleftmessage();
}
inline void PokerTHMessage::unsafe_arena_set_allocated_gamespectatorleftmessage(
    ::GameSpectatorLeftMessage* gamespectatorleftmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamespectatorleftmessage_);
  }
  gamespectatorleftmessage_ = gamespectatorleftmessage;
  if (gamespectatorleftmessage) {
    _has_bits_[2] |= 0x00010000u;
  } else {
    _has_bits_[2] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PokerTHMessage.gameSpectatorLeftMessage)
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::release_gamespectatorleftmessage() {
  _has_bits_[2] &= ~0x00010000u;
  ::GameSpectatorLeftMessage* temp = gamespectatorleftmessage_;
  gamespectatorleftmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::unsafe_arena_release_gamespectatorleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameSpectatorLeftMessage)
  _has_bits_[2] &= ~0x00010000u;
  ::GameSpectatorLeftMessage* temp = gamespectatorleftmessage_;
  gamespectatorleftmessage_ = nullptr;
  return temp;
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::_internal_mutable_gamespectatorleftmessage() {
  _has_bits_[2] |= 0x00010000u;
  if (gamespectatorleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpectatorLeftMessage>(GetArenaForAllocation());
    gamespectatorleftmessage_ = p;
  }
  return gamespectatorleftmessage_;
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::mutable_gamespectatorleftmessage() {
  ::GameSpectatorLeftMessage* _msg = _internal_mutable_gamespectatorleftmessage();
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameSpectatorLeftMessage)
  return _msg;
}
inline void PokerTHMessage::set_allocated_gamespectatorleftmessage(::GameSpectatorLeftMessage* gamespectatorleftmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gamespectatorleftmessage_;
  }
  if (gamespectatorleftmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GameSpectatorLeftMessage>::GetOwningArena(gamespectatorleftmessage);
    if (message_arena != submessage_arena) {
      gamespectatorleftmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamespectatorleftmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00010000u;
  } else {
    _has_bits_[2] &= ~0x00010000u;
  }
  gamespectatorleftmessage_ = gamespectatorleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameSpectatorLeftMessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::NetGameInfo_NetGameType> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameInfo_RaiseIntervalMode> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameInfo_EndRaiseMode> : ::std::true_type {};
template <> struct is_proto_enum< ::AnnounceMessage_ServerType> : ::std::true_type {};
template <> struct is_proto_enum< ::InitMessage_LoginType> : ::std::true_type {};
template <> struct is_proto_enum< ::PlayerListMessage_PlayerListNotification> : ::std::true_type {};
template <> struct is_proto_enum< ::SubscriptionRequestMessage_SubscriptionAction> : ::std::true_type {};
template <> struct is_proto_enum< ::JoinGameFailedMessage_JoinGameFailureReason> : ::std::true_type {};
template <> struct is_proto_enum< ::GamePlayerLeftMessage_GamePlayerLeftReason> : ::std::true_type {};
template <> struct is_proto_enum< ::RemovedFromGameMessage_RemovedFromGameReason> : ::std::true_type {};
template <> struct is_proto_enum< ::RejectGameInvitationMessage_RejectGameInvReason> : ::std::true_type {};
template <> struct is_proto_enum< ::StartEventMessage_StartEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::YourActionRejectedMessage_RejectionReason> : ::std::true_type {};
template <> struct is_proto_enum< ::AskKickDeniedMessage_KickDeniedReason> : ::std::true_type {};
template <> struct is_proto_enum< ::VoteKickReplyMessage_VoteKickReplyType> : ::std::true_type {};
template <> struct is_proto_enum< ::EndKickPetitionMessage_PetitionEndReason> : ::std::true_type {};
template <> struct is_proto_enum< ::StatisticsMessage_StatisticsData_StatisticsType> : ::std::true_type {};
template <> struct is_proto_enum< ::ChatMessage_ChatType> : ::std::true_type {};
template <> struct is_proto_enum< ::TimeoutWarningMessage_TimeoutReason> : ::std::true_type {};
template <> struct is_proto_enum< ::ReportAvatarAckMessage_ReportAvatarResult> : ::std::true_type {};
template <> struct is_proto_enum< ::ReportGameAckMessage_ReportGameResult> : ::std::true_type {};
template <> struct is_proto_enum< ::ErrorMessage_ErrorReason> : ::std::true_type {};
template <> struct is_proto_enum< ::AdminRemoveGameAckMessage_AdminRemoveGameResult> : ::std::true_type {};
template <> struct is_proto_enum< ::AdminBanPlayerAckMessage_AdminBanPlayerResult> : ::std::true_type {};
template <> struct is_proto_enum< ::PokerTHMessage_PokerTHMessageType> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameMode> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameState> : ::std::true_type {};
template <> struct is_proto_enum< ::NetPlayerAction> : ::std::true_type {};
template <> struct is_proto_enum< ::NetPlayerState> : ::std::true_type {};
template <> struct is_proto_enum< ::NetPlayerInfoRights> : ::std::true_type {};
template <> struct is_proto_enum< ::NetAvatarType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pokerth_2eproto
